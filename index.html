<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Roger Guo&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Roger Guo&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roger Guo&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Roger Guo's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Roger Guo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/DDIA-5-数据复制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/DDIA-5-数据复制/" itemprop="url">DDIA-5-数据复制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T09:19:53+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式数据系统"><a href="#分布式数据系统" class="headerlink" title="分布式数据系统"></a>分布式数据系统</h1><h2 id="分布式数据系统的设计目的"><a href="#分布式数据系统的设计目的" class="headerlink" title="分布式数据系统的设计目的"></a>分布式数据系统的设计目的</h2><ol>
<li>扩展性，当数据量或者读写负载增长的时候，如何分散到多台机器上</li>
<li>容错与高可用性， 当单机出现故障，如何可以让系统继续工作。</li>
<li>延迟考虑，就近为用户选择数据中心来提供服务。</li>
</ol>
<h2 id="系统扩展的方式和考虑的问题"><a href="#系统扩展的方式和考虑的问题" class="headerlink" title="系统扩展的方式和考虑的问题"></a>系统扩展的方式和考虑的问题</h2><h3 id="系统的扩展能力"><a href="#系统的扩展能力" class="headerlink" title="系统的扩展能力"></a>系统的扩展能力</h3><p>水平扩展和垂直扩展。共享内存架构与共享磁盘架构。成本问题。资源竞争问题。</p>
<h3 id="无共享结构"><a href="#无共享结构" class="headerlink" title="无共享结构"></a>无共享结构</h3><p>通过网络互联的节点，通过软件实现核心逻辑，提供统一的服务。<br>性价比高。<br>可以做到性能更强大。</p>
<h3 id="复制与分区"><a href="#复制与分区" class="headerlink" title="复制与分区"></a>复制与分区</h3><p>将数据分布在各个节点上的方法。分区和复制。</p>
<h1 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h1><p>能够在多台机器上存储相同的数据副本。达到以下目的：</p>
<ul>
<li>低延迟访问</li>
<li>高可用性</li>
<li>提高吞吐量</li>
</ul>
<p>本章假设是数据规模比较小，一份数据拷贝可以完整的保存在一个机器中。分布式数据库成为主流也是最近发生的事情。</p>
<h2 id="主节点和从节点，主从架构"><a href="#主节点和从节点，主从架构" class="headerlink" title="主节点和从节点，主从架构"></a>主节点和从节点，主从架构</h2><p>一个节点负责写入，其他节点负责读。写入节点负责更新所有的从属节点。</p>
<h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><ol>
<li>指定一个副本为主，程序中对数据库所有的写操作都发送到这个主节点，主节点把数据写入自己的数据库中。</li>
<li>主节点写完自己的数据后，把对数据的更改作为log或者更改流发送给所有的从属副本。每个从属副本得到更新日志后，完成数据写入本地的操作。</li>
<li>客户端 读区数据时候，可以在任何节点上执行查询。但是只有主节点可以写。</li>
</ol>
<img src="/2019/05/20/DDIA-5-数据复制/主从复制系统.png">
<h3 id="具有主从复制功能的数据库"><a href="#具有主从复制功能的数据库" class="headerlink" title="具有主从复制功能的数据库"></a>具有主从复制功能的数据库</h3><p>关系型，PostgresSQL, MySQL, Oracle Data Guard, SQL Server。<br>非关系型，MongoDB， RethinkDB和Expresso。<br>分布式消息队列，Kafka，RabbitMQ</p>
<h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><p>这是复制中非常重要的一个设计选项。对于关系型数据库，同步和异步是可以可配置的。而其他系统，只能hardcode一个选择。</p>
<img src="/2019/05/20/DDIA-5-数据复制/主从复制，一个同步节点，一个异步节点.png">
<ul>
<li>节点1是同步，主节点需要等节点1写完之后才能向客户端确认</li>
<li>节点2是异步，主节点不需要等节点2给出完成写入的信息，就可以向客户端确认。</li>
</ul>
<p>同步复制从节点的优点，从节点一直保留着最新的数据copy。如果主节点出现故障，从节点可以继续提供访问最新数据的能力。<br>缺点，如果同步节点无法确认，无论是网络原因还是其他原因，写入总会失败。主节点需要阻塞所有的写入操作直到从节点完成响应。</p>
<p>最佳配置是，一个同步节点，剩下的都是异步节点。这种配置也叫半同步。</p>
<p>达到极限吞吐量，就是全异步节点。但是无法保证持久化。有点是，无论从属节点怎么落后，都可以继续响应写入。<br>异步模式听起来不靠谱，但是还是被广泛使用，特别是那些从节点数量巨大或者分布地理环境特别广的情况。需要解决<strong>复制滞后问题</strong>。</p>
<h3 id="增配新的从节点"><a href="#增配新的从节点" class="headerlink" title="增配新的从节点"></a>增配新的从节点</h3><p>如何加一个新的从节点？</p>
<p>简单的把数据文件拷贝是不够的，因为客户端有可能在复制的时候继续更新原来的数据。<br>锁定数据库，使其不可写，直到复制完成，会影响可用性。</p>
<p>解决方案操作步骤：</p>
<ol>
<li>主节点在某个时间点生成快照文件。</li>
<li>把快照文件拷贝给新的从节点。</li>
<li>从节点连接到主节点，请求快照之后的更新日志。</li>
<li>从节点在快照文件的基础上执行这些更新日志，成为<strong>趋赶</strong>。接下来可以继续处理主节点的更新变化。并重复1到4.</li>
</ol>
<h3 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h3><h4 id="从节点失效：追赶式恢复"><a href="#从节点失效：追赶式恢复" class="headerlink" title="从节点失效：追赶式恢复"></a>从节点失效：追赶式恢复</h4><p>请求故障前最后一个事务滞后所有的更改，并且趋赶。</p>
<h4 id="主节点失效：节点切换"><a href="#主节点失效：节点切换" class="headerlink" title="主节点失效：节点切换"></a>主节点失效：节点切换</h4><p>需要把某个从节点升级成主节点。可以手动，可以自动。</p>
<p>自动切换步骤：</p>
<ol>
<li>确认主节点失效。基于超时的机制：节点间互发心跳。</li>
<li>选举新的主节点。选离主节点版本最新的节点，来最小化丢失数据的风险。</li>
<li>重新配置系统，使主节点生效。客户端需要把写请求发送给新的主节点。等原来的主节点上线时，要把它降级为从。</li>
</ol>
<h5 id="主节点切换时会遇到的问题"><a href="#主节点切换时会遇到的问题" class="headerlink" title="主节点切换时会遇到的问题"></a>主节点切换时会遇到的问题</h5><ol>
<li>异步复制的从节点，如果主节点挂掉之前，新的主节点并没有接收到最新的数据。这样当原来的主节点又上线后，需要处理写冲突的问题。通常的解决方案是原来主节点上没有完成复制数据丢弃掉。</li>
<li>丢弃数据的方案很危险。与主键分配有关，GitHub泄漏Private数据的例子。</li>
<li>两个节点都认为自己是主，称为脑裂。很危险，两个节点都接受写的请求，没有很好解决冲突的方法。可能需要强制关闭其中一个节点。</li>
<li>需要选择一个合适的超时时间来检测主节点失效。</li>
</ol>
<h3 id="复制日志的实现底层方式"><a href="#复制日志的实现底层方式" class="headerlink" title="复制日志的实现底层方式"></a>复制日志的实现底层方式</h3><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><p>执行SQL。有不适用的场景：</p>
<ol>
<li>非确定性函数语句，NOW（） RAND（）等</li>
<li>自增列问题</li>
<li>有副作用的语句（触发器，SP，自定函数）</li>
</ol>
<h4 id="基于预写日志（WAL）传输"><a href="#基于预写日志（WAL）传输" class="headerlink" title="基于预写日志（WAL）传输"></a>基于预写日志（WAL）传输</h4><p>存储引擎的磁盘数据结构。每个写操作都是追加写的方式写入日志：</p>
<ul>
<li>日志结构的存储引擎（SSTables，LSM-trees）。日志是存储方式</li>
<li>Btree的覆盖写结构，每次都会写WAL日志。</li>
</ul>
<p>不管哪种，都是日志。可以在另一个节点上构建copy。</p>
<p><strong>缺点</strong> 日志描述的数据结构非常底层，与存储引擎紧密耦合。数据库升级如果存储格式改版，可能会有问题。<br>复制协议必须要求版本严格一致，升级就必须停机。</p>
<h4 id="基于行的逻辑日志复制"><a href="#基于行的逻辑日志复制" class="headerlink" title="基于行的逻辑日志复制"></a>基于行的逻辑日志复制</h4><p>与存储引擎采用不同的日志格式。</p>
<ol>
<li>对于行插入，日志记录相关列的新值</li>
<li>对于行删除，日志表识这一行被删除</li>
<li>对于行更新，日志记录所有列的的新值</li>
</ol>
<p>事务执行时影响到多行，会产生多个这样的日志记录，最后是一个commit日志。MySQL的binlog使用该方式。</p>
<p>这样的逻辑日志，容易向后兼容。</p>
<h4 id="基于触发器的复制"><a href="#基于触发器的复制" class="headerlink" title="基于触发器的复制"></a>基于触发器的复制</h4><p><strong>优点</strong>高度灵活，<br>触发器执行自己写的应用代码，将数据的更改记录到一个单独的表中，然后外部逻辑处理这个表，完成自定义的逻辑，例如复制到另一个系统。<br><strong>缺点</strong>开销更高</p>
<h2 id="复制滞后问题"><a href="#复制滞后问题" class="headerlink" title="复制滞后问题"></a>复制滞后问题</h2><p>主从结构的复制，对于读操作密集的应用，如Web，是一个不错的选择。可以创建多个副本，来让读请求分配到就近的节点。</p>
<p>这种体系下的扩展，只需要添加更多的从副本，就可以提高服务器的吞吐量。但这种扩展一定是<strong>异步复制</strong>。这样会有复制滞后的问题。</p>
<p>这种不一致是一个暂时状态，但是并没有保证多长时间内会一致。也叫最终一致性（eventually consistency）。</p>
<h3 id="读自己的写"><a href="#读自己的写" class="headerlink" title="读自己的写"></a>读自己的写</h3><p>用户自己的刚刚提交的数据，返回提交成功，但刷新页面后又看不到数据。可能是因为第二次读，是读到了一个没有最新数据的节点。</p>
<img src="/2019/05/20/DDIA-5-数据复制/用户写入后从旧副本中读取数据。需要写后读(read-after-write)的一致性来防止这种异常.png">
<p>我们需要<strong>写后读一致性</strong></p>
<p>基于一些业务场景的方案：</p>
<ol>
<li>用户修改自己的资料场景。读用户<strong>可能已经修改过</strong>的内容时，都从主库读。别人无法修改这份数据，只有一个客户端会修改时，需要客户端配合记录修改的操作。</li>
<li>如果这份数据可以被多个人修改，上面的方法就不行了。需要用其他的标准来决定是否去主库读。例如可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。还可以监控从库的复制延迟，防止任向任何滞后超过一分钟到底从库发出查询。</li>
<li>客户端可以记住最近一次写入的时间戳，服务器检查这个时间戳和从库的同步时间比较。来验证数据是否有效。</li>
<li>如果副本分布在多个数据中心，则需要一个中心路由判断。</li>
</ol>
<p>多客户端时会变得更复杂。需要跨设备的读写一致性。</p>
<p>其他问题：</p>
<ul>
<li>记住用户上次更新时间戳的方法变得更加困难。元数据需要一个中心存储。</li>
<li>如很难保证来自不同设备的连接会路由到同一数据中心</li>
</ul>
<h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><p>读到新值后，之后不再会读到旧值。</p>
<p>看到新的评论刷新后又消失的例子。</p>
<img src="/2019/05/20/DDIA-5-数据复制/用户首先从新副本读取，然后从旧副本读取。时光倒流。为了防止这种异常，我们需要单调的读取。.png">
<p>确保每个用户总是固定的从一个副本中读数据。不要随记路由。</p>
<p>需要解决节点失效的影响。</p>
<h3 id="前缀一致读"><a href="#前缀一致读" class="headerlink" title="前缀一致读"></a>前缀一致读</h3><p>聊天记录的复制问题。对话，问答的happen before逻辑，需要在复制时候解决。不要乱序</p>
<img src="/2019/05/20/DDIA-5-数据复制/如果某些分区的复制速度慢于其他分区，那么观察者在看到问题之前可能会看到答案。.png">
<p>这个是分区数据库的一个特殊问题，需要<strong>前缀一致读</strong></p>
<p>一个解决方案时确保有因果关系的数据写入都交给一个分区解决。但是会影响效率。也有新的算法来解决逻辑先后问题。</p>
<h3 id="复制滞后的解决方案"><a href="#复制滞后的解决方案" class="headerlink" title="复制滞后的解决方案"></a>复制滞后的解决方案</h3><p>当需要对写后读等问题支持的时候，一定要小心同步复制和异步复制的配置问题，与系统设计时的思考一致，不然会出大问题。</p>
<p>应用层可以解决滞后问题，但是代价是更复杂更容易出错。</p>
<p>分布式事务，有人断言，最终一致性是分布式系统最终的选择。</p>
<h2 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h2><p>适用多数据中心的架构，如果是一般的单数据中心，还是主从好，因为简单不容易出错。</p>
<p>主从问题就是主节点网络中断后，写入操作都会出问题。</p>
<p>多主结构，就是有多个主节点接收写操作。数据中心之间的复制，由各自主节点之间通信，而数据中心内部的复制，由其中的主节点，复制到其他的从节点。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><h4 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h4><p>多领导者配置中可以在每个数据中心都有主库。 图中展示了这个架构的样子。 在每个数据中心内使用常规的主从复制；在数据中心之间，每个数据中心的主库都会将其更改复制到其他数据中心的主库中。</p>
<img src="/2019/05/20/DDIA-5-数据复制/跨多个数据中心的多主复制.png">
<p>单主，多主复制之间的差异：</p>
<ol>
<li>性能。<br>主从架构会影响写入延迟。多主结构，对于本地数据中心可以快速响应，然后用异步复制，复制到其他数据中心。</li>
<li>容忍数据中心失效<br>多主更好。没有切换操作。</li>
<li>容忍网络问题<br>多主更好。</li>
</ol>
<h6 id="商业数据库支持"><a href="#商业数据库支持" class="headerlink" title="商业数据库支持"></a>商业数据库支持</h6><p>多主复制MySQL的Tungsten Repliactor，PostgreSQL的BDR，Orcale的GoldenGate。</p>
<h5 id="多主的缺点"><a href="#多主的缺点" class="headerlink" title="多主的缺点"></a>多主的缺点</h5><p>必须处理写入冲突。</p>
<p>由于多主复制都是现在数据库中新增的高级功能，有些交互，触发器函数，自增主键等会有副作用。有些人认为多主很危险，应该尽量避免。</p>
<h4 id="离线客户端操作"><a href="#离线客户端操作" class="headerlink" title="离线客户端操作"></a>离线客户端操作</h4><p>例如日历，Todo，会议安排等。每一个设备都是一个充当主节点的本地数据库。当设备再次上线时候，需要与服务器同步。</p>
<p>CouchDB就是为这种操作模式设计的。</p>
<h4 id="协作编辑"><a href="#协作编辑" class="headerlink" title="协作编辑"></a>协作编辑</h4><p>Google Docs。</p>
<p>可编辑力度非常小，也会有多主复制的挑战—写入冲突。</p>
<h3 id="处理写冲突（多主）"><a href="#处理写冲突（多主）" class="headerlink" title="处理写冲突（多主）"></a>处理写冲突（多主）</h3><p>解决多主复制的最大问题。例子，多人编辑Wiki。</p>

<h4 id="同步与异步冲突检测"><a href="#同步与异步冲突检测" class="headerlink" title="同步与异步冲突检测"></a>同步与异步冲突检测</h4><p>简单的允许多主节点并行接受写请求，会产生冲突问题。</p>
<p>同步方式，需要所有主节点确认写入后才能返回，失去了多主节点的优势，退化成了单主结构。</p>
<h4 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h4><ul>
<li>总是把特定用户的更新请求路由到特定的数据中心。基本等价于主从模型</li>
<li>问题在于，如果某个数据中心故障，之前的配置需要被修改到可用的数据中心时，会有问题。无法避免冲突。</li>
</ul>
<h4 id="收敛于一致状态"><a href="#收敛于一致状态" class="headerlink" title="收敛于一致状态"></a>收敛于一致状态</h4><ul>
<li>给每个写入分配一个类似UUID的东西，选最高的ID为胜者。缺点，数据丢失。</li>
<li>为每个副本分配一个UUID，预先制定副本之间的优先级。缺点，数据丢失。</li>
<li>合并冲突数据。</li>
<li>保留冲突信息，给应用层解决。（时候解决冲突，可能需要提示用户）</li>
</ul>
<h4 id="自定义冲突解决逻辑"><a href="#自定义冲突解决逻辑" class="headerlink" title="自定义冲突解决逻辑"></a>自定义冲突解决逻辑</h4><p>最适合的方式可能还是<strong>应用层程序</strong>来解决冲突。</p>
<p>在写入和读时执行冲突解决代码的逻辑：</p>
<ul>
<li>写时执行<br>只要数据库系统在执行复制的change日志时，监测到冲突，就调用应用层的冲突解决程序。<br>Bucardo支持写Perl。这个解决方法通常只能后台运行。</li>
<li>读时执行<br>发现冲突时，把所有的冲突值都暂存起来。下一次读时，把这些值一并返回给应用层。让用户来处理。<br>CouchDB采用这样的处理方式。</li>
</ul>
<h4 id="冲突的定义"><a href="#冲突的定义" class="headerlink" title="冲突的定义"></a>冲突的定义</h4><p>根据业务场景区分。有些显而易见，例如两个人同时修改一个record的某一列。有些不是这么直接，例如会议室预定系统，或者有限商品的秒杀系统。</p>
<h4 id="自动冲突解决"><a href="#自动冲突解决" class="headerlink" title="自动冲突解决"></a>自动冲突解决</h4><p>冲突解决规则可能越来越复杂，而且自定义代码很容易出错。</p>
<p>一些方法：</p>
<ol>
<li>CRDT（conflict-free replicated datatypes），map orderedlist counter，可以用内置的方式自动解决。</li>
<li>使用可合并的数据结构。类似git的合并。</li>
<li>操作转换（operational transformation）是Google Docs等背后的解决方法。专门为可同时编辑的有序表设计。</li>
</ol>
<h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><p>三种多主的复制拓扑结构</p>
<img src="/2019/05/20/DDIA-5-数据复制/三个可以设置多领导者复制的示例拓扑.png">
<p>环形为防止无限循环，每个节点需要一个UUID，复制的时候带上已经完成过的节点ID。</p>
<p>星型和环形的问题，是节点故障。修复之前会影响其他节点。</p>
<p>全链路问题，某些链路快，某些慢，会导致复制日志覆盖，产生类似前缀一致读的问题。</p>
<img src="/2019/05/20/DDIA-5-数据复制/使用多主程序复制时，可能会在某些副本中写入错误的顺序。.png">
<h2 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h2><p>设计思路：放弃使用主节点，允许任何副本直接处理写请求。</p>
<p>这类数据库也被称为Dynamo风格数据库（不是AWS的那个，AWS的DynamoDB是单主架构）。</p>
<p>在一些无领导者的实现中，客户端直接将写入发送到到几个副本中，而另一些情况下，一个<strong>协调者（coordinator）</strong>节点代表客户端进行写入。但与主库数据库不同，协调者不执行特定的写入顺序。我们将会看到，这种设计上的差异对数据库的使用方式有着深远的影响。</p>
<h3 id="节点失效时写入数据库"><a href="#节点失效时写入数据库" class="headerlink" title="节点失效时写入数据库"></a>节点失效时写入数据库</h3><p>核心思想，并发读多个副本，使读到最新数据的概率达到最高。</p>

<h4 id="读修复与反熵"><a href="#读修复与反熵" class="headerlink" title="读修复与反熵"></a>读修复与反熵</h4><ul>
<li>读修复。并行读多个副本时，可以检测到过期的返回值。适合被频繁读取的场景。</li>
<li>反熵。后台进程不断查找副本之间的差异，完成更新。</li>
</ul>
<p>​并不是所有的系统都实现了这两个;例如，Voldemort目前没有反熵过程。请注意，如果没有反熵过程，某些副本中很少读取的值可能会丢失，从而降低了持久性，因为只有在应用程序读取值时才执行读修复。</p>
<h4 id="读写quorum（法定人数）"><a href="#读写quorum（法定人数）" class="headerlink" title="读写quorum（法定人数）"></a>读写quorum（法定人数）</h4><p>w + r &gt; n</p>
<p>写至少需要确认w个节点，读必须读到r个节点，n是副本总数。</p>
<p>通常w=r=（n+1）/ 2，也可以灵活配置。例如读多写少的情况，可以配置w=n，r=1.但是更容易写入失败。</p>
<p>仲裁条件定义了可以容忍的失效节点个数。</p>
<h4 id="Quorum一致性的局限性"><a href="#Quorum一致性的局限性" class="headerlink" title="Quorum一致性的局限性"></a>Quorum一致性的局限性</h4><p>关键在于读写有重叠。即使在w+r》n的情况下，也存在返回旧值的边界条件。主要取决于现实情况：</p>
<ol>
<li>如果采用了sloppy quorum</li>
<li>并发写冲突时候，需要根据时间戳挑选胜者，如果时钟偏差，会造成数据丢失。</li>
<li>读写同时发生，写操作可能只完成了一半节点，返回新旧值有不确定性。</li>
<li>如果写入失败，已经成功的节点不会回滚。会读到新值。</li>
<li>其他边界情况</li>
</ol>
<p>无法得到复制滞后问题的一致性保证。</p>
<h5 id="监控旧值"><a href="#监控旧值" class="headerlink" title="监控旧值"></a>监控旧值</h5><p>​<br>从运维的角度来看，监视你的数据库是否返回最新的结果是很重要的。</p>
<h5 id="sloppy-quorum与数据回传"><a href="#sloppy-quorum与数据回传" class="headerlink" title="sloppy quorum与数据回传"></a>sloppy quorum与数据回传</h5><ul>
<li>容错能力。网络中断，无法满足法定人数，会使系统无法读，</li>
<li>无法满足法定人数时的出错处理。是否把错误返回客户端，或者是否还接收写请求。</li>
<li>放松仲裁方案允许不满足法定人数的写</li>
<li>一旦网络恢复，临时节点需要向原主节点完成数据传输（回传）。</li>
</ul>
<p>​在所有常见的Dynamo实现中，sloppy quorum是可选的。在Riak中，它们默认是启用的，而在Cassandra和Voldemort中它们默认是禁用的。</p>
<h5 id="多数据中心操作"><a href="#多数据中心操作" class="headerlink" title="多数据中心操作"></a>多数据中心操作</h5><p>n是所有数据中心的节点总数。配置时，可以指定每个数据中心各有多少副本。</p>
<p>Cassandra和Voldemort在正常的无主模型中实现了他们的多数据中心支持。客户端通常只等待来自其本地数据中心内的法定节点的确认。</p>
<p>Riak将客户端和数据库节点之间的所有通信保持在一个数据中心本地，因此n描述了一个数据中心内的副本数量。数据库集群之间的跨数据中心复制在后台异步发生，其风格类似于多领导者复制</p>
<h3 id="检测并发写"><a href="#检测并发写" class="headerlink" title="检测并发写"></a>检测并发写</h3><p>Dynamo风格的数据库允许多个客户端同时写入相同的Key，这意味着即使使用严格的法定人数也会发生冲突。<br>读修复或带数据回传时也可能会产生冲突。</p>
<img src="/2019/05/20/DDIA-5-数据复制/并发写入Dynamo风格的数据存储：没有明确定义的顺序.png">
<p>解决冲突：</p>
<h4 id="最后写入胜利（丢弃并发写入）"><a href="#最后写入胜利（丢弃并发写入）" class="headerlink" title="最后写入胜利（丢弃并发写入）"></a>最后写入胜利（丢弃并发写入）</h4><p>强制排序，例如时间戳，最大的获胜。是Cassandra唯一支持的冲突解决方法，也是Riak中的一个可选方案。</p>
<p>LWW（last write wins）缺点，牺牲数据永久性。<br>如果丢失数据不可接受，LWW是解决冲突的一个很烂的选择。</p>
<p>与LWW一起使用数据库的唯一安全方法是确保一个pk只写入一次，然后视为不可变，从而避免对同一个key进行并发更新。</p>
<h4 id="Happens-before关系和并发"><a href="#Happens-before关系和并发" class="headerlink" title="Happens-before关系和并发"></a>Happens-before关系和并发</h4><p>需要一个算法判断两个操作是否并发。比如插入之后才会更新。</p>
<p><strong>确定先后关系</strong></p>
<p>购物车的例子。</p>
<img src="/2019/05/20/DDIA-5-数据复制/两个客户端同时编辑购物车.png">
<p>算法工作流程：</p>
<ol>
<li>服务器维护pk的版本号</li>
<li>客户端读时，返回所有的值的最新版本号。（写前必须读）</li>
<li>客户端写pk时，必须传入之前读的版本号，读到的值和新值合并后的集合。</li>
<li>服务端接收到特定版本的写入时，覆盖版本号。</li>
</ol>
<h4 id="合并同时写入的的值"><a href="#合并同时写入的的值" class="headerlink" title="合并同时写入的的值"></a>合并同时写入的的值</h4><p>购物车例子中，加入商品操作，可以合并，去掉重复值。</p>
<p>删除适用墓碑标记。</p>
<p>使用专门的数据结构，CRDT。支持高校合并，删除标记。</p>
<h4 id="版本矢量"><a href="#版本矢量" class="headerlink" title="版本矢量"></a>版本矢量</h4><p>多副本没有主节点的购物车。</p>
<p>需要为每个一个副本和每个主键都定一个版本号。每个副本在处理写入时增加自己的版本号，并且跟踪从其他副本中看到的版本号。这个信息指出了要覆盖哪些值，以及保留哪些值作为兄弟。</p>
<p>所有副本的版本号合集成为版本矢量。也有虚线版本适量。</p>
<p>另外，就像在单个副本的例子中，应用程序可能需要合并兄弟副本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/DDIA-4-数据编码与演化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/DDIA-4-数据编码与演化/" itemprop="url">DDIA-4-数据编码与演化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T20:46:32+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应用程序在根据需求不断的变化时，往往会对其存储的数据有更改的情况。</p>
<p>当数据格式或者模式发生变化的时候，经常需要对应用程序的代码修改。对于一个大型程序，这并非容易。</p>
<ol>
<li>服务器应用需要滚动升级。这样部署新版本的时候，不需要停止服务。</li>
<li>客户端升级，只能寄希望于用户。很有可能用户永远不会升级。</li>
</ol>
<p>升级中需要考虑的亮点：</p>
<ol>
<li>向前兼容。新代码读老数据。（容易）</li>
<li>向后兼容。老代码读新数据。（难）</li>
</ol>
<h1 id="数据编码格式"><a href="#数据编码格式" class="headerlink" title="数据编码格式"></a>数据编码格式</h1><p>程序中的数据，至少有两种不同的表示形式</p>
<ol>
<li>内存中。</li>
<li>写入文件或者发送到网络中。</li>
</ol>
<p>两种形式之间的转换，成为序列化Serialize和反序列化Deserialize。或者编码Encode，解码Decode。</p>
<h2 id="语言特定的格式"><a href="#语言特定的格式" class="headerlink" title="语言特定的格式"></a>语言特定的格式</h2><p>比如Java中java.io.Serializable接口；Ruby的Marshal；Python的pickle等。</p>
<p>这类编码的问题：</p>
<ol>
<li>编码和语言绑定在一起，无法跨语言使用。</li>
<li>安全问题。远程执行任意代码。可以恢复成任意类，意味着Decode的过程中需要有能力创建任意的类。</li>
<li>向前向后兼容问题。</li>
<li>效率低。比如Java内置序列化。</li>
</ol>
<h2 id="JSON，XML与它们的二进制遍体"><a href="#JSON，XML与它们的二进制遍体" class="headerlink" title="JSON，XML与它们的二进制遍体"></a>JSON，XML与它们的二进制遍体</h2><p>XML被批评主要在于其冗长和不必要的复杂。JSON受欢迎主要是在Web浏览器中的原生支持。CSV格式简单，功能弱一些。</p>
<p>它们都是文本格式的，可读性强。但也有<strong>问题</strong>：</p>
<ol>
<li>数字编码有很多模糊的地方。XML和CSV中无法区分数字和数字组成的字符串；JSON不区分整数和浮点数，而且不指定精度。</li>
<li>对Unicode字符串支持好，但是不支持二进制数据。所以人们使用Base64将二进制数据编码成String来传递。</li>
<li>XML和JSON都有可选的模式支持。数据的正确性解释，取决于模式中的信息，</li>
<li>CSV没有任何模式，需要程序解释。</li>
</ol>
<h2 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h2><p>更紧凑更快的解析格式。可以节省空间和时间。在TB级别的数据时尤其关键。</p>
<h3 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h3><p>最最基础的二进制化JSON方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;userName&quot;: &quot;Martin&quot;,</span><br><span class="line">    &quot;favoriteNumber: 1337,</span><br><span class="line">    &quot;interests&quot;: [&quot;daydreaming&quot;, &quot;hacking&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/05/15/DDIA-4-数据编码与演化/一条JSON记录对应的MessagePack的二进制表示.png">
<p>上图的二进制的结构解读：</p>
<ol>
<li>第一个字节0x83，表示接下来是包含三个fields的对象（第四位0x03，高四位0x80）</li>
<li>第二字节0xa8，表示接下来的字符串，长度为八个字节</li>
<li>再往下的八个字节时ASCII的字段，userName</li>
<li>在接下来7个字节前缀0xa6表示后面有六个字节，Martin</li>
</ol>
<p>结论：<br>整体编码占用66个字节，比原始的JSON编码（81个）少一些，但是不明显。</p>
<p>下面的方案中只用32个字节就可以完成同样记录的二进制化。</p>
<h2 id="Thrift与Protocol-Buffers"><a href="#Thrift与Protocol-Buffers" class="headerlink" title="Thrift与Protocol Buffers"></a>Thrift与Protocol Buffers</h2><p>它们都是基于相同原理的二进制编码方式。都需要使用<strong>模式（Schema）</strong>来编码任意数据。</p>
<ul>
<li><p>使用Thrift的接口定义语言（IDL）来描述模式：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    1: required string       userName,</span><br><span class="line">    2: optional i64          favoriteNumber,</span><br><span class="line">    3: optional list&lt;string&gt; interests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Protocol Buffers的等效模式定义看起来非常相似：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    required string user_name       = 1;</span><br><span class="line">    optional int64  favorite_number = 2;</span><br><span class="line">    repeated string interests       = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Thrift和Protocol Buffers都有各自的代码生成工具，并支持各种编程语言。应用程序可以直接使用生成的代码完成Encode，Decode的工作。</p>
<h3 id="Thrift的BinaryProtocal与CompactProtocol"><a href="#Thrift的BinaryProtocal与CompactProtocol" class="headerlink" title="Thrift的BinaryProtocal与CompactProtocol"></a>Thrift的BinaryProtocal与CompactProtocol</h3><ul>
<li><p>BinaryProtocal</p>
<img src="/2019/05/15/DDIA-4-数据编码与演化/使用BinaryProtocol的编码例子.png">
<p>需要59个字节。</p>
</li>
</ul>
<ol>
<li>每个字段有一个类型注视（是字符串，整数，列表等），并可以指定长度（字符串长度，列表的count）</li>
<li>与MessagePack最大的区别是没有字段名。</li>
</ol>
<ul>
<li><p>CompactProtocol</p>
<img src="/2019/05/15/DDIA-4-数据编码与演化/使用CompactProtocol的编码例子.png">
<p>只需要34字节。</p>
</li>
</ul>
<ol>
<li>通过将字段类型和标签号打包在一个字节中。</li>
<li>使用可变长度整数。 1337，不用一个字节中的全部8位都表示数值。使用两个字节编码，每个字节的最高位表示是否还有更多字节。</li>
<li>可变长度整数意味着，-64到63的数字可以用一个字节表示，-8192到8191之间用两个字节。</li>
</ol>
<h3 id="Protocol-Buffer编码"><a href="#Protocol-Buffer编码" class="headerlink" title="Protocol Buffer编码"></a>Protocol Buffer编码</h3><p>只有一种编码模式。与CompactProtocol很类似。只用33个字节。</p>

<p>不同之处：</p>
<ol>
<li>表示字段位置和类型的一个压缩的字节中的位数分配不同</li>
<li>表示数字的填充方式不同。例如1337的表示一个是最左，一个是最右。</li>
<li>表示列表的方式不同，Thrift是有列表type，而protocol buffer是用重复的field tag来表示列表或者数组</li>
<li>没有end of struct</li>
</ol>
<p>一个细节，optional字段对于编码encode的结果没有任何影响（二进制中不会体现一个field是optional的）。optional的体现在于在Runtime 时后可以做检查，捕获错误。</p>
<h3 id="字段标签和模式演化"><a href="#字段标签和模式演化" class="headerlink" title="字段标签和模式演化"></a>字段标签和模式演化</h3><p>如何保证修改模型时候，既保证向前又保证向后兼容呢？</p>
<p>可以根据之前的例子看出，每个字段的标签号码（1，2，3等），与它的类型整合在一个字节中。由此看出field tag对编码数据的含义至关重要。</p>
<ol>
<li>不能随便改字段的标签，会导致现有的编码无效。保证这个原则，实现向后兼容。</li>
<li>可以添加新的字段，只需要用一个新的标签。如果老代码读到带有新标签的数据，那么会忽略。这样可以向前兼容。</li>
<li>新增字段不可以是required字段，或者没有默认值的字段，向后兼容。违反的结果，会让老数据无法被新代码读。</li>
<li>删除字段只可以删除可选字段，老代码读新数据时才不会出检查问题，向前兼容。</li>
</ol>
<h3 id="数据类型和模式演化"><a href="#数据类型和模式演化" class="headerlink" title="数据类型和模式演化"></a>数据类型和模式演化</h3><p>改变数据类型会如何？可能是可以做的，但是风险在于丢失精度或者数据截断。</p>
<ol>
<li>例如一个32位整数变成一个64位的整数。新代码可以读老数据，因为可以用0填充缺失的位。如果是老代码读64位的数据，使用32位int存，则会截断。</li>
<li>Protocol Buffer中没有数组或者列表。所以如果把单值的类型变成列表类型的，老代码读新数据，只会留下最后一个值。而新代码没什么问题。</li>
</ol>
<h2 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h2><p>另一种二进制编码格式。由于Thrift不适合Hadoop的用例，因此Avro在2009年作为Hadoop的子项目启动。</p>
<p>Avro也用<strong>模式</strong>来制定数据结构的编码。它有两种语言：一种是Avro IDL，用于人工编辑，一种是基于JSON的易于机器读。</p>
<p>基于Avro IDL的模式的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">record Person &#123;</span><br><span class="line">    string                userName;</span><br><span class="line">    union &#123; null, long &#125;  favoriteNumber = null;</span><br><span class="line">    array&lt;string&gt;         interests;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其等价JSON格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;record&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Person&quot;,</span><br><span class="line">    &quot;fields&quot;: [</span><br><span class="line">        &#123;&quot;name&quot;: &quot;userName&quot;, &quot;type&quot;: &quot;string&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;: &quot;favoriteNumber&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;long&quot;], &quot;default&quot;: null&#125;,</span><br><span class="line">        &#123;&quot;name&quot;: &quot;interests&quot;, &quot;type&quot;: &#123;&quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &quot;string&quot;&#125;</span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/05/15/DDIA-4-数据编码与演化/使用Avro编码的例子.png">
<p>主要区别：</p>
<ol>
<li>模式中没有标签号，是目前见过的所有编码中最紧凑的。</li>
<li>字节序列中也没有类型信息。只是连在一起的一些列值组成。字符串是长度加UTF-8的字节流，整数使用可变长度编码（与CompactProtocol相同）。但是并没有任何信息表示这些field是什么类型。</li>
</ol>
<p>如何解析？<br>需要预先读区模式信息的数据，然后按照模式的顺序，遍历这些字段。</p>
<p>然后直接用模式中的字段信息来决定每个field到底是什么类型。</p>
<p>这意味着，读取数据的代码，必须使用当时写入数据是使用的<strong>模式</strong>，才可以正确还原数据。如果中间有任何不匹配，都无法解析。</p>
<h3 id="Avro中的写模式和读模式"><a href="#Avro中的写模式和读模式" class="headerlink" title="Avro中的写模式和读模式"></a>Avro中的写模式和读模式</h3><ul>
<li>写模式。encode时，使用的模式，可以将这个模式编译在应用中。</li>
<li>读模式。decode时，应用代码依赖的模式，这个模式可能是在应用程序build过程中基于模式语言动态生成的。</li>
</ul>
<p><strong>Avro关键思想</strong> ，写模式和读模式不一定需要完全一样，只需要兼容。当数据被Decode的时候，Avro的 Library通过对比查看写模式和读模式之间的差异，把数据从写模式转换成读模式，然后继续decode。Avro规范定义了这种解决方法的工作原理。</p>
<p>假如写模式和读模式的字段顺序不同，也没有关系，如果读的过程中遇到了只有在写模式中出现的字段，那可以忽略。如果在一个字段只在读模式中有，那么可以填充默认值。</p>
<h3 id="Avro模式演化"><a href="#Avro模式演化" class="headerlink" title="Avro模式演化"></a>Avro模式演化</h3><ol>
<li>只能添加或删除有默认值的字段。</li>
<li>如果添加一个没有默认值的字段，破坏了向后兼容性</li>
<li>如果删除一个没有默认值的字段，破坏了向前兼容性。</li>
<li>null值的处理。</li>
</ol>
<h4 id="关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？"><a href="#关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？" class="headerlink" title="关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？"></a>关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？</h4><p>这个问题要取决于Avro使用的上下文：</p>
<ol>
<li>有很多记录的大文件。<br> Avro常见场景。尤其是Hadoop的上下文中。上百万的数据，都是用相同的模式编码。这种情况下，该文件的写入模式可以嵌入到文件的开头。Avro可以制定一个文件格式来做到这一点。</li>
<li>具有单独写入记录的数据库<br> 数据库中的记录，可能是在不同的时间点写入的。每个时间点可能使用不同的写入模式。最简单的发难是在每个编码记录的开始处，包含一个版本号，制定着写入模式的版本。在数据库的一个地方存储所有的写入模式列表。这样读取时可以直到数据的写入模式。Espresso就是这样工作的。</li>
<li>通过网络连接发送记录<br> 连接双方可以在建立连接时，协商模式的版本，然后在这个连接会话中使用这个模式。这也是Avro RPC的协议原理。</li>
</ol>
<h3 id="动态生成的模式"><a href="#动态生成的模式" class="headerlink" title="动态生成的模式"></a>动态生成的模式</h3><p>Avro的一个重要优点就是不包含任何标签号。</p>
<p>不包含标签号是好理由： 动态生成模式更友好。</p>
<p>关系型数据库，使用二进制方式，把内容转存到一个文件的例子。</p>
<ol>
<li>根据关系模型，生成Avro模式。并使用这个模式编码，把数据库内容倒入Avro对象容器文件中。列名对应Avro的field</li>
<li>如果数据库的关系模型发生变化，则可以更新Avro的模式，使用新的Avro导出数据。不需要关注模式的改变，字段是通过名字来表识的，所以更新后的写模式仍然可以和老的读模式匹配。</li>
</ol>
<p>相比之下，Thrift和Protocol  Buffer都需要手动分配新的标签。而且还需要完成从数据库列名到新标签的映射。</p>
<h3 id="代码生成和动态类型语言"><a href="#代码生成和动态类型语言" class="headerlink" title="代码生成和动态类型语言"></a>代码生成和动态类型语言</h3><ol>
<li>静态类型语言<br>Thrift和Protocol Buffer依赖于代码生成。定义了模式之后，可以跨语言使用模式。对于Java，C++等语言非常有用。可以转换成内存结构，并且支持IDE的类型检查。</li>
<li>动态语言（Javascript，Ruby，Python），因为没有编译时检查，代码生成没有什么意义。</li>
<li>Avro为静态语言也提供了代码生成的工具，但是它也可以在在不生成代码的情况下使用。如果是一个嵌入了writer模式的对象容器文件，可以简单的使用Avro库打开，并用和JSON文件一样的方式查看。因为文件是字描述的。</li>
</ol>
<h2 id="模式的优点"><a href="#模式的优点" class="headerlink" title="模式的优点"></a>模式的优点</h2><ol>
<li>模式语言简单。原理简单，使用更简单，广泛的编程语言支持。</li>
<li>比JSON，XML，CSV，更紧凑</li>
<li>模式有文档价值，不需要额外的手工维护的文档</li>
</ol>
<h1 id="数据流模式"><a href="#数据流模式" class="headerlink" title="数据流模式"></a>数据流模式</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>向数据库中存储内容，就是在给未来的自己发送消息。</p>
<p>这种情况下，<strong>向后兼容</strong>是非常重要的。否则新代码无法读取存在数据库中以前写入的数据。</p>
<p>需要注意的一点是，老代码读区新代码写入的数据时，更新后又写会数据库，要当心不要丢失新数据格式的原来的信息。</p>
<p>将数据重写（迁移）到一个新的模式当然是可能的，但是在一个大数据集上执行是一个昂贵的事情，所以大多数数据库如果可能的话就避免它。</p>
<h2 id="基于服务的数据流：REST与RPC"><a href="#基于服务的数据流：REST与RPC" class="headerlink" title="基于服务的数据流：REST与RPC"></a>基于服务的数据流：REST与RPC</h2><h3 id="Web的方式，基于HTTP。"><a href="#Web的方式，基于HTTP。" class="headerlink" title="Web的方式，基于HTTP。"></a>Web的方式，基于HTTP。</h3><ol>
<li>使用客户端（浏览器，移动应用，PC应用等）访问服务器数据。</li>
<li>使用服务器访问另一个服务器的Web服务。这样的应用构建方式最近叫做微服务。</li>
</ol>
<p>微服务的关键设计目标是，通过使服务可独立部署和演化，让应用程序更易于更改和维护。这样每一个团队可以能够经常发布新的版本，而不必与其他团队协调。因此服务器和客户端之间的数据编码必须在不同版本的API之间兼容。</p>
<p>REST使一种HTTP服务的设计理念。SOAP基于XML，基于Web服务时，API被称为WSDL，支持代码生成。SOAP严重依赖工具，代码生成和IDE支持，与SOAP集成的成本很高。</p>
<p>RESTful的API更简单，格式如OpenAPI，Swagger。<br>由于互联网上存在广泛的安全威胁，REST的安全生态系统非常强大，从防火墙到OAUTH（身份验证/授权）</p>
<h3 id="远程过程调用RPC的问题"><a href="#远程过程调用RPC的问题" class="headerlink" title="远程过程调用RPC的问题"></a>远程过程调用RPC的问题</h3><p>看起来像是在使用本地方法。但是有缺陷需要解决：</p>
<ol>
<li>网络请求不可预测。速度方面，网络失败，需要准备重试的逻辑。</li>
<li>可能超时，没有结果。无法知道发生了什么。</li>
<li>重试的时候，需要保证调用的方法有幂等性保证。</li>
<li>序列化时的问题，效率方面，编程语言方面的限制。</li>
</ol>
<h3 id="RPC发展"><a href="#RPC发展" class="headerlink" title="RPC发展"></a>RPC发展</h3><p>这种新一代的RPC框架更加明确的是，远程请求与本地函数调用不同。例如，Finagle和Rest.li 使用futures（promises）来封装可能失败的异步操作。Futures还可以简化需要并行发出多项服务的情况，并将其结果合并。 gRPC支持流，其中一个调用不仅包括一个请求和一个响应，还包括一系列的请求和响应。</p>
<p>使用二进制编码格式的自定义RPC协议可以实现比通用的JSON over REST更好的性能。但是，RESTful API还有其他一些显着的优点：对于实验和调试（只需使用Web浏览器或命令行工具curl，无需任何代码生成或软件安装即可向其请求），它是受支持的所有的主流编程语言和平台，还有大量可用的工具（服务器，缓存，负载平衡器，代理，防火墙，监控，调试工具，测试工具等）的生态系统。由于这些原因，REST似乎是公共API的主要风格。 RPC框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一数据中心内。</p>
<h3 id="RPC的数据编码和演化"><a href="#RPC的数据编码和演化" class="headerlink" title="RPC的数据编码和演化"></a>RPC的数据编码和演化</h3><p>假定所有的服务器都会先更新，其次是所有的客户端。只需要在请求上具有向后兼容性，并且对响应具有前向兼容性。</p>
<p>RPC方案中的向前向后兼容的解决方法，可他们在数据编码中使用的方法也有关。</p>
<h2 id="异步消息传递，消息代理"><a href="#异步消息传递，消息代理" class="headerlink" title="异步消息传递，消息代理"></a>异步消息传递，消息代理</h2><p>中间件，可以低延迟的响应web请求。</p>
<p>优点：</p>
<ol>
<li>如果接收方不可用，可以当作缓冲区，暂存消息，等恢复之后一起消费，实现HA。</li>
<li>可以自动重新发送消息到崩溃进程。防止丢消息。</li>
<li>结偶发送方和接收方，双方不需要知道对方的IP</li>
<li>支持广播，一条消息被多个人接收</li>
<li>子系统之间结偶</li>
</ol>
<p>可以使用任何编码方式。只要兼容。</p>
<h2 id="分布式Actor框架"><a href="#分布式Actor框架" class="headerlink" title="分布式Actor框架"></a>分布式Actor框架</h2><p>并发编程模型。逻辑封装在Actor中。不直接操作线程。</p>
<p>由于每个Actor一次只能处理一条消息，因此不需要担心线程，每个Actor可以由框架独立调度。</p>
<p>分布式Actor框架中，编程模型被用来跨多节点进行scaling。位于不同节点之间的通讯可以使用encode decode的方式进行网络数据传输。</p>
<p>分布式Actor框架的实质是将消息代理（MQ等）和Actor编程模型集成到一个框架中。</p>
<p>三种流行的分布式Actor框架对于消息encoding的方式：</p>
<ul>
<li>默认情况下，Akka使用Java的内置序列化，不提供前向或后向兼容性。 但是，你可以用类似Protocol buffer的东西替代它，从而获得滚动升级的能力。</li>
<li>Orleans 默认使用不支持滚动升级部署的自定义数据编码格式; 要部署新版本的应用程序，您需要设置一个新的群集，将流量从旧群集迁移到新群集，然后关闭旧群集。 像Akka一样，可以使用自定义序列化插件。</li>
<li>在Erlang OTP中，对记录模式进行更改是非常困难的（尽管系统具有许多为高可用性设计的功能）。 滚动升级是可能的，但需要仔细计划。 一个新的实验性的maps数据类型（2014年在Erlang R17中引入的类似于JSON的结构）可能使得这个数据类型在未来更容易。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/Algorithim-String/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/Algorithim-String/" itemprop="url">Algorithim-String</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T14:12:42+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Removal"><a href="#Removal" class="headerlink" title="Removal"></a>Removal</h1><h2 id="remove-some-particular-char-from-string"><a href="#remove-some-particular-char-from-string" class="headerlink" title="remove some particular char from string"></a>remove some particular char from string</h2><p>slow,fast two pointer</p>
<h2 id="remove-all-leading-trailing-duplicated-empty-spaces-from-string"><a href="#remove-all-leading-trailing-duplicated-empty-spaces-from-string" class="headerlink" title="remove all leading/trailing/duplicated empty spaces from string"></a>remove all leading/trailing/duplicated empty spaces from string</h2><p>slow,fast two pointer, with handling special cases</p>
<h1 id="De-duplication"><a href="#De-duplication" class="headerlink" title="De-duplication"></a>De-duplication</h1><p>slow,fast two pointer</p>
<h1 id="Substring-gt-strstr"><a href="#Substring-gt-strstr" class="headerlink" title="Substring -&gt; strstr"></a>Substring -&gt; strstr</h1><h1 id="reversal"><a href="#reversal" class="headerlink" title="reversal"></a>reversal</h1><h1 id="replacement"><a href="#replacement" class="headerlink" title="replacement"></a>replacement</h1><p>Advance</p>
<h1 id="moving-letters-around-ABCD1234-gt-A1B2C3D4"><a href="#moving-letters-around-ABCD1234-gt-A1B2C3D4" class="headerlink" title="moving letters around(ABCD1234 =&gt; A1B2C3D4)"></a>moving letters around(ABCD1234 =&gt; A1B2C3D4)</h1><h1 id="permutation-use-DFS"><a href="#permutation-use-DFS" class="headerlink" title="permutation(use DFS)"></a>permutation(use DFS)</h1><h1 id="Decoding-Encoding"><a href="#Decoding-Encoding" class="headerlink" title="Decoding/Encoding"></a>Decoding/Encoding</h1><h1 id="Longest-substring-that-contains-unique-chars"><a href="#Longest-substring-that-contains-unique-chars" class="headerlink" title="Longest substring that contains unique chars"></a>Longest substring that contains unique chars</h1><h1 id="Reg-Matching"><a href="#Reg-Matching" class="headerlink" title="Reg Matching"></a>Reg Matching</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/DDIA-3-数据存储与检索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/DDIA-3-数据存储与检索/" itemprop="url">DDIA-3-数据存储与检索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T14:01:52+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据库只需要做两件事，1. 插入数据时候保存数据；2.之后读数据时，返回之前的结果。</p>
<h1 id="数据库核心：数据结构"><a href="#数据库核心：数据结构" class="headerlink" title="数据库核心：数据结构"></a>数据库核心：数据结构</h1><p>为了高效查找数据库中特定键的值，我们需要一个数据结构：索引（index）。索引是从主数据衍生的<strong>附加（additional）</strong>结构。这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。</p>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>key-value 数据的索引。</p>
<p>最简单的索引策略，保存一个内存中的hashmap，把每一个key映射到特定的字节偏移量，这样就可以找到每一个key的位置。</p>
<img src="/2019/05/05/DDIA-3-数据存储与检索/以类CSV格式存储键值对的日志，并使用内存哈希映射进行索引.png">
<p>这个理念是Bitcask（Riak中的默认索引引擎）的核心做法。只要所有key可以放入内存，只需要一次磁盘寻址，就可以把value加载到内存中。</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>所有的新的数据都以日志的样子追加到一个文件中，如何避免文件越来越大最后耗尽磁盘的空间？</p>
<ol>
<li>压缩。将日志分解成一定的大小的段，当超过时候，就关闭它。后续的写入会写入新的段文件中。然后可以分别压缩这些段。这样的压缩意味着，在每一个段日志中丢弃重复的key，只保留最近的更新。</li>
<li>多个段一起压缩，合并。由于段日志在写入后不会再修改，那么可以合并几个段的日志，到一个新的文件中。旧的日志可以删除。</li>
</ol>
<p>在这样的多段设计下，每个段都有自己的hashmap。查找过程就是一个段一个段的查询。由于有段合并，段的总数不会很多。</p>
<h3 id="实现中的重要问题"><a href="#实现中的重要问题" class="headerlink" title="实现中的重要问题"></a>实现中的重要问题</h3><ol>
<li>文件格式<br>CSV不是日志的最佳格式。更快更简单的是二进制格式，首字节存字符串长度，然后跟上原始字符串。</li>
<li>删除记录<br>插入墓碑标记</li>
<li>崩溃恢复<br>服务重启时，需要扫描所有的段来恢复hashmap，这样使得服务器重启变慢。Bitcask通过将每个hashmap的快照映射到磁盘，加速崩溃恢复。</li>
<li>部分写入的记录<br>Bitcask采用了校验和，发现损坏部分就丢弃。</li>
<li>并发控制<br>通常实现的选择只有一个写线程，简化了并发。而文件都是追加的写入，读并发更好。</li>
</ol>
<h3 id="为什么不原地更新？"><a href="#为什么不原地更新？" class="headerlink" title="为什么不原地更新？"></a>为什么不原地更新？</h3><ol>
<li>顺序写比随机写性能更好。特别是在磁盘。</li>
<li>文件是追加和不可变的，崩溃恢复更简单。</li>
<li>合并段的操作可以避免文件出现碎片。</li>
</ol>
<h3 id="哈希索引的局限性"><a href="#哈希索引的局限性" class="headerlink" title="哈希索引的局限性"></a>哈希索引的局限性</h3><ol>
<li>必须把key全部装入内存。即使在磁盘上维护hashmap，也很难保证高效的随机IO访问。处理哈希冲突也很复杂。</li>
<li>区间查询效率不高。只能逐一查询。</li>
</ol>
<h2 id="SSTables和LSM-Tree"><a href="#SSTables和LSM-Tree" class="headerlink" title="SSTables和LSM-Tree"></a>SSTables和LSM-Tree</h2><p>之前的段文件只可以追加，并且不要求key有序。现在我们可以对段文件的格式做一个简单的改变：我们要求<strong>键值对的序列按键排序</strong>。这就是<strong>SSTables（Sorted String Tables）</strong>的数据格式。我们还要求同一个key只会出现在一个段中。</p>
<p>SSTables优点：</p>
<ol>
<li>合并段更简单。就像merge sort一样。</li>
<li>内存中的hashmap索引是稀疏的。<br>在文件中查找key时，不需要在内存中保存所有的key。例如查询handiwork时，不需要handiwork在hashmap中有可以。而知道handbag和handsome的偏移量时，因为key已经排序，可以从handbag开始扫描到handsome就可以确定handiwork在不在。</li>
<li>压缩时，可以利用稀疏索引，降低了IO带宽。</li>
</ol>
<h3 id="构建和维护SSTables"><a href="#构建和维护SSTables" class="headerlink" title="构建和维护SSTables"></a>构建和维护SSTables</h3><p>要解决排序问题。方法是，</p>
<ol>
<li>在内存中保存一个排序结构，比如红黑树，AVL树。</li>
<li>在插入修改时候可以很快的响应。</li>
<li>可以顺序的读区它们。</li>
</ol>
<h4 id="存储引擎工作流程"><a href="#存储引擎工作流程" class="headerlink" title="存储引擎工作流程"></a>存储引擎工作流程</h4><ol>
<li>写入时，将数据加入内存表中，可以是红黑树实现。</li>
<li>当内存中的红黑树大小超过阀值时，把它用SSTable的格式写入磁盘。</li>
<li>处理读请求时，先尝试查询内存表，如果miss就查询磁盘段文件s。</li>
<li>周期性的执行合并和压缩。丢弃被覆盖和删除的值。</li>
</ol>
<h3 id="用SSTable实现LSM-Tree（Log-structured-Merge-Tree）"><a href="#用SSTable实现LSM-Tree（Log-structured-Merge-Tree）" class="headerlink" title="用SSTable实现LSM-Tree（Log-structured Merge-Tree）"></a>用SSTable实现LSM-Tree（Log-structured Merge-Tree）</h3><p>上面的算法时LevelDB和RocksDB使用的，用于嵌入到其他应用的key-value存储引擎。类似的存储引擎也用在了Cassandra和HBase中，这两个引擎都源于Google的BigTable论文。最初这个索引结构在早起的系统中被命名LSM-Tree。因此，基于合并和压缩的排序文件原理的存储引擎，通常都被称作LSM存储引擎。</p>
<p>全文搜索，Lucene是ElasticSearch和Solr的索引引擎。采用了类似的方法保存字典。全文索引复杂的多，但想法类似。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol>
<li>查询不存在的key时，会从内存开始扫描到磁盘的最后一个段。解决方法是，Bloom Filter。</li>
<li>压缩合并的时机。分为大小分级和分层压缩两个方法。一个是小的SSTables被连续合并到大的旧的SSTables。另一个是key的范围分裂成多个更小的SSTables，旧数据被移动到单独的层级。</li>
</ol>
<p>由于数据是按照排序存储，因此可以高效的执行区间查询。因为磁盘是顺序写入的，LSM-Tree的写入吞吐量可以非常高。</p>
<h2 id="B-trees索引"><a href="#B-trees索引" class="headerlink" title="B-trees索引"></a>B-trees索引</h2><p>应用最广泛的索引结构。和SSTable一样，B-tree保留按key排，也可以实现高效的范围查询。</p>
<p>B-tree将数据库分解成固定大小的块和页（4KB or more）。这种设计更接近底层硬件，因为磁盘也是固定大小的块的排列。</p>
<p>每个页，可以用地址标志，是磁盘地址，而不是内存。这样可以用这些页面引用构造一个树状页面进行索引。索引的根是一个页面，之后的查找根据地址，读取响应的页。</p>
<p>分支因子。</p>
<p>大多数数据库的索引适合3-4层的B-tree.因此不需要遍历非常深的页面层次即可找到所需的页。</p>
<p>B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；<br>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<h3 id="使B-tree可靠"><a href="#使B-tree可靠" class="headerlink" title="使B-tree可靠"></a>使B-tree可靠</h3><p>B-tree底层的基本操作是使用新数据覆盖磁盘的旧页。磁盘是覆盖扇区，对于SSD，擦除和重写的存储芯片块很大，情况更复杂。</p>
<p>页面溢出，需要分裂页时，也要覆盖其父页对更新后的两个子页的引用。属于复杂操作。在完成更新前发生崩溃，可能会产生孤儿页面。</p>
<p>崩溃恢复，使用redo Log。写数据之前先写日志。</p>
<p>并发控制。</p>
<h3 id="优化B-tree"><a href="#优化B-tree" class="headerlink" title="优化B-tree"></a>优化B-tree</h3><ol>
<li>一些数据库不是用覆盖页，而是做复制。</li>
<li>保存key的缩略信息而不是完整的key，来节省空间。只需要提供足够的信息来描述key的起止范围。</li>
<li>页可以存在磁盘的任何位置。可能回有随机的IO，而不是连续的。有些B-tree尝试实现对B-tree进行布局，但是随着树的增长，这个顺序会越来越难维护。</li>
<li>添加额外指针。左到右的指针，加速遍历。</li>
</ol>
<h2 id="对比B-tree-LSM-tree"><a href="#对比B-tree-LSM-tree" class="headerlink" title="对比B-tree, LSM-tree"></a>对比B-tree, LSM-tree</h2><p>根据经验，LSM-Tree写入更快，而B-tree读更快。读取通常在LSM—Tree中较慢，因为要检查多个不同的数据结构和SSTables。</p>
<h3 id="LSM-Tree优点"><a href="#LSM-Tree优点" class="headerlink" title="LSM-Tree优点"></a>LSM-Tree优点</h3><ol>
<li>LSM只写入一次数据（不考虑写放大（写入引起的压缩和合并）），而B-tree写入两次（一次redo log，一次数据本身）。</li>
<li>LSM可以成熟比B-tree更大的吞吐量。有时具有较低的写放大，顺序写入速度快。</li>
<li>可以支持更好的压缩，文件比B-tree小很多。没有B-tree产生碎片的问题。</li>
</ol>
<h3 id="LSM-Tree缺点"><a href="#LSM-Tree缺点" class="headerlink" title="LSM-Tree缺点"></a>LSM-Tree缺点</h3><ol>
<li>响应延迟不确定，因为压缩和合并。</li>
<li>由于配置问题，会出现压缩跟不上写入速度的问题。来不及合并，直到磁盘空间不足。</li>
<li>事务支持不如B-tree</li>
</ol>
<h2 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h2><h3 id="在索引中存储值"><a href="#在索引中存储值" class="headerlink" title="在索引中存储值"></a>在索引中存储值</h3><p>索引中存储行或则行的具体位置（堆文件法）。将索引行直接存在索引中，聚集索引。MySQL的InnoDB存储引擎中，表的主键是聚集索引，二级索引引用主键。</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>级联索引，通过将一列追加到另一列，将几个字段组合成一个键。只能从前到后匹配。B-tree和LSM-tree都无法高效的应对这种查询。</p>
<p>更常见的索引空间，R树。PostGIS使用PostgreSQL的广义搜索书索引实现了地理空间索引作为R树。</p>
<h3 id="全文搜索和模糊索引"><a href="#全文搜索和模糊索引" class="headerlink" title="全文搜索和模糊索引"></a>全文搜索和模糊索引</h3><p>之前的搜索都是准确匹配，而不能应对类似的key的搜索，例如错误的拼写。</p>
<p>Lucene引擎支持在某个编辑距离内的模糊搜索。LevelDB中这个内存中的索引是一些key的稀疏集合。但在Lucene中，内存中的索引是key中的字符串序列的有限状态机，类似字典树。这个自动机可以转换成Leveshtein自动机，支持编辑距离内的搜索。</p>
<h3 id="在内存中保存所有内容"><a href="#在内存中保存所有内容" class="headerlink" title="在内存中保存所有内容"></a>在内存中保存所有内容</h3><p>内存数据库。例如Memcached，做缓存。数据在重启后可以恢复。</p>
<p>内存数据可以更快的原因，是因为它们可以避免使用写磁盘的格式对内存数据结构编码的开销。</p>
<p>提供了给予磁盘索引难以实现的数据结构，例如Redis中的优先级队列和集合。</p>
<p>可以使用反缓存的方法，当没有足够的内存时，将一部分不常用数据倒入磁盘，类似操作系统的虚拟内存。</p>
<p>将来的NVM（non-volatile memory）技术广泛的普及，也可能很大的改变存储引擎的设计。</p>
<h1 id="事务处理OLTP与分析处理OLAP，"><a href="#事务处理OLTP与分析处理OLAP，" class="headerlink" title="事务处理OLTP与分析处理OLAP，"></a>事务处理OLTP与分析处理OLAP，</h1><p>事务意味着允许客户端进行低延迟读区和写入，相比于只能周期性的运行的批处理作业。事务不一定具有ACID属性。</p>
<p>OLTP每次返回少量的数据，随机访问，低延迟要求。OLAP对大量数据访问，批量导入（ETL）或事件流，内部分析师，为决策提供支持。</p>
<h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><p>数据仓库是一个单独的数据库，分析师可以在不影响OLTP的情况下，任意使用数据仓库。数据仓库包含公司所有OLTP数据库的只读副本。</p>
<p>单独使用数据仓库的优势在于数据仓库可以针对分析访问模式进行优化。本文前半部分讨论的索引模型只适合与OLTP而不适合做分析查询。</p>
<h3 id="OLTP数据库和数据仓库的差异"><a href="#OLTP数据库和数据仓库的差异" class="headerlink" title="OLTP数据库和数据仓库的差异"></a>OLTP数据库和数据仓库的差异</h3><p>数据仓库也支持SQL查询接口，但是和OLTP的实现差异很大。</p>
<p>一些数据库（SQL Server和SAP HANA）在同一产品中支持事务处理和数据仓库。然而，它们是两个独立的存储和查询引擎，只是通过一个SQL接口来访问。</p>
<p>一些商用的数据仓库，Teradata，Vertica，SAP HANA等很贵。还有开源的基于Hadoop的SQL项目，例如Apache Hive，Spark SQL，Cloudera Impala，Facebook Presto，Apache Tajo和Apache Drill. 其中一些是基于Google Dremel而构建的。</p>
<h3 id="星型与雪花型分析模式"><a href="#星型与雪花型分析模式" class="headerlink" title="星型与雪花型分析模式"></a>星型与雪花型分析模式</h3><p>许多数据仓库都使用了星型模式，也称为维度建模。</p>
<p>这种模式的中心是一个所谓的事实表。事实表的每一行表示在特定时间发生的事件。</p>
<img src="/2019/05/05/DDIA-3-数据存储与检索/用于数据仓库的星型模型例子.png">
<p>通常，事实被捕获为单独的事件，这样之后的分析具有很大的灵活性。</p>
<p>事实表中的列是属性，其他列可能会引用其他表的外键，成为维度表，这些维度代表事件的发生地点，时间，方式和原因。</p>
<p>名称<strong>星型模式</strong>来源于关系表可视化的适合，事实表位于中间，被一系列维度表包围。</p>
<p>该模型的一个变体成为<strong>雪花模型</strong>，其中维度进一步细分为子空间。例如，dimproduct表中的每一行可以再次向外引用品牌和类型的外键。这样更规范，但是更复杂。分析人员一般首选星型。</p>
<p>典型的数据仓库中，表都非常宽，事实表通常超过100列，甚至几百列。维度表也可能很宽。</p>
<h1 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h1><p>主要关注事实表的海量数据问题，通常有万亿行、PB级别的数据。</p>
<p>虽然通常事实表超过100列，但是一般一次分析也只会访问其中的4，5列。如何高效的执行这中类型的查询？</p>
<p>OLTP系统中，数据库的存储都是面向行的。如果属性超过100列，那么需要把很多不需要的数据读入内存，然后丢弃。非常低效。</p>
<p>面向列存储，不是将一行的内容存在一起，而是把每一列的所有值存在一起。</p>
<h2 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h2><p>面向列的存储非常适合压缩。一直技术是位图编码。</p>
<img src="/2019/05/05/DDIA-3-数据存储与检索/压缩位图索引存储布局.png">
<p>每一个不同的值一个位图，位图的位数是行数。</p>
<p>Bigtable模型仍然主要是面向行的。</p>
<h3 id="内存带宽和矢量化处理"><a href="#内存带宽和矢量化处理" class="headerlink" title="内存带宽和矢量化处理"></a>内存带宽和矢量化处理</h3><p>除了减少需要从磁盘加载的数据量之外，列存储也有利于高效利用CPU的周期性。</p>
<h2 id="列存储中的排序"><a href="#列存储中的排序" class="headerlink" title="列存储中的排序"></a>列存储中的排序</h2><p>列的存储如果是按照某个常见的顺序，例如date，就可以做类似于SSTables的索引机制。注意单独排序某列没用，需要正行排序。</p>
<p>数据仓库管理员需要基于经验选择合适的排序列，可以单列也可以是多列。这样查询优化器可以更高效。</p>
<p>另一个好处是可以进行压缩。可以进行游程编码，位图那样。</p>
<h3 id="几种不同的排序"><a href="#几种不同的排序" class="headerlink" title="几种不同的排序"></a>几种不同的排序</h3><ol>
<li>C-Store的改进。用不同的方式存储相同的数据。使不同的排序查询都获益。也就是通过排序后的冗余数据加速。</li>
<li>列排序，类似于面向行的二级索引。区别是，列的索引中，存的是值而不是地址。</li>
</ol>
<h2 id="列存储与写操作"><a href="#列存储与写操作" class="headerlink" title="列存储与写操作"></a>列存储与写操作</h2><p>上述的优化，都是对读的优化，这会让写变得更困难。类似B-tree的就地更新的操作，对压缩列是不可能的。</p>
<p>一个方案是类似LSM-tree。先写入内存的排序数据结构，然后在一定的时候把内存的数据顺序的倒入磁盘，接着进行有可能的文件合并。这样查询的时候需要检查内存中的数据，和磁盘中的数据。这对于查询方是透明的。</p>
<h2 id="聚合：数据立方体和物化视图"><a href="#聚合：数据立方体和物化视图" class="headerlink" title="聚合：数据立方体和物化视图"></a>聚合：数据立方体和物化视图</h2><p>数据仓库不是一定要用列存储的。但是列存储因为查询分析更快，所以正在迅速普及。数据仓库另一个方面是物化聚合，就是把常用的查询物理存储化，缓存一些查询结果。</p>
<p>实现：物化视图。 物化视图的常见特例称为数据立方体或OLAP立方。它是按不同维度分组的聚合网格。以沿着每行或每列应用相同的汇总，并获得一个维度减少的汇总（按产品的销售额，无论日期，还是按日期销售，无论产品如何）。</p>
<p>缺点是数据立方体不具有查询原始数据的灵活性。因此，大多数数据仓库试图保留尽可能多的原始数据，并将聚合数据（如数据立方体）仅用作某些查询的性能提升。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/DDIA-2-数据模型与查询语言/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/DDIA-2-数据模型与查询语言/" itemprop="url">DDIA-2-数据模型与查询语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T13:13:46+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>语言的边界就是世界的边界</p>
<p>数据模型可能是软件开发中最重要的部分了，因为它们的影响如此深远：不仅仅影响着软件的编写方式，而且影响着我们的解题思路。</p>
<h1 id="关系模型与文档模型"><a href="#关系模型与文档模型" class="headerlink" title="关系模型与文档模型"></a>关系模型与文档模型</h1><h2 id="关系型-RDBMS"><a href="#关系型-RDBMS" class="headerlink" title="关系型 RDBMS"></a>关系型 RDBMS</h2><p>关系模型致力于将数据库本身的实现细节隐藏在更简洁的接口之后。数据被组织成表，每个关系都是Tuple的无序集合。</p>
<p>应用场景<br>你今天在网上看到的大部分内容依旧是由关系数据库来提供支持，无论是在线发布，讨论，社交网络，电子商务，游戏，软件即服务生产力应用程序等等内容。</p>
<p>需求Transaction</p>
<h2 id="文档型-NoSQL"><a href="#文档型-NoSQL" class="headerlink" title="文档型 NoSQL"></a>文档型 NoSQL</h2><p>NoSQL数据库出现，有以下几个原因：</p>
<ol>
<li>关系型数据库的扩展性不够，包括对非常大的数据集或者非常高的写入吞吐量。</li>
<li>开源免费。</li>
<li>关系模型不能很好的支持特殊性的查询操作。</li>
<li>渴望一种更具多动态性与表现力的数据模型</li>
</ol>
<h2 id="对象关系不匹配"><a href="#对象关系不匹配" class="headerlink" title="对象关系不匹配"></a>对象关系不匹配</h2><p>如果数据存储在关系表中，那么需要一个<strong>笨拙的转换层</strong>，处于应用程序代码中的对象和表，行，列的数据库模型之间。模型之间的不连贯有时被称为阻抗不匹配（impedance mismatch)<br>像ActiveRecord和Hibernate这样的<strong>对象关系映射（object-relational mapping, ORM）</strong>框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异</p>
<h3 id="LinkedIn简历的例子，一对多"><a href="#LinkedIn简历的例子，一对多" class="headerlink" title="LinkedIn简历的例子，一对多"></a>LinkedIn简历的例子，一对多</h3><img src="/2019/04/21/DDIA-2-数据模型与查询语言/LinkedIn建立使用关系模型表示.png">
<p>一个User和他相关的项目有一对多的关系。除了使用在其他表中加入UserID作为外键；使用有些SQL数据库支持的列的数据格式为JSON/XML，<br>它更适合用JSON来表示。因为，<strong>简单</strong>，它主要是一个自包含的文档。文档模型优势在于如果要读区一份简历，<strong>局部性</strong>更好。一次查询就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;user_id&quot;: 251,</span><br><span class="line">  &quot;first_name&quot;: &quot;Bill&quot;,</span><br><span class="line">  &quot;last_name&quot;: &quot;Gates&quot;,</span><br><span class="line">  &quot;summary&quot;: &quot;Co-chair of the Bill &amp; Melinda Gates... Active blogger.&quot;,</span><br><span class="line">  &quot;region_id&quot;: &quot;us:91&quot;,</span><br><span class="line">  &quot;industry_id&quot;: 131,</span><br><span class="line">  &quot;photo_url&quot;: &quot;/p/7/000/253/05b/308dd6e.jpg&quot;,</span><br><span class="line">  &quot;positions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;job_title&quot;: &quot;Co-chair&quot;,</span><br><span class="line">      &quot;organization&quot;: &quot;Bill &amp; Melinda Gates Foundation&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;job_title&quot;: &quot;Co-founder, Chairman&quot;,</span><br><span class="line">      &quot;organization&quot;: &quot;Microsoft&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;education&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;school_name&quot;: &quot;Harvard University&quot;,</span><br><span class="line">      &quot;start&quot;: 1973,</span><br><span class="line">      &quot;end&quot;: 1975</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;school_name&quot;: &quot;Lakeside School, Seattle&quot;,</span><br><span class="line">      &quot;start&quot;: null,</span><br><span class="line">      &quot;end&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;contact_info&quot;: &#123;</span><br><span class="line">    &quot;blog&quot;: &quot;http://thegatesnotes.com&quot;,</span><br><span class="line">    &quot;twitter&quot;: &quot;http://twitter.com/BillGates&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的结构意味着数据存在一对多的关系，也就是<strong>树状结构</strong></p>
<img src="/2019/04/21/DDIA-2-数据模型与查询语言/树状结构的简历.png">
<h3 id="多对一，多对多"><a href="#多对一，多对多" class="headerlink" title="多对一，多对多"></a>多对一，多对多</h3><p>建立例子中的region_id, industry_id,主要解决了重复问题。可以避免歧义，做本地化支持，更好的搜索，等等。消除重复，就是数据库范式化的核心思想。</p>
<h4 id="IMS的层次模型"><a href="#IMS的层次模型" class="headerlink" title="IMS的层次模型"></a>IMS的层次模型</h4><p>支持多对多的关系有些困难，而且不支持联结。</p>
<h4 id="网络模型（network-model）-已经淘汰"><a href="#网络模型（network-model）-已经淘汰" class="headerlink" title="网络模型（network model） 已经淘汰"></a>网络模型（network model） 已经淘汰</h4><p>存指针，而不是外键。是一条开始于根（root）的路径。更改变得很困难。</p>
<h4 id="关系模型（relational-model）"><a href="#关系模型（relational-model）" class="headerlink" title="关系模型（relational model）"></a>关系模型（relational model）</h4><p>关系模型使用外键访问，也类似一选择了一条访问路径，区别在于，这个是由查询优化器自动生产的，一般不必过多的考虑。</p>
<h4 id="文档数据库的比较"><a href="#文档数据库的比较" class="headerlink" title="文档数据库的比较"></a>文档数据库的比较</h4><p>在表示多对多关系时候，关系模型与文档模型并没有不同，都是有相关的一项唯一标示符引用。关系模型中叫<strong>外键</strong>，文档模型中叫<strong>文档引用</strong>。可以使用链接操作或者后续的操作来解析这个引用。</p>
<h2 id="选哪个"><a href="#选哪个" class="headerlink" title="选哪个"></a>选哪个</h2><p>要考虑多方面的差异，包括容错性，并发处理。</p>
<p>关于模型中的差异，以下，</p>
<h3 id="哪个更简单"><a href="#哪个更简单" class="headerlink" title="哪个更简单"></a>哪个更简单</h3><p>如果应用本身有着类似文档的结构（树状结构，一对多），那么使用NoSQL。</p>
<p>关系型模型，倾向于模型中数据的分解。他把文档结构分解成多个表，有可能使得模式更为笨重，增加代码复杂度。</p>
<p>文档模型的局限性有，不能直接读取文档中的嵌套项，而是要全部读取，例如读区用户id为251的用户中职位列表的第二个。</p>
<p>对于连接的支持，是否是问题取决于应用本身，需不需要这种场景。</p>
<p>对于高度关联的数据，文档模型可能不是很适合。</p>
<h3 id="文档模式的灵活性"><a href="#文档模式的灵活性" class="headerlink" title="文档模式的灵活性"></a>文档模式的灵活性</h3><p>可以将任何key-value添加到文档数据库中，而且读取时，客户端也无法保证文档会包含那些字段。</p>
<p>文档模型是schema on read，<br>关系模型是schema on write。</p>
<p>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大的争议性一样【22】，数据库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案。</p>
<p>允许某些原因下，集合中数据是异构的。</p>
<h3 id="查询数据的局部性"><a href="#查询数据的局部性" class="headerlink" title="查询数据的局部性"></a>查询数据的局部性</h3><p>局部性优势在于，需要同时访问文档中大部分内容时，加载一次文档即可。但如果每次只访问文档中的一小部分，有些浪费。</p>
<p>更改文档时，会重写整个文档，因此通常建议，文档应该尽量的小，并且避免写入时候增加文档大小。</p>
<p>NoSQL在为文档分配空间时候，会多分配一些，以防修改更新时候，空间不足，引起空间搬家的昂贵操作。</p>
<h3 id="NoSQL与关系型数据库的结合"><a href="#NoSQL与关系型数据库的结合" class="headerlink" title="NoSQL与关系型数据库的结合"></a>NoSQL与关系型数据库的结合</h3><h1 id="数据查询语言"><a href="#数据查询语言" class="headerlink" title="数据查询语言"></a>数据查询语言</h1><p>SQL是一种声明式查询语言，与IMS和CODASYL命令式不同。</p>
<p>声明式查询语言不需要关心实现。由数据库查询引擎来优化实现。可以在不改变查询语句的情况下提高性能。可以利用并行执行的优化。</p>
<h2 id="Web中的声明式查询就是CSS，比Javascript的命令式查询要好。"><a href="#Web中的声明式查询就是CSS，比Javascript的命令式查询要好。" class="headerlink" title="Web中的声明式查询就是CSS，比Javascript的命令式查询要好。"></a><strong>Web中的声明</strong>式查询就是CSS，比Javascript的命令式查询要好。</h2><h2 id="MapReduce查询-介于声明式和命令式之间"><a href="#MapReduce查询-介于声明式和命令式之间" class="headerlink" title="MapReduce查询 介于声明式和命令式之间"></a><strong>MapReduce查询</strong> 介于声明式和命令式之间</h2><p>一些NoSQL数据存储（包括MongoDB和CouchDB）支持有限形式的MapReduce，作为在多个文档中执行只读查询的机制。</p>
<p>查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用。它基于map（也称为collect）和reduce（也称为fold或inject）函数，两个函数存在于许多函数式编程语言中。</p>
<p>map和reduce函数在功能上有所限制：它们必须是纯函数，这意味着它们只使用传递给它们的数据作为输入，它们不能执行额外的数据库查询，也不能有任何副作用。这些限制允许数据库以任何顺序运行任何功能，并在失败时重新运行它们。然而，map和reduce函数仍然是强大的：它们可以解析字符串，调用库函数，执行计算等等。</p>
<p>MapReduce是一个相当底层的编程模型，用于计算机集群上的分布式执行。像SQL这样的更高级的查询语言可以用一系列的MapReduce操作来实现（见第10章），但是也有很多不使用MapReduce的分布式SQL实现。请注意，SQL中没有任何内容限制它在单个机器上运行，而MapReduce在分布式查询执行上没有垄断权。</p>
<h1 id="图状数据模型"><a href="#图状数据模型" class="headerlink" title="图状数据模型"></a>图状数据模型</h1><p>解决复杂的多对多关系。</p>
<p><strong>社交图谱</strong></p>
<p>顶点是人，边指示哪些人彼此认识。</p>
<p><strong>网络图谱</strong></p>
<p>顶点是网页，边缘表示指向其他页面的HTML链接。</p>
<p><strong>公路或铁路网络</strong></p>
<p>顶点是交叉路口，边线代表它们之间的道路或铁路线。</p>
<p>图的存储，就是存定点和边。</p>
<ol>
<li>任何顶点都可以有一条边连接到任何其他顶点。没有模式限制哪种事物可不可以关联。</li>
<li>给定任何顶点，可以高效地找到它的入边和出边，从而遍历图，即沿着一系列顶点的路径前后移动。（这就是为什么例2-2在tail_vertex和head_vertex列上都有索引的原因。）</li>
<li>通过对不同类型的关系使用不同的标签，可以在一个图中存储几种不同的信息，同时仍然保持一个清晰的数据模型。</li>
</ol>
<p>这些特性让建模很灵活。有利于演化：添加应用功能时，容易扩展用，更能应对变化，使用合适的的数据结构。</p>
<h2 id="Cypher查询语言"><a href="#Cypher查询语言" class="headerlink" title="Cypher查询语言"></a>Cypher查询语言</h2><p>Neo4j图形数据库</p>
<h2 id="SQL的图查询"><a href="#SQL的图查询" class="headerlink" title="SQL的图查询"></a>SQL的图查询</h2><p>与Cypher比显得笨拙</p>
<h2 id="三元存储与SPARQL"><a href="#三元存储与SPARQL" class="headerlink" title="三元存储与SPARQL"></a>三元存储与SPARQL</h2><p>所有信息都是三个部分存储（主体，谓语，客体）。</p>
<h3 id="RDF数据模型"><a href="#RDF数据模型" class="headerlink" title="RDF数据模型"></a>RDF数据模型</h3><p>类似XML，更冗长。 不区分属性和边。</p>
<p>有工具支持生成RDF格式的数据模型。</p>
<h3 id="SPARQL查询语言"><a href="#SPARQL查询语言" class="headerlink" title="SPARQL查询语言"></a>SPARQL查询语言</h3><p>采用RDF数据模型的三元存储查询语言。类似一次性SELECT操作完成。</p>
<h3 id="Datalog基础"><a href="#Datalog基础" class="headerlink" title="Datalog基础"></a>Datalog基础</h3><p>比较老，适合处理复杂数据。每次实现一块。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/" itemprop="url">DDIA-1-可靠可扩展可维护的应用系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-20T19:35:16+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据密集型应用的模块"><a href="#数据密集型应用的模块" class="headerlink" title="数据密集型应用的模块"></a>数据密集型应用的模块</h1><p>当今许多应用大多是数据数据密集（data-intensive）而不是计算密集型（compute-intensive）的。所以CPU的处理能力往往不是应用程序的瓶颈。关键在于数据的量、数据的复杂度以及数据的快速多变性。</p>
<p>应用往往包含以下模块：</p>
<ol>
<li>数据库：用于存储数据</li>
<li>高速缓存：缓存复杂或者操作代价昂贵的结果，加快下一次访问</li>
<li>索引：用户可以按照关键字搜索数据并支持各种过滤</li>
<li>流式处理：持续发送消息到另一个进程，处理采用异步方式</li>
<li>批处理：定期处理大量积累的数据</li>
</ol>
<h2 id="数据系统的架构"><a href="#数据系统的架构" class="headerlink" title="数据系统的架构"></a>数据系统的架构</h2><img src="/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/一个可能的组合使用多个组件的数据系统架构.png" title="一个数据架构系统，包含了不同的组件">
<h1 id="核心设计目标"><a href="#核心设计目标" class="headerlink" title="核心设计目标"></a>核心设计目标</h1><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>出现意外情况，比如硬件、软件故障、人为失误等，系统可以继续正常运转，至少确保功能正确。</p>
<h3 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h3><p>比较容易出现的，硬盘崩溃，内存故障，电网停电。</p>
<p>第一反应是为硬件冗余来减少系统故障率。例如磁盘RAID，服务器双电源，甚至热插拔CPU，数据中心添加备用电源、发电机。</p>
<p>这样当一个组件发生故障时，冗余组件可以快速接管，之后运维人员可以修复或者更换坏掉的组件。</p>
<p>直到最近，采用硬件冗余方案对于大多数应用场景还是足够的，它让单机完全失效的概率降到最低。只要可以把备份迅速恢复到新的机器上，故障的停机时间在大多数应用中并不是灾难性的。</p>
<p>现在，通过软件容错的方式来容易多机失效成为新的手段，或者成为硬件容错方案的有力补充。例如滚动升级。</p>
<h3 id="软件错误"><a href="#软件错误" class="headerlink" title="软件错误"></a>软件错误</h3><p>这类故障更难预料。各个节点直接是由软件关联的，可能会导致更多的系统故障。</p>
<p>例如，</p>
<ol>
<li>由于软件错误，导致特定的输入引发应用的崩溃。例如Linux内核bug，在2012年6月30的闰秒时候触发，导致很多应用程序被挂掉。</li>
<li>失控的进程把系统的资源耗尽，导致这些共享资源不能被释放。</li>
<li>系统的Dependency出了问题，返回值异常。</li>
<li>组件中的小故障触发另一个组件中的故障，进而触发更多的故障。</li>
</ol>
<p>没有快速的解决方法。只能仔细考虑很多细节。</p>
<ol>
<li>检查系统的假设条件和系统之间的交互</li>
<li>进行全面的测试</li>
<li>进程隔离，</li>
<li>允许进程崩溃后自动重启</li>
<li>反复评估、监控并分析生产环境中的行为表现。</li>
</ol>
<p>例如消息队列中，输出消息的数量应等于输入消息的数量。如果发现不一致，则立即告警。</p>
<h3 id="人为失误"><a href="#人为失误" class="headerlink" title="人为失误"></a>人为失误</h3><p>人无法做到万无一失。运维人员的配置错误可能是系统下线的第一大原因。</p>
<p>要保证系统可靠，如何减少人为错误对它的影响？</p>
<ol>
<li>用最小出错的方式来设计系统。让做错事更难。</li>
<li>想办法分离最容易出错的地方，容易引发故障的接口。使用Sandbox隔离真正的生产和测试环境。</li>
<li>充分的测试。单元测试，集成测试，手动测试。边界条件的考虑。</li>
<li>当出现人为失误时，有快速回滚或者回复的机制。滚动发布新代码。</li>
<li>监控子系统需要详细和清晰。</li>
<li>推行管理流程和相关培训。</li>
</ol>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>随着规模的增长，例如数据量、流量和复杂性，系统应该可以用合理的方式进行应对，满足这种增长。</p>
<p>当应用负载增加的时候，比如用户从1w到100w，从100w到1000w，应用程序如何应对增长的负载。</p>
<p>相关参数：Web服务的QPS，数据库的写入比例，DAU，缓存命中率。有时候平均值很重要，有时候短时间内的峰值会成为系统瓶颈。</p>
<p>Twitter的Fan-out结构，对数据量提出了挑战。当一个人发Tweet时候，怎么处理Timeline这个请求。根据粉丝的数量，区别处理。</p>
<h3 id="如何描述性能"><a href="#如何描述性能" class="headerlink" title="如何描述性能"></a>如何描述性能</h3><p>系统负载增加后，会发生什么，两种思考方式</p>
<ol>
<li>系统资源不变（CPU，内存，带宽），系统的性能会发生什么变化？</li>
<li>如果要保持性能不变，需要增加多少资源？</li>
</ol>
<p>不同类型的系统关心的性能指标不同</p>
<ol>
<li>批处理系统通常关心<strong>吞吐量（throughput）</strong>，例如Hadoop，每秒可以处理多少条数据或者完成一个作业总共需要多少时间。</li>
<li>Online系统中，更看重服务的<strong>响应时间（response time）</strong>，即客户端从发出请求到得到回复的总时间。</li>
</ol>
<img src="/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/响应时间.png" title="展示了一个服务100次请求响应时间的均值与百分位数、中位数">
<p>对于响应时间，如下图，有一些很长的，算异常请求，可能是由于数据大很多。但也有可能是其他因素造成的，例如上下文切换、进程调度、网络丢包、TCP重传、垃圾回收STW，缺页中断、磁盘IO。</p>
<p>最好使用百分位数，中位数（50%）来评估系统的响应时间。</p>
<p>采用较高的响应时间百分位数很重要，因为直接影响用户的总体服务体验。例如亚马逊采用99.9百分位来定义服务响应时间。优化99.9%的目标可能成本很高。能不能带来收益很关键。</p>
<p>​排队延迟（queueing delay）通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为头部阻塞（head-of-line blocking）</p>
<h3 id="应对负载增加"><a href="#应对负载增加" class="headerlink" title="应对负载增加"></a>应对负载增加</h3><p>垂直扩展和水平扩展。</p>
<p>好的系统有弹性特征，可以自动检测负载的变化，来自动添加更多的计算资源。</p>
<p>可扩展架构通常都是从通用模块逐步构建出来的。</p>
<h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>项目会随着时间的推移，项目会需要新的人员参与到开发和运维工作中，来满足系统的稳定和新场景的适应。系统应该高效的变化。</p>
<p>​软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常运行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。</p>
<p>为此，我们将特别关注软件系统的三个设计原则：</p>
<h3 id="可操作性（Operability）"><a href="#可操作性（Operability）" class="headerlink" title="可操作性（Operability）"></a>可操作性（Operability）</h3><p>​    便于运维团队保持系统平稳运行。<br>良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。数据系统可以通过各种方式使日常任务更轻松：</p>
<h3 id="简单性（Simplicity）"><a href="#简单性（Simplicity）" class="headerlink" title="简单性（Simplicity）"></a>简单性（Simplicity）</h3><p>​    从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。）<br>   <strong>复杂度（complexity）</strong>有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等等，</p>
<h3 id="可演化性（evolability）"><a href="#可演化性（evolability）" class="headerlink" title="可演化性（evolability）"></a>可演化性（evolability）</h3><p>​    使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。<br>    组织流程方面，敏捷开发，TDD，重构。<br>    修改数据系统并使其适应不断变化需求的容易程度，是与简单性和抽象性密切相关的：简单易懂的系统通常比复杂系统更容易修改</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/文明之光-近代音乐发展/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/文明之光-近代音乐发展/" itemprop="url">文明之光-近代音乐发展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-13T17:19:18+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>透过古典音乐的发展历程，可以感受到近代人文主义的兴起和发展，以及时代的变迁。</p>
<h1 id="巴洛克音乐"><a href="#巴洛克音乐" class="headerlink" title="巴洛克音乐"></a>巴洛克音乐</h1><h2 id="形成时期"><a href="#形成时期" class="headerlink" title="形成时期"></a>形成时期</h2><p>早起音乐与宗教有关。后来人们富裕之后，音乐的宗教气息逐渐减少，世俗的元素开始增加。欧洲音乐第二次走向世俗是发生在文艺复兴时期，而其中产生质变是在18世纪初的巴洛克时期。因此巴洛克音乐是所有古典音乐的基础。</p>
<h2 id="什么是巴洛克"><a href="#什么是巴洛克" class="headerlink" title="什么是巴洛克"></a>什么是巴洛克</h2><p>源于西班牙语Barocco，引申的意思是充满细节。主要是指文艺复兴后期，豪华的建筑和精致的装饰风格。后来被用到了绘画和音乐中，也是类似的意思。巴洛克音乐华丽精致，加入了大量的修饰性音符。巴洛克时期的影响力最大的音乐家是巴赫。</p>
<img src="/2019/04/13/文明之光-近代音乐发展/barocco.png" title="巴洛克建筑的立柱">
<h2 id="巴赫（1685-1750）"><a href="#巴赫（1685-1750）" class="headerlink" title="巴赫（1685-1750）"></a>巴赫（1685-1750）</h2><iframe width="100%" height="400px" src="//player.bilibili.com/player.html?aid=5990334&cid=9724899&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>出身音乐世家。音乐天才。小时候因为父母趋势的早，被养在哥哥家。由于家庭负担问题15岁就要自己去挣钱养活自己。在教会表演，王公贵族的乐队里担任管风琴师。</p>
<p>下了很多苦功夫学习，21岁成为德意志地区有名的乐器师，担任城市乐团首席音乐总监。1717年在柯腾宫廷担任首席乐队长，在此期间创作了《勃兰登堡协奏曲》，创作水平到了炉火纯青的地步。</p>
<p>巴赫在音乐上的贡献非常高。</p>
<p><strong>在音乐之道上</strong>，有些人认为他比之后的贝多芬莫扎特地位还要高，原因就是在于他奠定了古典音乐的基础。巴赫教会了后人如何使用音符构建出音乐作品。<br>另一个贡献，帮音乐从宗教走向世俗。把严肃的沉重的宗教曲目，变化成美妙的优雅的表演。<br>巴赫确立了德意志地区在几百年之后中古典音乐的地位。巴赫之前，意大利比较厉害。巴赫是第一个把南欧丰富新颖的音乐表现形式容易单一呆板的德意志音乐的。</p>
<p><strong>在音乐之术上</strong>，有声乐和器乐两个方面。<br>声乐方面，巴赫的声乐作品中，康塔塔的数量占比很高。在巴赫的康塔塔中，首尾都是宗教的赞歌，中段是围绕主题的独唱咏叹调、重唱和合唱构成。这样的结构非常合理，既能表现宗教音乐的神圣，又带有民间艺术的美感。<br>在器乐曲上，巴赫是我们今天经常听到的奏鸣曲和协奏曲的先驱。协奏曲诞生于意大利。巴赫整天沉醉与各种乐器的组合实验。从此有了一种乐器为主，其他乐器为辅的协奏曲。配器有弦乐、羽管键琴、双簧管、小号、圆号、低音奥维尔，等等。最著名的就是《勃兰登堡协奏曲》。巴赫之后的音乐家，莫扎特、贝多芬等人在他的基础上不断完善协奏曲的创作技巧。</p>
<p>巴赫时代并不具备将创作的音乐普及全欧洲的条件。因此在他去世几十年后就被人们遗忘了。巴赫作品的重新发现和认识，要感谢浪漫主义时期的<strong>门德尔松</strong>（1809-1847）。门德尔松整理和出版了巴尔德音乐，在巴赫去世百年之后，人们才重新认识到这位奠定了现代音乐基础的作曲家的伟大。</p>
<p>巴赫一生作品之多，质量之高，让后世音乐家难以望其项背。作品包括几百首康塔塔，大量协奏曲，五部弥撒，大量的赋格。</p>
<h1 id="古典主义音乐"><a href="#古典主义音乐" class="headerlink" title="古典主义音乐"></a>古典主义音乐</h1><p>古典主义是指欧洲18世纪末19世纪初的文化和艺术思潮。那时正是资产阶级取代贵族统治欧洲的时期，音乐和艺术都是姨资产阶级追求的自由和人性解放为背景创作的。讲究理性、秩序、和谐。</p>
<h2 id="海顿"><a href="#海顿" class="headerlink" title="海顿"></a>海顿</h2><p>海顿、莫扎特和贝多芬。生于奥地利的海顿不仅是古典主义时期第一位重要的作曲家，也是<strong>交响乐之父</strong>。海顿不仅确立了交响乐的形式，而且一生创作了108首交响乐，超过莫扎特，贝多芬、舒伯特、舒曼、门德尔松、柴可夫斯基、马勒等人的创作总和。</p>
<p>海顿最大的贡献在于确定了交响乐的形式，即由四个乐章组成，分别是快板-慢板-诙谐曲或者小步舞曲-快板。直到今天大部分交响乐依然沿用这个传统。</p>
<h2 id="莫扎特"><a href="#莫扎特" class="headerlink" title="莫扎特"></a>莫扎特</h2><p>神童、天才。六岁就在维也纳宫廷为特蕾莎女王表演钢琴。莫扎特音乐轻柔曼妙，充满了阳光。可能不再年轻、有一些闲暇并且积累了一些人生经历时，才会发现莫扎特很适合自己。</p>
<iframe width="100%" height="400px" src="//player.bilibili.com/player.html?aid=7779069&cid=12755148&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h2 id="贝多芬"><a href="#贝多芬" class="headerlink" title="贝多芬"></a>贝多芬</h2><img src="/2019/04/13/文明之光-近代音乐发展/2019-04-13-21-12-59.png" title="贝多芬的肖像，收藏于贝多芬波恩故居，手中作品是《庄严弥撒曲》">
<p>乐圣。罗曼罗兰说贝多芬时人类历史上最伟大的英雄。1770年生于波恩。爷爷是宫廷乐队长，父亲是男高音。拜师奈弗，在两年后成为乐队的管风琴师并发布了三首奏鸣曲。</p>
<p>波恩大公弗朗兹十分欣赏年轻的贝多芬，成了他早起的保护人。介绍他去维也纳拜师莫扎特。不过由于莫扎特当时在忙于创作，没有成功。后来贝多芬回到波恩遇到了海顿，波恩建议他到维也纳学习。贝多芬1792年第二次到维也纳，并在那里度过了他一生的大部分时间。</p>
<p>接受了法国启蒙运动平等自由博爱的思想。成为自由主义者。贝多芬一生追求人性的解放，他的作品一直体现出一种向上的理想主义倾向。《第二交响曲》，形成自己的风格，英雄主义倾向很明显。两年后《第三（英雄）交响曲》，本来想献给拿破仑，最后听说拿破仑成帝了，起的把拿破仑名字划掉。</p>
<p>英雄交响曲分为四个乐章。第一乐章为快板，描写了法国大革命的情景，场面宏大。第二乐章，《葬礼进行曲》，描写英雄牺牲，人民为他送葬。第三乐章为快节奏诙谐曲。第四乐章为快板，奔放和柔美交替，越来越强烈，直到最后一个壮丽的高潮。</p>
<p>贝多芬有两段重要的爱情，最后都没有变成婚姻。第一段中写下了《月光奏鸣曲》，这段感情深深的伤害了贝多芬，甚至想到自杀。第二段特蕾莎，刻骨铭心，完成《第四交响曲》，《热情奏鸣曲》，《致爱丽丝》。</p>
<p>贝多芬30岁后耳聋越来越严重，把自己和命运抗争的心情写在《第五交响曲》，东亚又称为《命运交响曲》。恩格斯评价，如果你没听过这部壮丽的作品的话，那么可以说你一生什么作品都没听过。</p>
<p>《第六交响曲》，打破了四个乐章的限制，并且给每个乐章起了标题，在该曲中，用乐器模仿自然的声音。</p>
<p>最后的理想是想把《欢乐颂》的文字通过合唱的形式加到交响乐中，创作了被称为《合唱》的《第九交响曲》。1824年5月7日在维也纳首演，结束后整个音乐厅爆发出雷鸣般的掌声，可是贝多芬已经听不到了。女高音牵着贝多芬转过身来后，贝多芬激动的昏了过去。当时热烈的场面如同暴动，观众给予了五次掌声。而对国王也只有三次。</p>
<p>小说《约翰·克里斯朵夫》，前一半是以贝多芬为原型写的。</p>
<iframe width="100%" height="400px" src="//player.bilibili.com/player.html?aid=7844540&cid=12871747&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h1 id="浪漫主义音乐"><a href="#浪漫主义音乐" class="headerlink" title="浪漫主义音乐"></a>浪漫主义音乐</h1><p>拿破仑战争之后，欧洲进入平稳。浪漫主义音乐家更注重感情和音乐本身的外在表现，而不看重形式和结构。</p>
<h2 id="舒伯特"><a href="#舒伯特" class="headerlink" title="舒伯特"></a>舒伯特</h2><p>600首歌曲，10部交响曲，22部钢琴奏鸣曲和大量的其他作品。</p>
<h2 id="门德尔松"><a href="#门德尔松" class="headerlink" title="门德尔松"></a>门德尔松</h2><p>《仲夏夜之梦》等作品。收集整理了从巴赫到舒曼等著名音乐家的大量作品，对欧洲音乐的传承贡献很大。</p>
<h2 id="肖邦"><a href="#肖邦" class="headerlink" title="肖邦"></a>肖邦</h2><p>1810年出生于波兰。六岁开始学钢琴，8岁登台演出，被认为是继莫扎特贝多芬后的又一位神童。<br>《A大调军队波兰舞曲》和《降A大调英雄波兰舞曲》最有阳刚之气。<br>在法国生活了半辈子，一直眷恋故乡波兰。一生创作很多钢琴曲。作品四类，一类波兰的民族音乐，二类是法国的沙龙音乐，包括圆舞曲、即兴曲、夜曲；三类是炫技类作品；四类是表述内心情感作品。</p>
<h1 id="民族主义音乐"><a href="#民族主义音乐" class="headerlink" title="民族主义音乐"></a>民族主义音乐</h1><p>19世纪末，欧洲人的国家意识加强，浪漫主义音乐渐渐演变成民族主义音乐。成就最高的是俄罗斯的作曲家。</p>
<h2 id="柴可夫斯基"><a href="#柴可夫斯基" class="headerlink" title="柴可夫斯基"></a>柴可夫斯基</h2><p>出身于俄罗斯贵族家庭，父亲从小要求他学习法律，从事相关法律工作。但是他并不喜欢，22岁后考入圣彼得堡音乐学院学习音乐创作。1876年写出了《天鹅湖》芭蕾舞剧。梅克夫人与柴可夫斯基精神上交往了13年并在经济上支持他，并为他排忧解难。成为专职作曲家。但从未谋面。《1812序曲》纪念俄罗斯人在1812年打败拿破仑。1893年创作出了最重要的作品《第六（悲怆）交响曲》写尽了自己的一生酸甜苦辣。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/24/文明之光-反垄断/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/24/文明之光-反垄断/" itemprop="url">文明之光读书笔记-反垄断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-24T23:14:10+08:00">
                2018-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="垄断的形成"><a href="#垄断的形成" class="headerlink" title="垄断的形成"></a>垄断的形成</h1><h2 id="垄断的背景"><a href="#垄断的背景" class="headerlink" title="垄断的背景"></a>垄断的背景</h2><h3 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h3><p>垄断不只是通常人们说的独占市场，任意抬价，这一种表现形式。而且美国历史上上百宗反垄断诉讼，没有一个是控诉垄断哄抬物价的。相反，控诉理由常常会是降价或者补贴。<br>垄断的第二层危险性，是在独占资源或者市场后，肆意的控制市场甚至社会。印象社会公平。<br>范德比尔特和JP摩根是初期时代非常厉害的垄断代表。<br>范德比尔特通过不停的建立控股公司，控制了美国当时10%的财富。并且一个人打败了华尔街。<br>JP摩根在美国1907年的短暂金融危机时，以一己之力力挽狂澜。他控制的美国北方证券公司一度有美国一半的铁路系统，三分之二的钢铁。</p>
<h3 id="出现"><a href="#出现" class="headerlink" title="出现"></a>出现</h3><p>垄断是在第二次工业革命后才出现。<br>以前的生产力，物质的供应一直是供不应求的状态。单纯从供给关系讲，这种情况很容易垄断。因为供应一方可以漫天要价。但是事实不是如此。因为没有一个生产商可以提供一个国家，一个地区甚至一个城市的某种产品的全部生产量。这使那些缺乏竞争力的生产者得以生存。</p>
<p>垄断的形成除了生产力，还需要足够的资金。运输成本和开工厂。在第二次工业革命事情，垄断开始形成，在美国，德国。借助电气革命，采矿业，重工业，铁路运输业，制造业飞速发展。这些新的工商业大佬，对经济和政治的影响力远超以往的富豪。极少数人控制了美国的经济命脉，开始影响政治。</p>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>垄断的方式。信托（Trust）。中文托拉斯。信托是一个虚拟的盒子，可以把任何资产，房子股票钱甚至艺术品的所有权装入。信托注册的地点决定了其适用的法律，税率，政策优惠等。信托好处在于，1，受益人可以有限的使用而不能无度挥霍。2.财产不在属于自然人，避免了对自然人财产的法律限制，例如对个人并购公司的限制。信托的管理者和受益者可以是不同的人，而管理者可以决定如何投资。</p>
<p>信托的例子，洛克菲勒的标准石油公司，联合了40多家石油公司建立了信托。变成标准石油托拉斯。不加入托拉斯的，就会被打压。整个石油市场，别人就没法玩了。垄断把行业的生产力大大提升，降低了成本，有的谋取了超额利润。<br>主要的危害还是这些垄断巨头的经济话语权越来越大，可以在政府中安插代言人，这样美国基层民主政治自治的传统就动摇了。这些寡头成了经济领域的国王。颠覆了社会公平，美国的立国之本。</p>
<h3 id="垄断加速"><a href="#垄断加速" class="headerlink" title="垄断加速"></a>垄断加速</h3><p>1890年立法《谢尔曼反托拉斯法》，1895年，奈特案政府败诉。因为最高法院对《法》的适用范围解释的特别的窄。之后垄断加速。JP摩根为垄断形成提供了巨额资本的支持。</p>
<p>主流历史学家，认为中国专制时代越来越严重的土地兼并现象是导致王朝衰败的根本原因。当少数人在经济领域力获得绝对的权力后，一个政权就走向了衰落的不归路。</p>
<h1 id="反垄断开始"><a href="#反垄断开始" class="headerlink" title="反垄断开始"></a>反垄断开始</h1><p>美国至今还是一个充满活力的社会,而没有陷入贫富悬殊的国家，很大原因是因为美国的立国之本就是公平。反垄断就是其中一条。反垄断本身是人类成熟和进步的标志之一，它反映出，人类开始懂得如何避免兴衰轮回的悲剧。</p>
<p>20世纪初反垄断开始，老罗斯福总统。<br>1902年，要求拆分当时经济基础最为牢固的北方证券公司。在明尼苏达州法院败诉。上诉，在临时联邦法院审理。最终获胜。核心问题1.是北方证券公司是否限制或密谋限制跨州的商业行为和商业竞争。2。是垄断是否剥夺了他人的权利。<br>意义重大，赋予了《谢尔曼反托拉斯法》一个广泛的辖区。判断的重点在于，消费者有无可替代产品和服务，新的从业者能否进入这个行业。<br>紧接着罗斯福又将40多家公司告上法庭。</p>
<h1 id="老罗斯福"><a href="#老罗斯福" class="headerlink" title="老罗斯福"></a>老罗斯福</h1><p>拉什莫尔山的四位总统雕像，开国华盛顿，独立宣言杰佛逊，解放奴隶林肯。<br>美国的国父们建国时期思考的是防止政府权力过大，因此在制宪方面重点考虑了权利的平衡，制约。而他们没想到的经济的迅猛发展，导致了一些商业个人和家族的权力在许多方面甚至超过了政府。</p>
<p>标准石油公司，不仅毁掉了大量竞争对手的生意，而且毁掉了很多人的生活。它在美国经济中获得了无比强大的权力。控制价格，控制铁路电气采油等等上下游产业价格。劳工无法选择工作。贫富分化严重，百分之二的人控制了百分之六十的财富。全社会无能为力。美国的立国之本动摇了。<br>老罗斯福的伟大在于，能把这块硬骨头啃下去，将40多家大企业和托拉斯告上法庭。还给社会公平。把破坏的商业环境修复。自由竞争。</p>
<p>1904，1906年起诉标准石油公司。在1911年要求解散托拉斯。工商业得到一个信号，只要大企业不做控制价格和非正当竞争的事情，他们可以继续发展。</p>
<p>老罗斯福，豪门出身，首先想到的是社会公平，劳工利益以及让发展中国家近代化（庚子赔款退还）。他追求正义和进步的道德力量，称得上是第四位伟人。</p>
<h1 id="进步时代"><a href="#进步时代" class="headerlink" title="进步时代"></a>进步时代</h1><p>老罗斯福，塔夫脱，威尔逊，被称为进步时代。不仅仅是反垄断，而是全方位的变革。<br>鼓励海外投资。征收联邦税。遗产税。《克莱顿反托拉斯法》。妇女获得投票权。</p>
<h1 id="世纪反垄断"><a href="#世纪反垄断" class="headerlink" title="世纪反垄断"></a>世纪反垄断</h1><p>20世纪的三起诉讼。AT&amp;T，IBM和微软。</p>
<p>AT&amp;T被拆分后，形成了更大的电信市场。后来的衰落也和反垄断没有太大的关系，是因为一个战略失误。</p>
<p>IBM捆绑了硬件软件，占据了巨大的市场份额，每年还要收取8-10%的服务费。其他的计算机公司也只能模仿IBM的商业模式，无法创新。反垄13年后，软件硬件捆绑销售的行为有所缓解。为之后的甲骨文，苹果，微软，英特尔兴起。IT服务市场也变大。</p>
<p>微软，三招垄断，1.通过免费软件挤压竞争对手。2.通过软件和操作系统捆绑销售占领市场。3独占操作系统市场后，联合上下游控制PC产业。反垄断很漫长，从1993年到2000年。这个案件帮助互联网公司兴起，也使得Google和苹果在市值上超过了微软。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/31/Javascript函数式编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/Javascript函数式编程/" itemprop="url">Javascript函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-31T22:54:16+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><h2 id="Side-Effect-副作用"><a href="#Side-Effect-副作用" class="headerlink" title="Side Effect, 副作用"></a>Side Effect, 副作用</h2><p>非纯函数会产生副作用。我们一般调用一个函数，是要得到一个返回值，或者处理一些数据。但是如果这个函数在给你返回结果之后，影响了其他对象的状态，包括传入参数，甚至一些全局变量，那么我们就说这个函数又Side Effect，副作用。</p>
<p>所谓纯函数，就是不论你调用他多少次，他都会给你返回相同的结果，并且不会改变其他的变量的状态。</p>
<p>非纯函数在易读性易理解方面，是没有纯函数强的。因为我们需要记住每一次调用非纯函数后产生的各种状态转化，这就增加了程序阅读的难度。</p>
<p>非纯函数，会增加代码阅读时的困难。但这并不是说明我们要远离非纯函数，非纯函数是程序的必备部分。</p>
<h2 id="构造一个纯函数"><a href="#构造一个纯函数" class="headerlink" title="构造一个纯函数"></a>构造一个纯函数</h2><p>一个比较直接的方式，传入所有依赖的状态并做copy。这可能带来开销问题，内存，时间等等。</p>
<p>什么时候选择写一个纯函数，是要根据场景来判断的。纯函数不是解决任何问题的最好方法。</p>
<h1 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h1><p>函数组合是为了避免产生连续的纯函数调用时，依赖的中间状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z = multi(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">z = sum(z,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动组合2</span></span><br><span class="line"><span class="keyword">var</span> z = sum(multi(<span class="number">3</span>,<span class="number">4</span>),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动组合3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiAndSum</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(multi(x,y),z);</span><br><span class="line">&#125;</span><br><span class="line">multiAndSum(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>组合的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">fn1, fn2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">comp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        refurn fn2(fn1(args.shift(), args.shift()), args.shift());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multiAndSum = compose2(multi, sum);</span><br><span class="line">multiAndSum(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">x++; <span class="comment">// allowed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">3</span>;</span><br><span class="line">y++; <span class="comment">//not allowed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> z = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">z = <span class="number">10</span>; <span class="comment">//not allowed</span></span><br><span class="line">z[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// allowed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> w = Object.freeze([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">w = <span class="number">10</span>; /not allowed</span><br><span class="line">w[<span class="number">0</span>] = <span class="number">10</span>; /not allowed</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">doubleThemMutable</span><span class="params">(list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++&gt;) &#123;</span><br><span class="line">        list[i] = list[i] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">doubleThemMutable(arr);</span><br><span class="line">arr; <span class="comment">// [6,8,10];</span></span><br><span class="line"><span class="function">function <span class="title">doubleThemImmutable</span><span class="params">(list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newList = [];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++&gt;) &#123;</span><br><span class="line">        newList[i] = list[i] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = doubelThemImmutable(arr);</span><br><span class="line">arr; <span class="comment">// [3,4,5]</span></span><br><span class="line">arr2; <span class="comment">//[6,8,10]</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/31/Nginx配置笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/Nginx配置笔记/" itemprop="url">Nginx配置笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-31T22:06:41+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在yum repo配置目录下创建nginx镜像配置， /etc/yum.repos.d/nginx.repo， 文件nginx.repo填入如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<p>然后运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure>
<p>如果出错，需要检查配置文件内容是否有误，也有可能是cache问题，运行yum clean all 即可。</p>
<p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start # 启动Nginx服务</span><br><span class="line"> </span><br><span class="line">/etc/init.d/nginx stop # 停止Nginx服务</span><br><span class="line"> </span><br><span class="line">/etc/nginx/nginx.conf # Nginx配置文件</span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>将域名 <a href="http://www.domain.com" target="_blank" rel="noopener">www.domain.com</a> 的证书文件1_<a href="http://www.domain.com_bundle.crt" target="_blank" rel="noopener">www.domain.com_bundle.crt</a> 、私钥文件2_<a href="http://www.domain.com.key保存到同一个目录，例如/usr/local/nginx/conf目录下。" target="_blank" rel="noopener">www.domain.com.key保存到同一个目录，例如/usr/local/nginx/conf目录下。</a><br>更新Nginx根目录下 conf/nginx.conf 文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate 1_www.domain.com_bundle.crt;</span><br><span class="line">        ssl_certificate_key 2_www.domain.com.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; #站点目录</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-rewrite-to-HTTPS"><a href="#HTTP-rewrite-to-HTTPS" class="headerlink" title="HTTP rewrite to HTTPS"></a>HTTP rewrite to HTTPS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen         80;</span><br><span class="line">   server_name    www.domain.com;</span><br><span class="line">   return         301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://serverfault.com/questions/67316/in-nginx-how-can-i-rewrite-all-http-requests-to-https-while-maintaining-sub-dom" target="_blank" rel="noopener">https://serverfault.com/questions/67316/in-nginx-how-can-i-rewrite-all-http-requests-to-https-while-maintaining-sub-dom</a></p>
<p><a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/" target="_blank" rel="noopener">https://www.nginx.com/resources/wiki/start/topics/tutorials/install/</a></p>
<p><a href="https://nginx.org/en/docs/beginners_guide.html" target="_blank" rel="noopener">https://nginx.org/en/docs/beginners_guide.html</a></p>
<p><a href="https://cloud.tencent.com/document/product/400/4143" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/400/4143</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Roger Guo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roger Guo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
