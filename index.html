<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Roger Guo&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Roger Guo&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roger Guo&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Roger Guo's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Roger Guo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/DDIA-8-分布式系统的挑战/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/27/DDIA-8-分布式系统的挑战/" itemprop="url">DDIA-8-分布式系统的挑战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-27T20:35:37+08:00">
                2019-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>所有可能出错的事情一定会出错</p>
<h1 id="故障与部分失效"><a href="#故障与部分失效" class="headerlink" title="故障与部分失效"></a>故障与部分失效</h1><p>单节点的应用，质量合格情况下，操作有确定性。要么完全正常工作，要么就是完全失败（硬件问题，等）。<br>分布式系统，有多台节点的时，情况发生了根本变化。多接点复杂性，部分失效（网络分区）。</p>
<h2 id="云计算和超算"><a href="#云计算和超算" class="headerlink" title="云计算和超算"></a>云计算和超算</h2><ol>
<li>一个极端是高性能计算。计算密集型的科学任务。</li>
<li>另一个计算是云计算。通用计算机用网络连接，弹性/按需分配资源。</li>
<li>传统企业数据中心介于二者之间。</li>
</ol>
<p>基于互联网的系统，与高性能计算有很多不同：</p>
<ol>
<li>服务是不可离线计算的，需要随时为用户提供低延迟服务。</li>
<li>硬件廉价的单节点聚合，故障率高。</li>
<li>节点之间通过网络连接</li>
<li>系统越大，局部组建失效的概率就越大</li>
<li>HA的要求</li>
<li>节点之间额通讯可能不可靠。</li>
</ol>
<p>所以系统的故障处理设计非常重要。软件要能够处理这种故障。要知道系统故障时候预期的行为。</p>
<h1 id="不可靠的网络"><a href="#不可靠的网络" class="headerlink" title="不可靠的网络"></a>不可靠的网络</h1><p>基于不可靠的组建构建可靠的系统</p>
<ol>
<li>纠错码</li>
<li>TCP在不可靠的IP层提供可靠传输。</li>
</ol>
<img src="/2019/06/27/DDIA-8-分布式系统的挑战/如果请求没有得到响应，无法区分原因。.png">
<h2 id="现实中的网络故障"><a href="#现实中的网络故障" class="headerlink" title="现实中的网络故障"></a>现实中的网络故障</h2><p>人为+机器故障。发生概率高。</p>
<p>设计方面：出现网络问题，软件的应对策略需要容错和恢复。除了容错措施，还可以做的就是给用户提示错误信息。</p>
<p>运维方面：推荐人为的触发网络问题，来测试系统的反应情况。</p>
<h2 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h2><p>软件系统需要自动检测节点失效的功能。包括以下的设计：</p>
<ol>
<li>不向已经失效的节点继续发送request</li>
<li>主从模式，主节点失效后，要触发选举新主。</li>
</ol>
<p>确定问题出在哪里有可能很困难。如果想知道一个请求是否执行成功，需要应用级别的恢复。</p>
<h2 id="超时与无限期的延迟"><a href="#超时与无限期的延迟" class="headerlink" title="超时与无限期的延迟"></a>超时与无限期的延迟</h2><p>存在过场等待，误判节点死亡的可能。</p>
<p>2d+r设置理想的超时时间。但是异步网络系统对响应延迟没有任何保证。</p>
<p>网络延迟的根源是<strong>排队</strong></p>
<ol>
<li>多对一的发送，接收的单节点负载过重，发生拥塞。队列慢后被丢弃，引发重传。</li>
<li>接收放机器的CPU忙碌。处理延迟。</li>
<li>虚拟化导致的CPU占用。</li>
<li>TCP流量控制</li>
</ol>
<img src="/2019/06/27/DDIA-8-分布式系统的挑战/如果有多台机器将网络流量发送到同一目的地，则其交换机队列可能会被填满。在这里，端口1,2和4都试图发送数据包到端口3.png">
<p>TCP vs UDP</p>
<p>不稳定网络环境下，超时设置：</p>
<ol>
<li>超时的设置可以通过实验一步步确定。</li>
<li>自适应的动态超时调整。</li>
</ol>
<h2 id="同步与异步网络"><a href="#同步与异步网络" class="headerlink" title="同步与异步网络"></a>同步与异步网络</h2><p>拨打电话的网络是同步网络，预留了带宽资源。端到端的延迟有界。资源利用率低。</p>
<p>TCP是基于共享带宽的。IP协议本身就有排队的影响。有不确定性。但是资源利用率高。</p>
<p>延迟是成本和收益的相互博弈的结果。</p>
<h1 id="不可靠的时钟"><a href="#不可靠的时钟" class="headerlink" title="不可靠的时钟"></a>不可靠的时钟</h1><p>有两种时间问题：</p>
<ol>
<li>测量持续时间。（request的发送到响应的时间间隔）</li>
<li>某个定点的时间值。（特定的日期时间，触发事件）</li>
</ol>
<p>NTP协议，同步机器时钟。</p>
<h2 id="单调时钟与墙上时钟"><a href="#单调时钟与墙上时钟" class="headerlink" title="单调时钟与墙上时钟"></a>单调时钟与墙上时钟</h2><ol>
<li>墙上时钟。某个时间点。Linux上的clock_gettime(CLOCK_REALTIME)和Java中的System.currentTimeMillis()</li>
<li>单调时钟，测量时间段。Linux上的clock_gettime(CLOCK_MONOTONIC)，和Java中的System.nanoTime()都是单调时钟</li>
</ol>
<h2 id="时钟同步与准确性"><a href="#时钟同步与准确性" class="headerlink" title="时钟同步与准确性"></a>时钟同步与准确性</h2><p>需要同步的是<strong>单调时钟</strong>；硬件时钟和NTP可能会出现问题：</p>
<ol>
<li>计算机中的石英钟不够精确：它会漂移（drifts）（运行速度快于或慢于预期）时钟漂移取决于机器的温度.</li>
<li>本地时钟和NTP时钟差距过大，出现时间突然倒退或者前进。</li>
<li>NTP因为网络延迟，对精度产生影响。</li>
<li>NTP服务器本身错误。</li>
<li>闰秒</li>
<li>虚拟化导致的一些毫秒级的延迟。</li>
<li>用户故意设置错误时间。</li>
</ol>
<h2 id="依赖同步的时钟"><a href="#依赖同步的时钟" class="headerlink" title="依赖同步的时钟"></a>依赖同步的时钟</h2><p>​如果你使用需要同步时钟的软件，必须仔细监控所有机器之间的时钟偏移。时钟偏离其他时钟太远的节点应当被宣告死亡，并从集群中移除。这样的监控可以确保你在损失发生之前注意到破损的时钟</p>
<h3 id="时间戳与事件顺序"><a href="#时间戳与事件顺序" class="headerlink" title="时间戳与事件顺序"></a>时间戳与事件顺序</h3><p>跨节点的事件排序。使用墙上时钟。采用LWW策略会出现的问题。</p>
<p>节点之间的时间偏差会导致数据顺序排序有问题。</p>
<img src="/2019/06/27/DDIA-8-分布式系统的挑战/客户端B的写入比客户端A的写入要晚，但是B的写入具有较早的时间戳。.png">
<p><strong>更安全的方式</strong><br>所谓的逻辑时钟是基于递增计数器而不是振荡石英晶体，对于排序事件来说是更安全的选择（请参见“检测并发写入”）。逻辑时钟不测量一天中的时间或经过的秒数，而仅测量事件的相对顺序（无论一个事件发生在另一个事件之前还是之后）。相反，用来测量实际经过时间的时钟和单调钟也被称为物理时钟。我们将在“顺序保证”中查看更多订购信息。</p>
<h3 id="时钟置信区间"><a href="#时钟置信区间" class="headerlink" title="时钟置信区间"></a>时钟置信区间</h3><p>使用公共互联网上的NTP服务器，最好的准确度可能达到几十毫秒，而且当网络拥塞时，误差可能会超过100毫秒</p>
<p>因此，<strong>将时钟读数视为一个精确的时间点是不应该的</strong>——它更像是一段时间范围：例如，一个系统可能以95％的置信度认为当前时间处于本分钟内的第10.3秒和10.5秒之间，它可能没法比这更精确了</p>
<p>Spanner中的Google TrueTime API，它明确地报告了本地时钟的置信区间。</p>
<h3 id="全局快照的同步时钟"><a href="#全局快照的同步时钟" class="headerlink" title="全局快照的同步时钟"></a>全局快照的同步时钟</h3><p>快照隔离中会需要单调递增的事务ID。如果一个写入发生在快照之后，那么这个数据就对该快照不可见。单机容易实现。</p>
<p>在多接点的环境中，需要复杂的协调产生这个唯一的递增ID。<br>（跨所有分区）全局单调递增的事务ID可能很难生成。事务ID必须反映因果关系：如果事务B读取由事务A写入的值，则B必须具有比A更大的事务ID，否则快照就无法保持一致。在有大量的小规模、高频率的事务情景下，在分布式系统中创建事务ID成为一个站不住脚的瓶颈。</p>
<p>更晚的事务会有更大的时间戳。当然，问题在于时钟精度的不确定性。Spanner以这种方式实现跨数据中心的快照隔离。​    为了确保事务时间戳反映因果关系，在提交读写事务之前，Spanner在提交读写事务时，会故意等待置信区间长度的时间。这样读事务会处于足够晚的时间，两个事务之间的置信区间不会重叠。</p>
<h2 id="进程暂停"><a href="#进程暂停" class="headerlink" title="进程暂停"></a>进程暂停</h2><p>例子：数据库主节点确定自己是否被其他节点宣布死亡，要用到<strong>租约</strong>。是一个带有超时的锁。任何一个时刻只有一个节点可以持有这个租约。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">	request=getIncomingRequest();</span><br><span class="line">	// 确保租约还剩下至少10秒</span><br><span class="line">	if (lease.expiryTimeMillis-System.currentTimeMillis()&lt; 10000)&#123;</span><br><span class="line">		lease = lease.renew();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(lease.isValid())&#123;</span><br><span class="line">    	process(request);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序执行中出现了意外的停顿呢？例如，想象一下，线程在lease.isValid()行周围停止15秒，然后才终止。</p>
<p>发生的原因：</p>
<ol>
<li>GC</li>
<li>虚拟化挂起</li>
<li>操作系统上下文切换时，切换到另一个进程话费了更多的时间。</li>
<li>同步磁盘访问</li>
<li>内存页面抖动</li>
</ol>
<p>所有的这些时间都是可以随时<strong>抢占</strong>正在运行的进程。在之后恢复。</p>
<p>分布式系统中的一节点不许假定执行过程中的任何时刻都可能被暂停，而且时间不确定。</p>
<h3 id="响应时间保证"><a href="#响应时间保证" class="headerlink" title="响应时间保证"></a>响应时间保证</h3><p>仔细调教系统，避免很多次的这种暂停。</p>
<h3 id="调整垃圾回收影响"><a href="#调整垃圾回收影响" class="headerlink" title="调整垃圾回收影响"></a>调整垃圾回收影响</h3><p>​    一个新兴的想法是将GC暂停视为一个节点的短暂计划中断，并让其他节点处理来自客户端的请求，同时一个节点正在收集其垃圾。如果运行时可以警告应用程序一个节点很快需要GC暂停，那么应用程序可以停止向该节点发送新的请求，等待它完成处理未完成的请求，然后在没有请求正在进行时执行GC。</p>
<p>这个想法的一个变种是只用垃圾收集器来处理短命对象（这些对象要快速收集），并定期在积累大量长寿对象（因此需要完整GC）之前重新启动进程</p>
<p>这些措施不能完全阻止垃圾回收暂停，但可以有效地减少它们对应用的影响。</p>
<h1 id="知识，真相，谎言"><a href="#知识，真相，谎言" class="headerlink" title="知识，真相，谎言"></a>知识，真相，谎言</h1><h2 id="真相由多数觉得（法定人数）"><a href="#真相由多数觉得（法定人数）" class="headerlink" title="真相由多数觉得（法定人数）"></a>真相由多数觉得（法定人数）</h2><p>一个节点发生故障的可能性有很多。自身故障；网络通讯丢失；GC过长；</p>
<p>节点不能根据自己的信息来判断自身的状态。目前分布式算法都依靠法定票数。最常见的法定票数是取系统节点半数以上。</p>
<h3 id="主节点与锁"><a href="#主节点与锁" class="headerlink" title="主节点与锁"></a>主节点与锁</h3><p>只允许有一个实例存在的例子：</p>
<ol>
<li>只允许一个节点作为数据库分区主节点</li>
<li>特定资源的锁（事务获取资源锁）</li>
<li>不能重复的用户名</li>
</ol>
<img src="/2019/06/27/DDIA-8-分布式系统的挑战/分布式锁的实现不正确：客户端1认为它仍然具有有效的租约，即使它已经过期，从而破坏了存储中的文件.png">
<p>要处理节点被宣布失效后的降级操作。</p>
<h3 id="Fencing令牌"><a href="#Fencing令牌" class="headerlink" title="Fencing令牌"></a>Fencing令牌</h3><p>我们假设每次锁定服务器授予锁或租约时，它还会返回一个fencing令牌（fencing token），这个数字在每次授予锁定时都会增加（例如，由锁定服务增加）。然后，我们可以要求客户端每次向存储服务发送写入请求时，都必须包含当前的fencing令牌。</p>
<img src="/2019/06/27/DDIA-8-分布式系统的挑战/只允许以增加屏蔽令牌的顺序进行写操作，从而保证存储安全.png">
<p>对于不明确支持fencing令牌的资源，可能仍然可以解决此限制（例如，在文件存储服务的情况下，可以将防护令牌包含在文件名中）。但是，为了避免在锁的保护之外处理请求，需要进行某种检查。</p>
<h2 id="拜占庭故障"><a href="#拜占庭故障" class="headerlink" title="拜占庭故障"></a>拜占庭故障</h2><p>伪造令牌，有节点故意破坏。</p>
<p>拜占庭故障（Byzantine fault），在不信任的环境中达成共识的问题被称为拜占庭将军问题</p>
<p>现实中的例子：</p>
<ol>
<li>航空航天的硬件，被辐射发生故障。</li>
<li>在多个参与组织的系统中，一些参与者可能会试图作弊或者欺骗他人。</li>
</ol>
<p>解决拜占庭容错的系统协议<strong>异常复杂</strong>；容错的嵌入式系统还需要硬件层面的支持。</p>
<p>普通的web应用不需要拜占庭容错，因为可以由服务其全权觉得请求是不是合法。在那种没有这种中央决策机制的点对点网络中，拜占庭容错才更为必要。</p>
<p>大多数拜占庭式容错算法要求超过三分之二的节点能够正常工作。</p>
<p>如果攻击者可以渗透一个节点，那他们可能会渗透所有这些节点，因为它们可能运行相同的软件。因此传统机制（认证，访问控制，加密，防火墙等）仍然是攻击者的主要保护措施。</p>
<h3 id="弱的谎言形式以及预防："><a href="#弱的谎言形式以及预防：" class="headerlink" title="弱的谎言形式以及预防："></a>弱的谎言形式以及预防：</h3><p>当系统由于硬件，bug，配置错误发生了错误，可以采取一些方案来让系统更可靠：</p>
<ol>
<li>TCP/UDP内置的校验和</li>
<li>总是检查用户的输入是否合法</li>
<li>NTP客户端配置多个时间服务器</li>
</ol>
<h3 id="理论系统模型与实践"><a href="#理论系统模型与实践" class="headerlink" title="理论系统模型与实践"></a>理论系统模型与实践</h3><h4 id="计时方面："><a href="#计时方面：" class="headerlink" title="计时方面："></a>计时方面：</h4><ol>
<li>同步模型</li>
<li>部分同步模型</li>
<li>异步模型</li>
</ol>
<h4 id="处理节点失效："><a href="#处理节点失效：" class="headerlink" title="处理节点失效："></a>处理节点失效：</h4><ol>
<li>崩溃-中止模型</li>
<li>崩溃-恢复模型</li>
<li>拜占庭（任意）失效模型</li>
</ol>
<h4 id="对于fencing令牌生成算法模型要求："><a href="#对于fencing令牌生成算法模型要求：" class="headerlink" title="对于fencing令牌生成算法模型要求："></a>对于fencing令牌生成算法模型要求：</h4><ol>
<li>唯一性</li>
<li>单调递增性</li>
<li>可以用性</li>
</ol>
<h4 id="安全性和活性"><a href="#安全性和活性" class="headerlink" title="安全性和活性"></a>安全性和活性</h4><p>安全性通常被非正式地定义为，没有坏事发生，而活性通常就类似：最终好事发生。但是，最好不要过多地阅读那些非正式的定义，因为好与坏的含义是主观的。</p>
<p>在刚刚给出的例子中，唯一性（uniqueness）和单调序列（monotonic sequence）是安全属性，但可用性是<strong>活性（liveness</strong>属性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/DDIA-7-事务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/DDIA-7-事务/" itemprop="url">DDIA-7-事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-12T08:46:48+08:00">
                2019-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事务主要是为了应对可能的出错情况。硬件软件的失效，应用与数据库节点之间的连接出问题，客户端竞争导致的写入覆盖等问题。</p>
<p>数据库事务，主要是为了<strong>简化应用层的编程模型</strong>。并非每个应用都需要事务机制。</p>
<h1 id="深入理解事务"><a href="#深入理解事务" class="headerlink" title="深入理解事务"></a>深入理解事务</h1><p>关系型数据库都支持事务，有些非关系型也支持。</p>
<p>很多新一代数据库（NoSQL）放弃了事务，或者替换为比其更弱的保证。</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>不符合ACID标准的系统有时被冠以BASE</p>
<h3 id="A-原子性"><a href="#A-原子性" class="headerlink" title="A 原子性"></a>A 原子性</h3><p>提交过程中发生故障，事务会终止，并且丢弃或者撤销之前的部分更改。</p>
<h3 id="C-一致性"><a href="#C-一致性" class="headerlink" title="C 一致性"></a>C 一致性</h3><p>对数据的一组特定陈述必须始终成立。即不变量（invariants），例如在会计系统中，所有账户整体上必须借贷相抵。</p>
<p>一致性本质上要求应用层来维护状态的一致（或者守恒）。</p>
<h3 id="I-隔离性"><a href="#I-隔离性" class="headerlink" title="I 隔离性"></a>I 隔离性</h3><p>如果两个客户端同时访问一条记录，可能会遇到并发问题（带来竞争条件）。</p>
<p>计数器的例子。</p>
<img src="/2019/06/12/DDIA-7-事务/两个客户之间的竞争状态同时递增计数器.png">
<p>传统的数据库教科书将隔离性形式化为可序列化（Serializability），这意味着每个事务可以假装它是唯一在整个数据库上运行的事务。</p>
<p>然而实践中很少会使用可序列化隔离，因为它有性能损失。一些流行的数据库如Oracle 11g，甚至没有实现它。在Oracle中有一个名为“可序列化”的隔离级别，但实际上它实现了一种叫做快照隔离（snapshot isolation） 的功能，这是一种比可序列化更弱的保证。</p>
<h3 id="D-持久性"><a href="#D-持久性" class="headerlink" title="D 持久性"></a>D 持久性</h3><p>持久性 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p>
<p>在历史上，持久性意味着写入归档磁带。后来它被理解为写入硬盘或SSD。最近它已经适应了“复制（replication）”的新内涵。</p>
<h2 id="单对象与多对象事务"><a href="#单对象与多对象事务" class="headerlink" title="单对象与多对象事务"></a>单对象与多对象事务</h2><p>数据库提供的保证是</p>
<ul>
<li>原子性， 要么全部成功，要么全部失败。</li>
<li>隔离性， 同时运行的事务之间不应互相干扰。</li>
</ul>
<p>违反隔离性的例子，邮件系统的未读邮件计数器和邮件，在写入的时候不应该被其他客户端读区到不一致的状态。</p>
<img src="/2019/06/12/DDIA-7-事务/违反隔离性：一个事务读取另一个事务的未被执行的写入（“脏读”）。.png">
<h3 id="单对象写入"><a href="#单对象写入" class="headerlink" title="单对象写入"></a>单对象写入</h3><p>一些数据库也提供更复杂的原子操作，例如自增操作。同样流行的是 比较和设置（CAS, compare-and-set） 操作，当值没有并发被其他人修改过时，才允许执行写操作。</p>
<h3 id="多对象事务"><a href="#多对象事务" class="headerlink" title="多对象事务"></a>多对象事务</h3><p>需要多对象事务的情况：</p>
<ol>
<li>关系型，外键插入时的正确性验证。</li>
<li>文档型，更新非规范化（因为缺乏连接能力）信息时，一次更新多个文档。</li>
<li>二级索引的更新</li>
</ol>
<h3 id="处理错误与中止"><a href="#处理错误与中止" class="headerlink" title="处理错误与中止"></a>处理错误与中止</h3><p>错误发生不可避免，但许多软件开发人员倾向于只考虑乐观情况，而不是错误处理的复杂性。例如，像Rails的ActiveRecord和Django这样的对象关系映射（ORM, object-relation Mapping） 框架不会重试中断的事务—— 这个错误通常会导致一个从堆栈向上传播的异常，所以任何用户输入都会被丢弃，用户拿到一个错误信息。这实在是太耻辱了，因为中止的重点就是允许安全的重试。</p>
<h1 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h1><p>出于这个原因，数据库一直试图通过提供事务隔离（transaction isolation） 来隐藏应用程序开发者的并发问题。从理论上讲，隔离可以通过假装没有并发发生，让你的生活更加轻松：可序列化（serializable） 的隔离等级意味着数据库保证事务的效果与连续运行（即一次一个，没有任何并发）是一样的。</p>
<p>实际上不幸的是：隔离并没有那么简单。可序列化 会有性能损失，许多数据库不愿意支付这个代价。因此，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题。这些隔离级别难以理解，并且会导致微妙的错误，但是它们仍然在实践中被使用。</p>
<h2 id="读已提交（Read-Commited）"><a href="#读已提交（Read-Commited）" class="headerlink" title="读已提交（Read Commited）"></a>读已提交（Read Commited）</h2><ol>
<li>读数据库时，只能看到已经提交的数据（防止脏读）</li>
<li>写数据库时，只能覆盖已经提交的数据（防止脏写）</li>
</ol>
<h3 id="防止脏读"><a href="#防止脏读" class="headerlink" title="防止脏读"></a>防止脏读</h3><p>如果一个事务可以看到另一个事务还没有完全提交的数据，那么就是脏读。</p>
<p>读已提交的隔离级别可以防止脏读。</p>
<img src="/2019/06/12/DDIA-7-事务/没有脏读：用户2只有在用户1的事务已经提交后才能看到x的新值。.png">
<p>需要防止脏读的情况：</p>
<ol>
<li>一个事务需要修改多个对象，并且这些对象有一致性的保证。例如电子邮件的例子。</li>
<li>如果事务发生中止，所有的写入都要回滚。如果发生脏读，那么会看到一些会被回滚的数据，可能会造成麻烦。</li>
</ol>
<h3 id="防止脏写"><a href="#防止脏写" class="headerlink" title="防止脏写"></a>防止脏写</h3><p>两个事务更新同一个对象，如果一个事务的写入操作覆盖了另一个事务尚未提交的一部分，那么就是脏写。</p>
<p>读已提交的隔离级别可以防止脏写。通常的方式是推迟第二个写请求，直到前面的事务提交成功（或者中止）。</p>
<p>二手车买卖的例子，买同一辆车，车主和销售发票的所有者要一致。</p>
<img src="/2019/06/12/DDIA-7-事务/如果存在脏写，来自不同事务的冲突写入可能会混淆在一起.png">
<h3 id="实现读已提交"><a href="#实现读已提交" class="headerlink" title="实现读已提交"></a>实现读已提交</h3><p>数据库通常使用<strong>行级锁</strong>来防止脏写。</p>
<p>防止脏读，用锁太重了。大多数数据库通常都会对待更新的对象，维护旧值和当前持有写锁的事务的新值两个版本。</p>
<h2 id="快照级别隔离和可重复读（Repeatable-Read）"><a href="#快照级别隔离和可重复读（Repeatable-Read）" class="headerlink" title="快照级别隔离和可重复读（Repeatable Read）"></a>快照级别隔离和可重复读（Repeatable Read）</h2><p>读已提交解决不了一些场景中的问题，会导致错误。</p>
<p>银行转账的例子。</p>
<img src="/2019/06/12/DDIA-7-事务/读取偏差：Alice观察数据库处于不一致的状态.png">
<p>爱丽丝在银行有1000美元的储蓄，分为两个账户，每个500美元。现在一笔事务从她的一个账户中转移了100美元到另一个账户。如果她在事务处理的同时查看其账户余额列表，不幸地在转账事务完成前看到收款账户余额（余额为500美元），而在转账完成后看到另一个转出账户（已经转出100美元，余额400美元）。对爱丽丝来说，现在她的账户似乎只有900美元——看起来100美元已经消失了。</p>
<p>这种异常被称为不可重复读（nonrepeatable read）或读取偏差（read skew）</p>
<p>还有一些场景不能容忍暂止的不一致，数据备份，分析查询和完整性检查场景。</p>
<p><strong>快照级别隔离</strong>是常见的解决手段。快照隔离是一个流行的功能：PostgreSQL，使用InnoDB引擎的MySQL，Oracle，SQL Server等都支持。</p>
<h3 id="实现快照级别隔离"><a href="#实现快照级别隔离" class="headerlink" title="实现快照级别隔离"></a>实现快照级别隔离</h3><p>与读取提交的隔离类似，快照隔离的实现通常使用写锁来防止脏写。</p>
<p>但是读取不需要任何锁定。从性能的角度来看，快照隔离的一个关键原则是：读不阻塞写，写不阻塞读。</p>
<p>为了实现快照隔离，数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它并排维护着多个版本的对象，所以这种技术被称为多版本并发控制（MVCC, multi-version concurrentcy control）。</p>
<p>图种说明了，如何在PostgreSQL中实现基于MVCC的快照隔离【31】（其他实现类似）。当一个事务开始时，它被赋予一个唯一的，永远增长[^vii]的事务ID（txid）。每当事务向数据库写入任何内容时，它所写入的数据都会被标记上写入者的事务ID。</p>
<img src="/2019/06/12/DDIA-7-事务/使用多版本对象实现快照隔离.png">
<p>表中的每一行都有一个 created_by 字段，其中包含将该行插入到表中的的事务ID。此外，每行都有一个 deleted_by 字段，最初是空的。如果某个事务删除了一行，那么该行实际上并未从数据库中删除，而是通过将 deleted_by 字段设置为请求删除的事务的ID来标记为删除。在稍后的时间，当确定没有事务可以再访问已删除的数据时，数据库中的垃圾收集过程会将所有带有删除标记的行移除，并释放其空间。</p>
<h3 id="一致性快照的可见性规则"><a href="#一致性快照的可见性规则" class="headerlink" title="一致性快照的可见性规则"></a>一致性快照的可见性规则</h3><p>当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象。通过仔细定义可见性规则，数据库可以向应用程序呈现一致的数据库快照。</p>
<h3 id="索引与快照级别隔离"><a href="#索引与快照级别隔离" class="headerlink" title="索引与快照级别隔离"></a>索引与快照级别隔离</h3><p>如何支持索引？</p>
<ol>
<li>直接指向对象的所有版本。</li>
<li>Copy on write。每次修改时候，复制一个B-tree。后台回收和压缩。</li>
</ol>
<h2 id="防止更新丢失"><a href="#防止更新丢失" class="headerlink" title="防止更新丢失"></a>防止更新丢失</h2><p>例子，两个并发的计数器更新。</p>
<p>如果应用从数据库中读取一些值，修改它并写回修改的值（读取-修改-写入序列），则可能会发生丢失更新的问题。如果两个事务同时执行，则其中一个的修改可能会丢失，因为第二个写入的内容并没有包括第一个事务的修改。</p>
<p>场景，递增计数器；更新账户余额；对复杂对象的一部分修改；两个用户同时编辑wiki页面。</p>
<h3 id="原子写操作"><a href="#原子写操作" class="headerlink" title="原子写操作"></a>原子写操作</h3><p>有些数据库支持的原子操作。可以避免在应用层的“读取-修改-写入”操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE counters SET value = value + 1 WHERE key = &apos;foo&apos;;</span><br></pre></td></tr></table></figure>
<p>像MongoDB这样的文档数据库提供了对JSON文档的一部分进行本地修改的原子操作，Redis提供了修改数据结构（如优先级队列）的原子操作</p>
<h3 id="显示加锁"><a href="#显示加锁" class="headerlink" title="显示加锁"></a>显示加锁</h3><p>Select … for update 加行锁</p>
<p>这是有效的，但要做对，你需要仔细考虑应用逻辑。忘记在代码某处加锁很容易引入竞争条件。</p>
<h3 id="自动检查更新丢失"><a href="#自动检查更新丢失" class="headerlink" title="自动检查更新丢失"></a>自动检查更新丢失</h3><p>另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列。</p>
<p>丢失更新检测是一个很好的功能，因为它不需要应用代码使用任何特殊的数据库功能，你可能会忘记使用锁或原子操作，从而引入错误；但丢失更新的检测是自动发生的，因此不太容易出错。</p>
<h3 id="原子比较与设置"><a href="#原子比较与设置" class="headerlink" title="原子比较与设置"></a>原子比较与设置</h3><p>CAS，</p>
<p>例如，为了防止两个用户同时更新同一个wiki页面，可以尝试类似这样的方式，只有当用户开始编辑页面内容时，才会发生更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 根据数据库的实现情况，这可能也可能不安全</span><br><span class="line">UPDATE wiki_pages SET content = &apos;新内容&apos;</span><br><span class="line">  WHERE id = 1234 AND content = &apos;旧内容&apos;;</span><br></pre></td></tr></table></figure>
<p>ABA问题？</p>
<h3 id="冲突解决和复制"><a href="#冲突解决和复制" class="headerlink" title="冲突解决和复制"></a>冲突解决和复制</h3><p>在复制数据库中（参见第5章），防止丢失的更新需要考虑另一个维度：由于在多个节点上存在数据副本，并且在不同节点上的数据可能被并发地修改，因此需要采取一些额外的步骤来防止丢失更新。</p>
<p>如“检测并发写入”一节所述，这种复制数据库中的一种常见方法是允许并发写入创建多个冲突版本的值（也称为兄弟），并使用<strong>应用代码或特殊数据结构在事实发生之后解决和合并</strong>这些版本。</p>
<p>另一方面，<strong>最后写入为准</strong>（LWW）的冲突解决方法很容易丢失更新，如“最后写入为准（丢弃并发写入）”中所述。不幸的是，LWW是许多复制数据库中的默认值。</p>
<h2 id="写入偏差与幻读"><a href="#写入偏差与幻读" class="headerlink" title="写入偏差与幻读"></a>写入偏差与幻读</h2><p>医院排班on call的例子。并发请假，导致应用的错误。</p>
<img src="/2019/06/12/DDIA-7-事务/写入偏差导致应用程序错误的示例.png">
<h3 id="写偏差的特征"><a href="#写偏差的特征" class="headerlink" title="写偏差的特征"></a>写偏差的特征</h3><p>它既不是脏写，也不是丢失更新，因为这两个事务正在更新两个不同的对象。在这里发生的冲突并不是那么明显，但是这显然是一个竞争条件：如果两个事务一个接一个地运行，那么第二个医生就不能歇班了。异常行为只有在事务并发进行时才有可能。</p>
<p>如果无法使用<strong>可序列化的隔离级别</strong>，则此情况下的次优选项可能是<strong>显式锁定事务所依赖的行</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION;</span><br><span class="line">SELECT * FROM doctors</span><br><span class="line">  WHERE on_call = TRUE </span><br><span class="line">  AND shift_id = 1234 FOR UPDATE;</span><br><span class="line"></span><br><span class="line">UPDATE doctors</span><br><span class="line">  SET on_call = FALSE</span><br><span class="line">  WHERE name = &apos;Alice&apos; </span><br><span class="line">  AND shift_id = 1234;</span><br><span class="line">  </span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<h3 id="更多写偏差的例子"><a href="#更多写偏差的例子" class="headerlink" title="更多写偏差的例子"></a>更多写偏差的例子</h3><ol>
<li>会议室预定系统，double booking</li>
<li>多人游戏, 棋盘上同时移动不同的棋子，但是要预防违反游戏规则。</li>
<li>申请同一个用户名，重名问题，可以使用Unique Key</li>
<li>防止双重开支，超额支付信用或者存款。</li>
</ol>
<h3 id="产生写偏差的原因"><a href="#产生写偏差的原因" class="headerlink" title="产生写偏差的原因"></a>产生写偏差的原因</h3><p>一个事务中的写入改变另一个事务的搜索查询的结果，被称为幻读。</p>
<h3 id="物化冲突"><a href="#物化冲突" class="headerlink" title="物化冲突"></a>物化冲突</h3><p>如果幻读的问题是没有对象可以加锁，也许可以人为地在数据库中引入一个锁对象。</p>
<p>例如会议室预定，可以想象创建一个关于时间槽和房间的表。要创建预订的事务可以锁定（SELECT FOR UPDATE）表中与所需房间和时间段对应的行。</p>
<p>这种方法被称为物化冲突（materializing conflicts），因为它将幻读变为数据库中一组具体行上的锁冲突</p>
<p><strong>在大多数情况下。可序列化（Serializable） 的隔离级别是更可取的。</strong></p>
<h1 id="串行化（Serialize）"><a href="#串行化（Serialize）" class="headerlink" title="串行化（Serialize）"></a>串行化（Serialize）</h1><p>最强的隔离级别。</p>
<p>数据库保证，如果事务在单独运行时行为正确，则它们在并发运行时仍然正确，换句话说，数据库防止所有可能的竞争条件。</p>
<p>目前大多数提供可序列化的数据库都使用了三种技术之一，本章的剩余部分将会介绍这些技术。</p>
<ol>
<li>字面意义上地串行顺序执行事务（参见“真的串行执行”）</li>
<li>两相锁定（2PL, two-phase locking），几十年来唯一可行的选择。（参见“两相锁定（2PL）”）</li>
<li>乐观并发控制技术，例如可序列化的快照隔离（serializable snapshot isolation）（参阅“可序列化的快照隔离（SSI）”</li>
</ol>
<h3 id="真的串行执行"><a href="#真的串行执行" class="headerlink" title="真的串行执行"></a>真的串行执行</h3><p>单线程循环执行事务。</p>
<p>基础：</p>
<ol>
<li>内存中可以加载应用需要的所有数据，之后的事务操作都在内存中，快。</li>
<li>OLTP一般都很快，只是少量的读写。</li>
</ol>
<p>串行执行事务的方法在VoltDB/H-Store，Redis和Datomic中实现。</p>
<h4 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h4><p>具有单线程串行事务处理的系统不允许交互式的多语句事务。应用程序必须提前将整个事务代码作为存储过程提交给数据库。</p>
<h4 id="存储过程优缺点"><a href="#存储过程优缺点" class="headerlink" title="存储过程优缺点"></a>存储过程优缺点</h4><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>厂商们在存储过程的语言不一致；</li>
<li>代码难以管理；难调试；难测试；</li>
<li>如果写了不好的存储过程，会对数据库性能产生很大的影响；</li>
</ol>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>吞吐量高</li>
</ol>
<h4 id="分区下的串行"><a href="#分区下的串行" class="headerlink" title="分区下的串行"></a>分区下的串行</h4><p>需要对所有分区加锁。如果有多个二级索引，性能会很差。</p>
<h4 id="串行小结"><a href="#串行小结" class="headerlink" title="串行小结"></a>串行小结</h4><p>在特定约束条件下，真的串行执行事务，已经成为一种实现可序列化隔离等级的可行办法。</p>
<ol>
<li>每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。</li>
<li>仅限于活跃数据集可以放入内存的情况。很少访问的数据可能会被移动到磁盘，但如果需要在单线程执行的事务中访问，系统就会变得非常慢^x。</li>
<li>写入吞吐量必须低到能在单个CPU核上处理，如若不然，事务需要能划分至单个分区，且不需要跨分区协调。</li>
<li>跨分区事务是可能的，但是它们的使用程度有很大的限制。</li>
</ol>
<h3 id="两阶段加锁2PL"><a href="#两阶段加锁2PL" class="headerlink" title="两阶段加锁2PL"></a>两阶段加锁2PL</h3><p>不是分布式中的两阶段提交2PC。</p>
<p>对象只要有写入（修改或删除），就需要独占访问（exclusive access） 权限：</p>
<ol>
<li>如果事务A读取了一个对象，并且事务B想要写入该对象，那么B必须等到A提交或中止才能继续。 （这确保B不能在A底下意外地改变对象。）</li>
<li>如果事务A写入了一个对象，并且事务B想要读取该对象，则B必须等到A提交或中止才能继续。 （读取旧版本的对象在2PL下是不会出现的。）</li>
</ol>
<p>在2PL中，写入不仅会阻塞其他写入，也会阻塞读，反之亦然。</p>
<p>而快照隔离使得读不阻塞写，写也不阻塞读。</p>
<h4 id="实现2PL"><a href="#实现2PL" class="headerlink" title="实现2PL"></a>实现2PL</h4><p>每个对象有一个读写锁来隔离写操作。</p>
<p>2PL用于MySQL（InnoDB）和SQL Server中的可序列化隔离级别，以及DB2中的可重复读隔离级别。</p>
<p>读与写的阻塞是通过为数据库中每个对象添加锁来实现的。锁可以处于共享模式（shared mode）或独占模式（exclusive mode）</p>
<p>锁规则：</p>
<ol>
<li>若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。</li>
<li>若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果对象上存在任何锁，该事务必须等待。</li>
<li>如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得排他锁相同。</li>
<li>事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是“两阶段”这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。</li>
</ol>
<p>由于使用了这么多锁，所以很容易发生事务A被卡住等待事务B释放它的锁，反之亦然。这种情况称为死锁。数据库自动检测死锁之后会终止事务，然后重启事务排队。</p>
<h4 id="2PL性能"><a href="#2PL性能" class="headerlink" title="2PL性能"></a>2PL性能</h4><p>缺点，性能差（吞吐量低，响应时间不确定）。</p>
<h4 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h4><p>会议室预定例子。查询所有会议室，和update/insert会议室预定。</p>
<p>锁定一个范围的查询对象。</p>
<h4 id="索引区间锁"><a href="#索引区间锁" class="headerlink" title="索引区间锁"></a>索引区间锁</h4><p>谓词锁性能不佳：如果活跃事务持有很多锁，检查匹配的锁会非常耗时。因此，大多数使用2PL的数据库实际上实现了索引范围锁（也称为间隙锁（next-key locking）），这是一个简化的近似版谓词锁。</p>
<h3 id="可串行化的快照隔离（SSI）"><a href="#可串行化的快照隔离（SSI）" class="headerlink" title="可串行化的快照隔离（SSI）"></a>可串行化的快照隔离（SSI）</h3><p>性能不好（2PL）或者扩展性不好（串行执行）的可序列化隔离级别。</p>
<p>更好的选择，一个称为可序列化快照隔离（SSI, serializable snapshot isolation） 的算法是非常有前途的。</p>
<h4 id="悲观与乐观的并发控制"><a href="#悲观与乐观的并发控制" class="headerlink" title="悲观与乐观的并发控制"></a>悲观与乐观的并发控制</h4><p><strong>2PL是悲观机制</strong>，如果有竞争可能出错，那么等到安全之后再做。像多线程编程种的互斥。串行执行可以称为悲观到了极致。</p>
<p>相比之下，<strong>序列化快照隔离</strong>是一种乐观（optimistic） 的并发控制技术。如果可能发生冲突，那么先继续执行，等到提交时候，数据库检查是否冲突。如果有冲突则中止，接下来重试。</p>
<p>如果事务之间竞争不大，乐观并发控制会比悲观控制高效很多。如果冲突很多，则性能不佳。</p>
<p>SSI，所有的读操作都是基于一致性快照。通过算法检测冲突，来决定是否中止事务。</p>
<h4 id="需要考虑的冲突情况"><a href="#需要考虑的冲突情况" class="headerlink" title="需要考虑的冲突情况"></a>需要考虑的冲突情况</h4><h5 id="检测对旧MVCC对象版本的读取（读之前存在未提交的写入）"><a href="#检测对旧MVCC对象版本的读取（读之前存在未提交的写入）" class="headerlink" title="检测对旧MVCC对象版本的读取（读之前存在未提交的写入）"></a>检测对旧MVCC对象版本的读取（读之前存在未提交的写入）</h5><img src="/2019/06/12/DDIA-7-事务/检测事务何时从MVCC快照读取过时的值.png">
<p>在事务43想要提交时，事务42 已经提交。这意味着在读一致性快照时被忽略的写入已经生效，事务43 的前提不再为真。</p>
<p>为何在提交时才检查？为了高效支持长时间读事务的性能。</p>
<h5 id="检测影响先前读取的写入（读之后发生写入）"><a href="#检测影响先前读取的写入（读之后发生写入）" class="headerlink" title="检测影响先前读取的写入（读之后发生写入）"></a>检测影响先前读取的写入（读之后发生写入）</h5><img src="/2019/06/12/DDIA-7-事务/在可序列化快照隔离中，检测一个事务何时修改另一个事务的读取。.png">
<p>当事务写入数据库时，它必须在索引中查找最近曾读取受影响数据的其他事务。这个过程类似于在受影响的键范围上获取写锁，但锁并不会阻塞事务到其他事务完成，而是像一个引线一样只是简单通知其他事务：你们读过的数据可能不是最新的啦。</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>对比2PL，串行。对于读密集的负载性能好。</p>
<p>事务中止的比例会影响SSI的性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/DDIA-6-数据分区/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/DDIA-6-数据分区/" itemprop="url">DDIA-6-数据分区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-12T08:46:30+08:00">
                2019-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据分区的主要目的—提高可扩展性。也就是应对增长的负载，把负载均匀的分布到各个机器/节点上。</p>
<h1 id="数据分区与数据复制"><a href="#数据分区与数据复制" class="headerlink" title="数据分区与数据复制"></a>数据分区与数据复制</h1><p>通常结合使用，也就是每个分区在多个节点都存有副本。</p>
<p>一个节点可能有一个或多个分区。每个分区都有自己的主副本。</p>
<img src="/2019/06/12/DDIA-6-数据分区/组合使用复制和分区：每个节点充当某些分区的领导者，其他分区充当追随者。.png">
<h1 id="Key-Value-数据分区"><a href="#Key-Value-数据分区" class="headerlink" title="Key-Value 数据分区"></a>Key-Value 数据分区</h1><p>如何决定哪些记录放在哪个节点上？</p>
<p>如果分区不均匀，那么会导致某些分区节点比其他分区承担更多的数据量的查询负载，成为<strong>倾斜</strong>。会导致分区效率下降。</p>
<p>避免热点的最简单的方法是将记录<strong>随机分配</strong>给各个节点。可以比较均匀的分布数据。但是有一个缺点，当读区特定数据时，无法知道保存在哪个节点，所以必须并发读所有节点。这可以改进。</p>
<h2 id="基于Key的区间分区"><a href="#基于Key的区间分区" class="headerlink" title="基于Key的区间分区"></a>基于Key的区间分区</h2><p>为每个分区指定一块连续的key范围，就像百科全书一样。</p>
<img src="/2019/06/12/DDIA-6-数据分区/印刷版百科全书按照关键字范围进行分区.png">
<p>Bigtable使用了这种分区策略，以及其开源等价物HBase。</p>
<ul>
<li>优点，每个分区可以按照key排序（类似SSTables和LSM-Trees），可以轻松支持区间查询。</li>
<li>缺点，某些访问模式会导致热点。</li>
</ul>
<h2 id="基于关键字哈希值分区"><a href="#基于关键字哈希值分区" class="headerlink" title="基于关键字哈希值分区"></a>基于关键字哈希值分区</h2><p>用来解决数据倾斜和热点问题。</p>
<p>哈希函数的选择，不能使用内置的哈希函数，例如Java的Object.hashCode,同一个Key的返回值可能在不同的进程中不一样。</p>
<p>每一个分区是一个哈希范围。</p>
<img src="/2019/06/12/DDIA-6-数据分区/基于关键字的哈希值进行分区.png">
<p>分区的边界可以是均匀的，也可也是伪随机选择（一致性哈希）。</p>
<p><strong>缺点</strong>，丧失了良好的分区查询特性。在MongoDB中，如果使用了哈希分片模式，则区间查询会发送到所有的分区上。</p>
<p>Cassandra在两种分区策略中做了折中。使用了主key哈希，其他列区间的方式。可以支持在其他列上的高效区间查询。</p>
<p><strong>一致性哈希</strong><br>是一种平均分配负载的方法，最初用于CDN，描述了重新平衡的特定方法。正如我们将在“重新平衡分区”中所看到的，这种特殊的方法对于数据库实际上并不是很好，所以在实际中很少使用。</p>
<p><strong>组合索引</strong> 例如社交网络的（user_id, update_timestamp）。可以高效的检索一个用户在一段时间的所有更新，按照时间戳排序。</p>
<h2 id="负载倾斜与消除热点"><a href="#负载倾斜与消除热点" class="headerlink" title="负载倾斜与消除热点"></a>负载倾斜与消除热点</h2><p>基于哈希的分区方法可以减轻热点，但是无法完全避免。极端情况就是所有的读写操作都是针对同一个key。社交网络上的名人有几千万粉丝的例子。</p>
<p>解决方法：应用层来减轻倾斜程度。</p>
<ul>
<li><strong>写入</strong> 例如如果某个关键字被确定为热点，就在关键字开头或者结尾加一个随机数。这样只需要一个两位数的十进制数就可以把关键字分不到100个不同的关键字上。</li>
<li><strong>读取</strong> 需要从所有100个关键字中读取数据然后进行合并。</li>
</ul>
<p>因此只有对少量关键字附加随机数才有意义。需要额外的元数据来标记哪些关键字进行了特殊处理。</p>
<h1 id="分区与二级索引"><a href="#分区与二级索引" class="headerlink" title="分区与二级索引"></a>分区与二级索引</h1><p>二级索引，情况变得复杂。不能唯一表识一个记录，而是用来做特定值的查询。例如红色的车，包含hogwash的文章。</p>
<h2 id="基于文档分区的二级索引"><a href="#基于文档分区的二级索引" class="headerlink" title="基于文档分区的二级索引"></a>基于文档分区的二级索引</h2><p>也称为本地索引。每个分区有自己的索引。</p>
<p>搜索时候，需要将查询发送到所有的问去，然后合并所有的返回结果。这种方法也叫做分散/聚集。查询代价高昂。</p>
<p>尽管如此，它还是广泛用于实践：MongoDB，Riak，Cassandra，ElasticSearch，SolrCloud，VoltDB。。。</p>
<img src="/2019/06/12/DDIA-6-数据分区/按文档分区二级索引.png">
<h2 id="基于词条的二级索引分区"><a href="#基于词条的二级索引分区" class="headerlink" title="基于词条的二级索引分区"></a>基于词条的二级索引分区</h2><p>构建全局索引。全局索引也必须进行分区。可以与数据关键字采用不同的分区策略。</p>
<p>读取更为高效。不需要分散/聚集。</p>
<p>写入较慢且非常复杂。更新单个文档时，需要涉及到多个二级索引，写放大。所以，现有数据库都不支持同步更新二级索引。</p>
<p>实践中，二级索引的更新都是异步的。</p>
<img src="/2019/06/12/DDIA-6-数据分区/按关键词对二级索引进行分区.png">
<h1 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h1><p>应对数据库的变化，例如：</p>
<ol>
<li>查询压力增加，需要更多的CPU处理负载。</li>
<li>数据规模增加，需要更多的磁盘和内存。</li>
<li>节点故障，需要其他机器接管失效节点。</li>
</ol>
<p>以上这些变化都要求数据和请求从一个节点转移到另一个节点。这样一个迁移负载的过程成为再平衡。</p>
<p>再平衡的目标：</p>
<ol>
<li>平衡后，负载，存储，读写请求等应该更均匀。</li>
<li>再平衡过程中，可以正常的读写。</li>
<li>避免不必要的负载迁移，尽量减少网络和磁盘IO影响。</li>
</ol>
<h2 id="再平衡策略"><a href="#再平衡策略" class="headerlink" title="再平衡策略"></a>再平衡策略</h2><h3 id="坏方法：取模-mod-N"><a href="#坏方法：取模-mod-N" class="headerlink" title="坏方法：取模 mod N"></a>坏方法：取模 mod N</h3><p>如果N变化，就会产生迁移。频繁的迁移增加了再平衡的成本。</p>
<h3 id="简单的解决方法：固定数量分区"><a href="#简单的解决方法：固定数量分区" class="headerlink" title="简单的解决方法：固定数量分区"></a>简单的解决方法：固定数量分区</h3><ol>
<li>首先，创建远超过实际节点数的分区。然后为每个节点分配多个分区。</li>
<li>接下来，如果集群中添加了新节点，就从现有节点中匀走几个给新节点，直到分区再次达到全局平衡。</li>
<li>如果删除节点，则执行相反的措施。</li>
</ol>
<img src="/2019/06/12/DDIA-6-数据分区/将新节点添加到每个节点具有多个分区的数据库群集.png">
<p>迁移过程中，总分区数不变。也不会改变关键字到分区的映射关系。</p>
<p>需要调整的是，分区与节点的对应关系。</p>
<p>分区大小应该恰到好处。</p>
<h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><p>HBase和RethinkDB等采用了动态创建分区的策略。当分区数据增长超过一个可配置的阀值，就将它拆分为两个分区，每个承担一半的数据量。反过来也是。</p>
<p>动态分区不仅适用于关键字区间分区，也适用于基于哈希的分区策略。</p>
<h3 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h3><p>每个节点具有固定数量的分区。Cassandra和Ketama采用了这种方式。</p>
<p>当节点数不变时，每个分区的大小与数据集大小保持正比的增长关系。当节点数增加时，分区则会调整的更小。</p>
<p>新节点加入集群时，会随机选择固定数量的现有分区进行分裂，然后拿走这额分区一半的数据量。</p>
<p>随机选择分区边界，前提是要求采用基于哈希的分区。这也符合一致性哈希。</p>
<h2 id="自动与手动再平衡"><a href="#自动与手动再平衡" class="headerlink" title="自动与手动再平衡"></a>自动与手动再平衡</h2><p>推荐手动，避免意外发生。</p>
<h1 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h1><p>客户端请求时，如何直到应该链接哪个节点？</p>
<p>属于服务发现的问题。任何通过网络访问的系统都有这样的要求，尤其是当服务目标支持高可用时。</p>
<p><strong>处理策略</strong>：</p>
<ol>
<li>允许客户端链接任意的节点。如果请求的节点能满足客户端查询，则返回，否则转发到下一个合适的节点。</li>
<li>客户端的请求都发送到一个路由层，路由层来转发请求到可以处理的节点。</li>
<li>客户端感知分区和节点的关系，直接连接到目标节点。</li>
</ol>
<img src="/2019/06/12/DDIA-6-数据分区/将请求路由到正确节点的三种不同方式.png">
<p>如何应对变化？很多分布式系统依赖一个独立的协调服务（如ZooKeeper），跟踪集群范围内的元数据。每个节点都向Zookeeper中注册自己，ZooKeeper维护了分区到节点的映射。客户端或者路由层订阅这个映射，当有改变时，会通知订阅者更改。</p>
<img src="/2019/06/12/DDIA-6-数据分区/使用ZooKeeper跟踪分区分配给节点.png">
<p>​<br>Cassandra和Riak采取不同的方法：他们在节点之间使用流言协议（gossip protocol） 来传播群集状态的变化。请求可以发送到任意节点，该节点会转发到包含所请求的分区的适当节点（处理策略的方法1）。这个模型在数据库节点中增加了更多的复杂性，但是避免了对像ZooKeeper这样的外部协调服务的依赖。</p>
<h2 id="执行并行查询"><a href="#执行并行查询" class="headerlink" title="执行并行查询"></a>执行并行查询</h2><p>目前只关注了读写单个关键字的建大查询，大多数是<strong>NoSQL</strong>分布式数据存储所支持的访问类型。</p>
<p>然而，通常用于分析的大规模并行处理（MPP, Massively parallel processing） <strong>关系型数据库</strong>产品在其支持的查询类型方面要复杂得多。一个典型的数据仓库查询包含多个连接，过滤，分组和聚合操作。 MPP查询优化器将这个复杂的查询分解成许多执行阶段和分区，其中许多可以在数据库集群的不同节点上并行执行。涉及扫描大规模数据集的查询特别受益于这种并行执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/DDIA-5-数据复制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/DDIA-5-数据复制/" itemprop="url">DDIA-5-数据复制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T09:19:53+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式数据系统"><a href="#分布式数据系统" class="headerlink" title="分布式数据系统"></a>分布式数据系统</h1><h2 id="分布式数据系统的设计目的"><a href="#分布式数据系统的设计目的" class="headerlink" title="分布式数据系统的设计目的"></a>分布式数据系统的设计目的</h2><ol>
<li>扩展性，当数据量或者读写负载增长的时候，如何分散到多台机器上</li>
<li>容错与高可用性， 当单机出现故障，如何可以让系统继续工作。</li>
<li>延迟考虑，就近为用户选择数据中心来提供服务。</li>
</ol>
<h2 id="系统扩展的方式和考虑的问题"><a href="#系统扩展的方式和考虑的问题" class="headerlink" title="系统扩展的方式和考虑的问题"></a>系统扩展的方式和考虑的问题</h2><h3 id="系统的扩展能力"><a href="#系统的扩展能力" class="headerlink" title="系统的扩展能力"></a>系统的扩展能力</h3><p>水平扩展和垂直扩展。共享内存架构与共享磁盘架构。成本问题。资源竞争问题。</p>
<h3 id="无共享结构"><a href="#无共享结构" class="headerlink" title="无共享结构"></a>无共享结构</h3><p>通过网络互联的节点，通过软件实现核心逻辑，提供统一的服务。<br>性价比高。<br>可以做到性能更强大。</p>
<h3 id="复制与分区"><a href="#复制与分区" class="headerlink" title="复制与分区"></a>复制与分区</h3><p>将数据分布在各个节点上的方法。分区和复制。</p>
<h1 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h1><p>能够在多台机器上存储相同的数据副本。达到以下目的：</p>
<ul>
<li>低延迟访问</li>
<li>高可用性</li>
<li>提高吞吐量</li>
</ul>
<p>本章假设是数据规模比较小，一份数据拷贝可以完整的保存在一个机器中。分布式数据库成为主流也是最近发生的事情。</p>
<h2 id="主节点和从节点，主从架构"><a href="#主节点和从节点，主从架构" class="headerlink" title="主节点和从节点，主从架构"></a>主节点和从节点，主从架构</h2><p>一个节点负责写入，其他节点负责读。写入节点负责更新所有的从属节点。</p>
<h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><ol>
<li>指定一个副本为主，程序中对数据库所有的写操作都发送到这个主节点，主节点把数据写入自己的数据库中。</li>
<li>主节点写完自己的数据后，把对数据的更改作为log或者更改流发送给所有的从属副本。每个从属副本得到更新日志后，完成数据写入本地的操作。</li>
<li>客户端 读区数据时候，可以在任何节点上执行查询。但是只有主节点可以写。</li>
</ol>
<img src="/2019/05/20/DDIA-5-数据复制/主从复制系统.png">
<h3 id="具有主从复制功能的数据库"><a href="#具有主从复制功能的数据库" class="headerlink" title="具有主从复制功能的数据库"></a>具有主从复制功能的数据库</h3><p>关系型，PostgresSQL, MySQL, Oracle Data Guard, SQL Server。<br>非关系型，MongoDB， RethinkDB和Expresso。<br>分布式消息队列，Kafka，RabbitMQ</p>
<h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><p>这是复制中非常重要的一个设计选项。对于关系型数据库，同步和异步是可以可配置的。而其他系统，只能hardcode一个选择。</p>
<img src="/2019/05/20/DDIA-5-数据复制/主从复制，一个同步节点，一个异步节点.png">
<ul>
<li>节点1是同步，主节点需要等节点1写完之后才能向客户端确认</li>
<li>节点2是异步，主节点不需要等节点2给出完成写入的信息，就可以向客户端确认。</li>
</ul>
<p>同步复制从节点的优点，从节点一直保留着最新的数据copy。如果主节点出现故障，从节点可以继续提供访问最新数据的能力。<br>缺点，如果同步节点无法确认，无论是网络原因还是其他原因，写入总会失败。主节点需要阻塞所有的写入操作直到从节点完成响应。</p>
<p>最佳配置是，一个同步节点，剩下的都是异步节点。这种配置也叫半同步。</p>
<p>达到极限吞吐量，就是全异步节点。但是无法保证持久化。有点是，无论从属节点怎么落后，都可以继续响应写入。<br>异步模式听起来不靠谱，但是还是被广泛使用，特别是那些从节点数量巨大或者分布地理环境特别广的情况。需要解决<strong>复制滞后问题</strong>。</p>
<h3 id="增配新的从节点"><a href="#增配新的从节点" class="headerlink" title="增配新的从节点"></a>增配新的从节点</h3><p>如何加一个新的从节点？</p>
<p>简单的把数据文件拷贝是不够的，因为客户端有可能在复制的时候继续更新原来的数据。<br>锁定数据库，使其不可写，直到复制完成，会影响可用性。</p>
<p>解决方案操作步骤：</p>
<ol>
<li>主节点在某个时间点生成快照文件。</li>
<li>把快照文件拷贝给新的从节点。</li>
<li>从节点连接到主节点，请求快照之后的更新日志。</li>
<li>从节点在快照文件的基础上执行这些更新日志，成为<strong>趋赶</strong>。接下来可以继续处理主节点的更新变化。并重复1到4.</li>
</ol>
<h3 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h3><h4 id="从节点失效：追赶式恢复"><a href="#从节点失效：追赶式恢复" class="headerlink" title="从节点失效：追赶式恢复"></a>从节点失效：追赶式恢复</h4><p>请求故障前最后一个事务滞后所有的更改，并且趋赶。</p>
<h4 id="主节点失效：节点切换"><a href="#主节点失效：节点切换" class="headerlink" title="主节点失效：节点切换"></a>主节点失效：节点切换</h4><p>需要把某个从节点升级成主节点。可以手动，可以自动。</p>
<p>自动切换步骤：</p>
<ol>
<li>确认主节点失效。基于超时的机制：节点间互发心跳。</li>
<li>选举新的主节点。选离主节点版本最新的节点，来最小化丢失数据的风险。</li>
<li>重新配置系统，使主节点生效。客户端需要把写请求发送给新的主节点。等原来的主节点上线时，要把它降级为从。</li>
</ol>
<h5 id="主节点切换时会遇到的问题"><a href="#主节点切换时会遇到的问题" class="headerlink" title="主节点切换时会遇到的问题"></a>主节点切换时会遇到的问题</h5><ol>
<li>异步复制的从节点，如果主节点挂掉之前，新的主节点并没有接收到最新的数据。这样当原来的主节点又上线后，需要处理写冲突的问题。通常的解决方案是原来主节点上没有完成复制数据丢弃掉。</li>
<li>丢弃数据的方案很危险。与主键分配有关，GitHub泄漏Private数据的例子。</li>
<li>两个节点都认为自己是主，称为脑裂。很危险，两个节点都接受写的请求，没有很好解决冲突的方法。可能需要强制关闭其中一个节点。</li>
<li>需要选择一个合适的超时时间来检测主节点失效。</li>
</ol>
<h3 id="复制日志的实现底层方式"><a href="#复制日志的实现底层方式" class="headerlink" title="复制日志的实现底层方式"></a>复制日志的实现底层方式</h3><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><p>执行SQL。有不适用的场景：</p>
<ol>
<li>非确定性函数语句，NOW（） RAND（）等</li>
<li>自增列问题</li>
<li>有副作用的语句（触发器，SP，自定函数）</li>
</ol>
<h4 id="基于预写日志（WAL）传输"><a href="#基于预写日志（WAL）传输" class="headerlink" title="基于预写日志（WAL）传输"></a>基于预写日志（WAL）传输</h4><p>存储引擎的磁盘数据结构。每个写操作都是追加写的方式写入日志：</p>
<ul>
<li>日志结构的存储引擎（SSTables，LSM-trees）。日志是存储方式</li>
<li>Btree的覆盖写结构，每次都会写WAL日志。</li>
</ul>
<p>不管哪种，都是日志。可以在另一个节点上构建copy。</p>
<p><strong>缺点</strong> 日志描述的数据结构非常底层，与存储引擎紧密耦合。数据库升级如果存储格式改版，可能会有问题。<br>复制协议必须要求版本严格一致，升级就必须停机。</p>
<h4 id="基于行的逻辑日志复制"><a href="#基于行的逻辑日志复制" class="headerlink" title="基于行的逻辑日志复制"></a>基于行的逻辑日志复制</h4><p>与存储引擎采用不同的日志格式。</p>
<ol>
<li>对于行插入，日志记录相关列的新值</li>
<li>对于行删除，日志表识这一行被删除</li>
<li>对于行更新，日志记录所有列的的新值</li>
</ol>
<p>事务执行时影响到多行，会产生多个这样的日志记录，最后是一个commit日志。MySQL的binlog使用该方式。</p>
<p>这样的逻辑日志，容易向后兼容。</p>
<h4 id="基于触发器的复制"><a href="#基于触发器的复制" class="headerlink" title="基于触发器的复制"></a>基于触发器的复制</h4><p><strong>优点</strong>高度灵活，<br>触发器执行自己写的应用代码，将数据的更改记录到一个单独的表中，然后外部逻辑处理这个表，完成自定义的逻辑，例如复制到另一个系统。<br><strong>缺点</strong>开销更高</p>
<h2 id="复制滞后问题"><a href="#复制滞后问题" class="headerlink" title="复制滞后问题"></a>复制滞后问题</h2><p>主从结构的复制，对于读操作密集的应用，如Web，是一个不错的选择。可以创建多个副本，来让读请求分配到就近的节点。</p>
<p>这种体系下的扩展，只需要添加更多的从副本，就可以提高服务器的吞吐量。但这种扩展一定是<strong>异步复制</strong>。这样会有复制滞后的问题。</p>
<p>这种不一致是一个暂时状态，但是并没有保证多长时间内会一致。也叫最终一致性（eventually consistency）。</p>
<h3 id="读自己的写"><a href="#读自己的写" class="headerlink" title="读自己的写"></a>读自己的写</h3><p>用户自己的刚刚提交的数据，返回提交成功，但刷新页面后又看不到数据。可能是因为第二次读，是读到了一个没有最新数据的节点。</p>
<img src="/2019/05/20/DDIA-5-数据复制/用户写入后从旧副本中读取数据。需要写后读(read-after-write)的一致性来防止这种异常.png">
<p>我们需要<strong>写后读一致性</strong></p>
<p>基于一些业务场景的方案：</p>
<ol>
<li>用户修改自己的资料场景。读用户<strong>可能已经修改过</strong>的内容时，都从主库读。别人无法修改这份数据，只有一个客户端会修改时，需要客户端配合记录修改的操作。</li>
<li>如果这份数据可以被多个人修改，上面的方法就不行了。需要用其他的标准来决定是否去主库读。例如可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。还可以监控从库的复制延迟，防止任向任何滞后超过一分钟到底从库发出查询。</li>
<li>客户端可以记住最近一次写入的时间戳，服务器检查这个时间戳和从库的同步时间比较。来验证数据是否有效。</li>
<li>如果副本分布在多个数据中心，则需要一个中心路由判断。</li>
</ol>
<p>多客户端时会变得更复杂。需要跨设备的读写一致性。</p>
<p>其他问题：</p>
<ul>
<li>记住用户上次更新时间戳的方法变得更加困难。元数据需要一个中心存储。</li>
<li>如很难保证来自不同设备的连接会路由到同一数据中心</li>
</ul>
<h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><p>读到新值后，之后不再会读到旧值。</p>
<p>看到新的评论刷新后又消失的例子。</p>
<img src="/2019/05/20/DDIA-5-数据复制/用户首先从新副本读取，然后从旧副本读取。时光倒流。为了防止这种异常，我们需要单调的读取。.png">
<p>确保每个用户总是固定的从一个副本中读数据。不要随记路由。</p>
<p>需要解决节点失效的影响。</p>
<h3 id="前缀一致读"><a href="#前缀一致读" class="headerlink" title="前缀一致读"></a>前缀一致读</h3><p>聊天记录的复制问题。对话，问答的happen before逻辑，需要在复制时候解决。不要乱序</p>
<img src="/2019/05/20/DDIA-5-数据复制/如果某些分区的复制速度慢于其他分区，那么观察者在看到问题之前可能会看到答案。.png">
<p>这个是分区数据库的一个特殊问题，需要<strong>前缀一致读</strong></p>
<p>一个解决方案时确保有因果关系的数据写入都交给一个分区解决。但是会影响效率。也有新的算法来解决逻辑先后问题。</p>
<h3 id="复制滞后的解决方案"><a href="#复制滞后的解决方案" class="headerlink" title="复制滞后的解决方案"></a>复制滞后的解决方案</h3><p>当需要对写后读等问题支持的时候，一定要小心同步复制和异步复制的配置问题，与系统设计时的思考一致，不然会出大问题。</p>
<p>应用层可以解决滞后问题，但是代价是更复杂更容易出错。</p>
<p>分布式事务，有人断言，最终一致性是分布式系统最终的选择。</p>
<h2 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h2><p>适用多数据中心的架构，如果是一般的单数据中心，还是主从好，因为简单不容易出错。</p>
<p>主从问题就是主节点网络中断后，写入操作都会出问题。</p>
<p>多主结构，就是有多个主节点接收写操作。数据中心之间的复制，由各自主节点之间通信，而数据中心内部的复制，由其中的主节点，复制到其他的从节点。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><h4 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h4><p>多领导者配置中可以在每个数据中心都有主库。 图中展示了这个架构的样子。 在每个数据中心内使用常规的主从复制；在数据中心之间，每个数据中心的主库都会将其更改复制到其他数据中心的主库中。</p>
<img src="/2019/05/20/DDIA-5-数据复制/跨多个数据中心的多主复制.png">
<p>单主，多主复制之间的差异：</p>
<ol>
<li>性能。<br>主从架构会影响写入延迟。多主结构，对于本地数据中心可以快速响应，然后用异步复制，复制到其他数据中心。</li>
<li>容忍数据中心失效<br>多主更好。没有切换操作。</li>
<li>容忍网络问题<br>多主更好。</li>
</ol>
<h6 id="商业数据库支持"><a href="#商业数据库支持" class="headerlink" title="商业数据库支持"></a>商业数据库支持</h6><p>多主复制MySQL的Tungsten Repliactor，PostgreSQL的BDR，Orcale的GoldenGate。</p>
<h5 id="多主的缺点"><a href="#多主的缺点" class="headerlink" title="多主的缺点"></a>多主的缺点</h5><p>必须处理写入冲突。</p>
<p>由于多主复制都是现在数据库中新增的高级功能，有些交互，触发器函数，自增主键等会有副作用。有些人认为多主很危险，应该尽量避免。</p>
<h4 id="离线客户端操作"><a href="#离线客户端操作" class="headerlink" title="离线客户端操作"></a>离线客户端操作</h4><p>例如日历，Todo，会议安排等。每一个设备都是一个充当主节点的本地数据库。当设备再次上线时候，需要与服务器同步。</p>
<p>CouchDB就是为这种操作模式设计的。</p>
<h4 id="协作编辑"><a href="#协作编辑" class="headerlink" title="协作编辑"></a>协作编辑</h4><p>Google Docs。</p>
<p>可编辑力度非常小，也会有多主复制的挑战—写入冲突。</p>
<h3 id="处理写冲突（多主）"><a href="#处理写冲突（多主）" class="headerlink" title="处理写冲突（多主）"></a>处理写冲突（多主）</h3><p>解决多主复制的最大问题。例子，多人编辑Wiki。</p>

<h4 id="同步与异步冲突检测"><a href="#同步与异步冲突检测" class="headerlink" title="同步与异步冲突检测"></a>同步与异步冲突检测</h4><p>简单的允许多主节点并行接受写请求，会产生冲突问题。</p>
<p>同步方式，需要所有主节点确认写入后才能返回，失去了多主节点的优势，退化成了单主结构。</p>
<h4 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h4><ul>
<li>总是把特定用户的更新请求路由到特定的数据中心。基本等价于主从模型</li>
<li>问题在于，如果某个数据中心故障，之前的配置需要被修改到可用的数据中心时，会有问题。无法避免冲突。</li>
</ul>
<h4 id="收敛于一致状态"><a href="#收敛于一致状态" class="headerlink" title="收敛于一致状态"></a>收敛于一致状态</h4><ul>
<li>给每个写入分配一个类似UUID的东西，选最高的ID为胜者。缺点，数据丢失。</li>
<li>为每个副本分配一个UUID，预先制定副本之间的优先级。缺点，数据丢失。</li>
<li>合并冲突数据。</li>
<li>保留冲突信息，给应用层解决。（时候解决冲突，可能需要提示用户）</li>
</ul>
<h4 id="自定义冲突解决逻辑"><a href="#自定义冲突解决逻辑" class="headerlink" title="自定义冲突解决逻辑"></a>自定义冲突解决逻辑</h4><p>最适合的方式可能还是<strong>应用层程序</strong>来解决冲突。</p>
<p>在写入和读时执行冲突解决代码的逻辑：</p>
<ul>
<li>写时执行<br>只要数据库系统在执行复制的change日志时，监测到冲突，就调用应用层的冲突解决程序。<br>Bucardo支持写Perl。这个解决方法通常只能后台运行。</li>
<li>读时执行<br>发现冲突时，把所有的冲突值都暂存起来。下一次读时，把这些值一并返回给应用层。让用户来处理。<br>CouchDB采用这样的处理方式。</li>
</ul>
<h4 id="冲突的定义"><a href="#冲突的定义" class="headerlink" title="冲突的定义"></a>冲突的定义</h4><p>根据业务场景区分。有些显而易见，例如两个人同时修改一个record的某一列。有些不是这么直接，例如会议室预定系统，或者有限商品的秒杀系统。</p>
<h4 id="自动冲突解决"><a href="#自动冲突解决" class="headerlink" title="自动冲突解决"></a>自动冲突解决</h4><p>冲突解决规则可能越来越复杂，而且自定义代码很容易出错。</p>
<p>一些方法：</p>
<ol>
<li>CRDT（conflict-free replicated datatypes），map orderedlist counter，可以用内置的方式自动解决。</li>
<li>使用可合并的数据结构。类似git的合并。</li>
<li>操作转换（operational transformation）是Google Docs等背后的解决方法。专门为可同时编辑的有序表设计。</li>
</ol>
<h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><p>三种多主的复制拓扑结构</p>
<img src="/2019/05/20/DDIA-5-数据复制/三个可以设置多领导者复制的示例拓扑.png">
<p>环形为防止无限循环，每个节点需要一个UUID，复制的时候带上已经完成过的节点ID。</p>
<p>星型和环形的问题，是节点故障。修复之前会影响其他节点。</p>
<p>全链路问题，某些链路快，某些慢，会导致复制日志覆盖，产生类似前缀一致读的问题。</p>
<img src="/2019/05/20/DDIA-5-数据复制/使用多主程序复制时，可能会在某些副本中写入错误的顺序。.png">
<h2 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h2><p>设计思路：放弃使用主节点，允许任何副本直接处理写请求。</p>
<p>这类数据库也被称为Dynamo风格数据库（不是AWS的那个，AWS的DynamoDB是单主架构）。</p>
<p>在一些无领导者的实现中，客户端直接将写入发送到到几个副本中，而另一些情况下，一个<strong>协调者（coordinator）</strong>节点代表客户端进行写入。但与主库数据库不同，协调者不执行特定的写入顺序。我们将会看到，这种设计上的差异对数据库的使用方式有着深远的影响。</p>
<h3 id="节点失效时写入数据库"><a href="#节点失效时写入数据库" class="headerlink" title="节点失效时写入数据库"></a>节点失效时写入数据库</h3><p>核心思想，并发读多个副本，使读到最新数据的概率达到最高。</p>

<h4 id="读修复与反熵"><a href="#读修复与反熵" class="headerlink" title="读修复与反熵"></a>读修复与反熵</h4><ul>
<li>读修复。并行读多个副本时，可以检测到过期的返回值。适合被频繁读取的场景。</li>
<li>反熵。后台进程不断查找副本之间的差异，完成更新。</li>
</ul>
<p>​并不是所有的系统都实现了这两个;例如，Voldemort目前没有反熵过程。请注意，如果没有反熵过程，某些副本中很少读取的值可能会丢失，从而降低了持久性，因为只有在应用程序读取值时才执行读修复。</p>
<h4 id="读写quorum（法定人数）"><a href="#读写quorum（法定人数）" class="headerlink" title="读写quorum（法定人数）"></a>读写quorum（法定人数）</h4><p>w + r &gt; n</p>
<p>写至少需要确认w个节点，读必须读到r个节点，n是副本总数。</p>
<p>通常w=r=（n+1）/ 2，也可以灵活配置。例如读多写少的情况，可以配置w=n，r=1.但是更容易写入失败。</p>
<p>仲裁条件定义了可以容忍的失效节点个数。</p>
<h4 id="Quorum一致性的局限性"><a href="#Quorum一致性的局限性" class="headerlink" title="Quorum一致性的局限性"></a>Quorum一致性的局限性</h4><p>关键在于读写有重叠。即使在w+r》n的情况下，也存在返回旧值的边界条件。主要取决于现实情况：</p>
<ol>
<li>如果采用了sloppy quorum</li>
<li>并发写冲突时候，需要根据时间戳挑选胜者，如果时钟偏差，会造成数据丢失。</li>
<li>读写同时发生，写操作可能只完成了一半节点，返回新旧值有不确定性。</li>
<li>如果写入失败，已经成功的节点不会回滚。会读到新值。</li>
<li>其他边界情况</li>
</ol>
<p>无法得到复制滞后问题的一致性保证。</p>
<h5 id="监控旧值"><a href="#监控旧值" class="headerlink" title="监控旧值"></a>监控旧值</h5><p>​<br>从运维的角度来看，监视你的数据库是否返回最新的结果是很重要的。</p>
<h5 id="sloppy-quorum与数据回传"><a href="#sloppy-quorum与数据回传" class="headerlink" title="sloppy quorum与数据回传"></a>sloppy quorum与数据回传</h5><ul>
<li>容错能力。网络中断，无法满足法定人数，会使系统无法读，</li>
<li>无法满足法定人数时的出错处理。是否把错误返回客户端，或者是否还接收写请求。</li>
<li>放松仲裁方案允许不满足法定人数的写</li>
<li>一旦网络恢复，临时节点需要向原主节点完成数据传输（回传）。</li>
</ul>
<p>​在所有常见的Dynamo实现中，sloppy quorum是可选的。在Riak中，它们默认是启用的，而在Cassandra和Voldemort中它们默认是禁用的。</p>
<h5 id="多数据中心操作"><a href="#多数据中心操作" class="headerlink" title="多数据中心操作"></a>多数据中心操作</h5><p>n是所有数据中心的节点总数。配置时，可以指定每个数据中心各有多少副本。</p>
<p>Cassandra和Voldemort在正常的无主模型中实现了他们的多数据中心支持。客户端通常只等待来自其本地数据中心内的法定节点的确认。</p>
<p>Riak将客户端和数据库节点之间的所有通信保持在一个数据中心本地，因此n描述了一个数据中心内的副本数量。数据库集群之间的跨数据中心复制在后台异步发生，其风格类似于多领导者复制</p>
<h3 id="检测并发写"><a href="#检测并发写" class="headerlink" title="检测并发写"></a>检测并发写</h3><p>Dynamo风格的数据库允许多个客户端同时写入相同的Key，这意味着即使使用严格的法定人数也会发生冲突。<br>读修复或带数据回传时也可能会产生冲突。</p>
<img src="/2019/05/20/DDIA-5-数据复制/并发写入Dynamo风格的数据存储：没有明确定义的顺序.png">
<p>解决冲突：</p>
<h4 id="最后写入胜利（丢弃并发写入）"><a href="#最后写入胜利（丢弃并发写入）" class="headerlink" title="最后写入胜利（丢弃并发写入）"></a>最后写入胜利（丢弃并发写入）</h4><p>强制排序，例如时间戳，最大的获胜。是Cassandra唯一支持的冲突解决方法，也是Riak中的一个可选方案。</p>
<p>LWW（last write wins）缺点，牺牲数据永久性。<br>如果丢失数据不可接受，LWW是解决冲突的一个很烂的选择。</p>
<p>与LWW一起使用数据库的唯一安全方法是确保一个pk只写入一次，然后视为不可变，从而避免对同一个key进行并发更新。</p>
<h4 id="Happens-before关系和并发"><a href="#Happens-before关系和并发" class="headerlink" title="Happens-before关系和并发"></a>Happens-before关系和并发</h4><p>需要一个算法判断两个操作是否并发。比如插入之后才会更新。</p>
<p><strong>确定先后关系</strong></p>
<p>购物车的例子。</p>
<img src="/2019/05/20/DDIA-5-数据复制/两个客户端同时编辑购物车.png">
<p>算法工作流程：</p>
<ol>
<li>服务器维护pk的版本号</li>
<li>客户端读时，返回所有的值的最新版本号。（写前必须读）</li>
<li>客户端写pk时，必须传入之前读的版本号，读到的值和新值合并后的集合。</li>
<li>服务端接收到特定版本的写入时，覆盖版本号。</li>
</ol>
<h4 id="合并同时写入的的值"><a href="#合并同时写入的的值" class="headerlink" title="合并同时写入的的值"></a>合并同时写入的的值</h4><p>购物车例子中，加入商品操作，可以合并，去掉重复值。</p>
<p>删除适用墓碑标记。</p>
<p>使用专门的数据结构，CRDT。支持高校合并，删除标记。</p>
<h4 id="版本矢量"><a href="#版本矢量" class="headerlink" title="版本矢量"></a>版本矢量</h4><p>多副本没有主节点的购物车。</p>
<p>需要为每个一个副本和每个主键都定一个版本号。每个副本在处理写入时增加自己的版本号，并且跟踪从其他副本中看到的版本号。这个信息指出了要覆盖哪些值，以及保留哪些值作为兄弟。</p>
<p>所有副本的版本号合集成为版本矢量。也有虚线版本适量。</p>
<p>另外，就像在单个副本的例子中，应用程序可能需要合并兄弟副本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/DDIA-4-数据编码与演化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/DDIA-4-数据编码与演化/" itemprop="url">DDIA-4-数据编码与演化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T20:46:32+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应用程序在根据需求不断的变化时，往往会对其存储的数据有更改的情况。</p>
<p>当数据格式或者模式发生变化的时候，经常需要对应用程序的代码修改。对于一个大型程序，这并非容易。</p>
<ol>
<li>服务器应用需要滚动升级。这样部署新版本的时候，不需要停止服务。</li>
<li>客户端升级，只能寄希望于用户。很有可能用户永远不会升级。</li>
</ol>
<p>升级中需要考虑的亮点：</p>
<ol>
<li>向前兼容。新代码读老数据。（容易）</li>
<li>向后兼容。老代码读新数据。（难）</li>
</ol>
<h1 id="数据编码格式"><a href="#数据编码格式" class="headerlink" title="数据编码格式"></a>数据编码格式</h1><p>程序中的数据，至少有两种不同的表示形式</p>
<ol>
<li>内存中。</li>
<li>写入文件或者发送到网络中。</li>
</ol>
<p>两种形式之间的转换，成为序列化Serialize和反序列化Deserialize。或者编码Encode，解码Decode。</p>
<h2 id="语言特定的格式"><a href="#语言特定的格式" class="headerlink" title="语言特定的格式"></a>语言特定的格式</h2><p>比如Java中java.io.Serializable接口；Ruby的Marshal；Python的pickle等。</p>
<p>这类编码的问题：</p>
<ol>
<li>编码和语言绑定在一起，无法跨语言使用。</li>
<li>安全问题。远程执行任意代码。可以恢复成任意类，意味着Decode的过程中需要有能力创建任意的类。</li>
<li>向前向后兼容问题。</li>
<li>效率低。比如Java内置序列化。</li>
</ol>
<h2 id="JSON，XML与它们的二进制遍体"><a href="#JSON，XML与它们的二进制遍体" class="headerlink" title="JSON，XML与它们的二进制遍体"></a>JSON，XML与它们的二进制遍体</h2><p>XML被批评主要在于其冗长和不必要的复杂。JSON受欢迎主要是在Web浏览器中的原生支持。CSV格式简单，功能弱一些。</p>
<p>它们都是文本格式的，可读性强。但也有<strong>问题</strong>：</p>
<ol>
<li>数字编码有很多模糊的地方。XML和CSV中无法区分数字和数字组成的字符串；JSON不区分整数和浮点数，而且不指定精度。</li>
<li>对Unicode字符串支持好，但是不支持二进制数据。所以人们使用Base64将二进制数据编码成String来传递。</li>
<li>XML和JSON都有可选的模式支持。数据的正确性解释，取决于模式中的信息，</li>
<li>CSV没有任何模式，需要程序解释。</li>
</ol>
<h2 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h2><p>更紧凑更快的解析格式。可以节省空间和时间。在TB级别的数据时尤其关键。</p>
<h3 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h3><p>最最基础的二进制化JSON方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;userName&quot;: &quot;Martin&quot;,</span><br><span class="line">    &quot;favoriteNumber: 1337,</span><br><span class="line">    &quot;interests&quot;: [&quot;daydreaming&quot;, &quot;hacking&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/05/15/DDIA-4-数据编码与演化/一条JSON记录对应的MessagePack的二进制表示.png">
<p>上图的二进制的结构解读：</p>
<ol>
<li>第一个字节0x83，表示接下来是包含三个fields的对象（第四位0x03，高四位0x80）</li>
<li>第二字节0xa8，表示接下来的字符串，长度为八个字节</li>
<li>再往下的八个字节时ASCII的字段，userName</li>
<li>在接下来7个字节前缀0xa6表示后面有六个字节，Martin</li>
</ol>
<p>结论：<br>整体编码占用66个字节，比原始的JSON编码（81个）少一些，但是不明显。</p>
<p>下面的方案中只用32个字节就可以完成同样记录的二进制化。</p>
<h2 id="Thrift与Protocol-Buffers"><a href="#Thrift与Protocol-Buffers" class="headerlink" title="Thrift与Protocol Buffers"></a>Thrift与Protocol Buffers</h2><p>它们都是基于相同原理的二进制编码方式。都需要使用<strong>模式（Schema）</strong>来编码任意数据。</p>
<ul>
<li><p>使用Thrift的接口定义语言（IDL）来描述模式：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    1: required string       userName,</span><br><span class="line">    2: optional i64          favoriteNumber,</span><br><span class="line">    3: optional list&lt;string&gt; interests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Protocol Buffers的等效模式定义看起来非常相似：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    required string user_name       = 1;</span><br><span class="line">    optional int64  favorite_number = 2;</span><br><span class="line">    repeated string interests       = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Thrift和Protocol Buffers都有各自的代码生成工具，并支持各种编程语言。应用程序可以直接使用生成的代码完成Encode，Decode的工作。</p>
<h3 id="Thrift的BinaryProtocal与CompactProtocol"><a href="#Thrift的BinaryProtocal与CompactProtocol" class="headerlink" title="Thrift的BinaryProtocal与CompactProtocol"></a>Thrift的BinaryProtocal与CompactProtocol</h3><ul>
<li><p>BinaryProtocal</p>
<img src="/2019/05/15/DDIA-4-数据编码与演化/使用BinaryProtocol的编码例子.png">
<p>需要59个字节。</p>
</li>
</ul>
<ol>
<li>每个字段有一个类型注视（是字符串，整数，列表等），并可以指定长度（字符串长度，列表的count）</li>
<li>与MessagePack最大的区别是没有字段名。</li>
</ol>
<ul>
<li><p>CompactProtocol</p>
<img src="/2019/05/15/DDIA-4-数据编码与演化/使用CompactProtocol的编码例子.png">
<p>只需要34字节。</p>
</li>
</ul>
<ol>
<li>通过将字段类型和标签号打包在一个字节中。</li>
<li>使用可变长度整数。 1337，不用一个字节中的全部8位都表示数值。使用两个字节编码，每个字节的最高位表示是否还有更多字节。</li>
<li>可变长度整数意味着，-64到63的数字可以用一个字节表示，-8192到8191之间用两个字节。</li>
</ol>
<h3 id="Protocol-Buffer编码"><a href="#Protocol-Buffer编码" class="headerlink" title="Protocol Buffer编码"></a>Protocol Buffer编码</h3><p>只有一种编码模式。与CompactProtocol很类似。只用33个字节。</p>

<p>不同之处：</p>
<ol>
<li>表示字段位置和类型的一个压缩的字节中的位数分配不同</li>
<li>表示数字的填充方式不同。例如1337的表示一个是最左，一个是最右。</li>
<li>表示列表的方式不同，Thrift是有列表type，而protocol buffer是用重复的field tag来表示列表或者数组</li>
<li>没有end of struct</li>
</ol>
<p>一个细节，optional字段对于编码encode的结果没有任何影响（二进制中不会体现一个field是optional的）。optional的体现在于在Runtime 时后可以做检查，捕获错误。</p>
<h3 id="字段标签和模式演化"><a href="#字段标签和模式演化" class="headerlink" title="字段标签和模式演化"></a>字段标签和模式演化</h3><p>如何保证修改模型时候，既保证向前又保证向后兼容呢？</p>
<p>可以根据之前的例子看出，每个字段的标签号码（1，2，3等），与它的类型整合在一个字节中。由此看出field tag对编码数据的含义至关重要。</p>
<ol>
<li>不能随便改字段的标签，会导致现有的编码无效。保证这个原则，实现向后兼容。</li>
<li>可以添加新的字段，只需要用一个新的标签。如果老代码读到带有新标签的数据，那么会忽略。这样可以向前兼容。</li>
<li>新增字段不可以是required字段，或者没有默认值的字段，向后兼容。违反的结果，会让老数据无法被新代码读。</li>
<li>删除字段只可以删除可选字段，老代码读新数据时才不会出检查问题，向前兼容。</li>
</ol>
<h3 id="数据类型和模式演化"><a href="#数据类型和模式演化" class="headerlink" title="数据类型和模式演化"></a>数据类型和模式演化</h3><p>改变数据类型会如何？可能是可以做的，但是风险在于丢失精度或者数据截断。</p>
<ol>
<li>例如一个32位整数变成一个64位的整数。新代码可以读老数据，因为可以用0填充缺失的位。如果是老代码读64位的数据，使用32位int存，则会截断。</li>
<li>Protocol Buffer中没有数组或者列表。所以如果把单值的类型变成列表类型的，老代码读新数据，只会留下最后一个值。而新代码没什么问题。</li>
</ol>
<h2 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h2><p>另一种二进制编码格式。由于Thrift不适合Hadoop的用例，因此Avro在2009年作为Hadoop的子项目启动。</p>
<p>Avro也用<strong>模式</strong>来制定数据结构的编码。它有两种语言：一种是Avro IDL，用于人工编辑，一种是基于JSON的易于机器读。</p>
<p>基于Avro IDL的模式的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">record Person &#123;</span><br><span class="line">    string                userName;</span><br><span class="line">    union &#123; null, long &#125;  favoriteNumber = null;</span><br><span class="line">    array&lt;string&gt;         interests;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其等价JSON格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;record&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Person&quot;,</span><br><span class="line">    &quot;fields&quot;: [</span><br><span class="line">        &#123;&quot;name&quot;: &quot;userName&quot;, &quot;type&quot;: &quot;string&quot;&#125;,</span><br><span class="line">        &#123;&quot;name&quot;: &quot;favoriteNumber&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;long&quot;], &quot;default&quot;: null&#125;,</span><br><span class="line">        &#123;&quot;name&quot;: &quot;interests&quot;, &quot;type&quot;: &#123;&quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &quot;string&quot;&#125;</span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/05/15/DDIA-4-数据编码与演化/使用Avro编码的例子.png">
<p>主要区别：</p>
<ol>
<li>模式中没有标签号，是目前见过的所有编码中最紧凑的。</li>
<li>字节序列中也没有类型信息。只是连在一起的一些列值组成。字符串是长度加UTF-8的字节流，整数使用可变长度编码（与CompactProtocol相同）。但是并没有任何信息表示这些field是什么类型。</li>
</ol>
<p>如何解析？<br>需要预先读区模式信息的数据，然后按照模式的顺序，遍历这些字段。</p>
<p>然后直接用模式中的字段信息来决定每个field到底是什么类型。</p>
<p>这意味着，读取数据的代码，必须使用当时写入数据是使用的<strong>模式</strong>，才可以正确还原数据。如果中间有任何不匹配，都无法解析。</p>
<h3 id="Avro中的写模式和读模式"><a href="#Avro中的写模式和读模式" class="headerlink" title="Avro中的写模式和读模式"></a>Avro中的写模式和读模式</h3><ul>
<li>写模式。encode时，使用的模式，可以将这个模式编译在应用中。</li>
<li>读模式。decode时，应用代码依赖的模式，这个模式可能是在应用程序build过程中基于模式语言动态生成的。</li>
</ul>
<p><strong>Avro关键思想</strong> ，写模式和读模式不一定需要完全一样，只需要兼容。当数据被Decode的时候，Avro的 Library通过对比查看写模式和读模式之间的差异，把数据从写模式转换成读模式，然后继续decode。Avro规范定义了这种解决方法的工作原理。</p>
<p>假如写模式和读模式的字段顺序不同，也没有关系，如果读的过程中遇到了只有在写模式中出现的字段，那可以忽略。如果在一个字段只在读模式中有，那么可以填充默认值。</p>
<h3 id="Avro模式演化"><a href="#Avro模式演化" class="headerlink" title="Avro模式演化"></a>Avro模式演化</h3><ol>
<li>只能添加或删除有默认值的字段。</li>
<li>如果添加一个没有默认值的字段，破坏了向后兼容性</li>
<li>如果删除一个没有默认值的字段，破坏了向前兼容性。</li>
<li>null值的处理。</li>
</ol>
<h4 id="关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？"><a href="#关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？" class="headerlink" title="关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？"></a>关键问题，写模式是什么？读模式如何直到某一个数据是用那个写模式编码的？</h4><p>这个问题要取决于Avro使用的上下文：</p>
<ol>
<li>有很多记录的大文件。<br> Avro常见场景。尤其是Hadoop的上下文中。上百万的数据，都是用相同的模式编码。这种情况下，该文件的写入模式可以嵌入到文件的开头。Avro可以制定一个文件格式来做到这一点。</li>
<li>具有单独写入记录的数据库<br> 数据库中的记录，可能是在不同的时间点写入的。每个时间点可能使用不同的写入模式。最简单的发难是在每个编码记录的开始处，包含一个版本号，制定着写入模式的版本。在数据库的一个地方存储所有的写入模式列表。这样读取时可以直到数据的写入模式。Espresso就是这样工作的。</li>
<li>通过网络连接发送记录<br> 连接双方可以在建立连接时，协商模式的版本，然后在这个连接会话中使用这个模式。这也是Avro RPC的协议原理。</li>
</ol>
<h3 id="动态生成的模式"><a href="#动态生成的模式" class="headerlink" title="动态生成的模式"></a>动态生成的模式</h3><p>Avro的一个重要优点就是不包含任何标签号。</p>
<p>不包含标签号是好理由： 动态生成模式更友好。</p>
<p>关系型数据库，使用二进制方式，把内容转存到一个文件的例子。</p>
<ol>
<li>根据关系模型，生成Avro模式。并使用这个模式编码，把数据库内容倒入Avro对象容器文件中。列名对应Avro的field</li>
<li>如果数据库的关系模型发生变化，则可以更新Avro的模式，使用新的Avro导出数据。不需要关注模式的改变，字段是通过名字来表识的，所以更新后的写模式仍然可以和老的读模式匹配。</li>
</ol>
<p>相比之下，Thrift和Protocol  Buffer都需要手动分配新的标签。而且还需要完成从数据库列名到新标签的映射。</p>
<h3 id="代码生成和动态类型语言"><a href="#代码生成和动态类型语言" class="headerlink" title="代码生成和动态类型语言"></a>代码生成和动态类型语言</h3><ol>
<li>静态类型语言<br>Thrift和Protocol Buffer依赖于代码生成。定义了模式之后，可以跨语言使用模式。对于Java，C++等语言非常有用。可以转换成内存结构，并且支持IDE的类型检查。</li>
<li>动态语言（Javascript，Ruby，Python），因为没有编译时检查，代码生成没有什么意义。</li>
<li>Avro为静态语言也提供了代码生成的工具，但是它也可以在在不生成代码的情况下使用。如果是一个嵌入了writer模式的对象容器文件，可以简单的使用Avro库打开，并用和JSON文件一样的方式查看。因为文件是字描述的。</li>
</ol>
<h2 id="模式的优点"><a href="#模式的优点" class="headerlink" title="模式的优点"></a>模式的优点</h2><ol>
<li>模式语言简单。原理简单，使用更简单，广泛的编程语言支持。</li>
<li>比JSON，XML，CSV，更紧凑</li>
<li>模式有文档价值，不需要额外的手工维护的文档</li>
</ol>
<h1 id="数据流模式"><a href="#数据流模式" class="headerlink" title="数据流模式"></a>数据流模式</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>向数据库中存储内容，就是在给未来的自己发送消息。</p>
<p>这种情况下，<strong>向后兼容</strong>是非常重要的。否则新代码无法读取存在数据库中以前写入的数据。</p>
<p>需要注意的一点是，老代码读区新代码写入的数据时，更新后又写会数据库，要当心不要丢失新数据格式的原来的信息。</p>
<p>将数据重写（迁移）到一个新的模式当然是可能的，但是在一个大数据集上执行是一个昂贵的事情，所以大多数数据库如果可能的话就避免它。</p>
<h2 id="基于服务的数据流：REST与RPC"><a href="#基于服务的数据流：REST与RPC" class="headerlink" title="基于服务的数据流：REST与RPC"></a>基于服务的数据流：REST与RPC</h2><h3 id="Web的方式，基于HTTP。"><a href="#Web的方式，基于HTTP。" class="headerlink" title="Web的方式，基于HTTP。"></a>Web的方式，基于HTTP。</h3><ol>
<li>使用客户端（浏览器，移动应用，PC应用等）访问服务器数据。</li>
<li>使用服务器访问另一个服务器的Web服务。这样的应用构建方式最近叫做微服务。</li>
</ol>
<p>微服务的关键设计目标是，通过使服务可独立部署和演化，让应用程序更易于更改和维护。这样每一个团队可以能够经常发布新的版本，而不必与其他团队协调。因此服务器和客户端之间的数据编码必须在不同版本的API之间兼容。</p>
<p>REST使一种HTTP服务的设计理念。SOAP基于XML，基于Web服务时，API被称为WSDL，支持代码生成。SOAP严重依赖工具，代码生成和IDE支持，与SOAP集成的成本很高。</p>
<p>RESTful的API更简单，格式如OpenAPI，Swagger。<br>由于互联网上存在广泛的安全威胁，REST的安全生态系统非常强大，从防火墙到OAUTH（身份验证/授权）</p>
<h3 id="远程过程调用RPC的问题"><a href="#远程过程调用RPC的问题" class="headerlink" title="远程过程调用RPC的问题"></a>远程过程调用RPC的问题</h3><p>看起来像是在使用本地方法。但是有缺陷需要解决：</p>
<ol>
<li>网络请求不可预测。速度方面，网络失败，需要准备重试的逻辑。</li>
<li>可能超时，没有结果。无法知道发生了什么。</li>
<li>重试的时候，需要保证调用的方法有幂等性保证。</li>
<li>序列化时的问题，效率方面，编程语言方面的限制。</li>
</ol>
<h3 id="RPC发展"><a href="#RPC发展" class="headerlink" title="RPC发展"></a>RPC发展</h3><p>这种新一代的RPC框架更加明确的是，远程请求与本地函数调用不同。例如，Finagle和Rest.li 使用futures（promises）来封装可能失败的异步操作。Futures还可以简化需要并行发出多项服务的情况，并将其结果合并。 gRPC支持流，其中一个调用不仅包括一个请求和一个响应，还包括一系列的请求和响应。</p>
<p>使用二进制编码格式的自定义RPC协议可以实现比通用的JSON over REST更好的性能。但是，RESTful API还有其他一些显着的优点：对于实验和调试（只需使用Web浏览器或命令行工具curl，无需任何代码生成或软件安装即可向其请求），它是受支持的所有的主流编程语言和平台，还有大量可用的工具（服务器，缓存，负载平衡器，代理，防火墙，监控，调试工具，测试工具等）的生态系统。由于这些原因，REST似乎是公共API的主要风格。 RPC框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一数据中心内。</p>
<h3 id="RPC的数据编码和演化"><a href="#RPC的数据编码和演化" class="headerlink" title="RPC的数据编码和演化"></a>RPC的数据编码和演化</h3><p>假定所有的服务器都会先更新，其次是所有的客户端。只需要在请求上具有向后兼容性，并且对响应具有前向兼容性。</p>
<p>RPC方案中的向前向后兼容的解决方法，可他们在数据编码中使用的方法也有关。</p>
<h2 id="异步消息传递，消息代理"><a href="#异步消息传递，消息代理" class="headerlink" title="异步消息传递，消息代理"></a>异步消息传递，消息代理</h2><p>中间件，可以低延迟的响应web请求。</p>
<p>优点：</p>
<ol>
<li>如果接收方不可用，可以当作缓冲区，暂存消息，等恢复之后一起消费，实现HA。</li>
<li>可以自动重新发送消息到崩溃进程。防止丢消息。</li>
<li>结偶发送方和接收方，双方不需要知道对方的IP</li>
<li>支持广播，一条消息被多个人接收</li>
<li>子系统之间结偶</li>
</ol>
<p>可以使用任何编码方式。只要兼容。</p>
<h2 id="分布式Actor框架"><a href="#分布式Actor框架" class="headerlink" title="分布式Actor框架"></a>分布式Actor框架</h2><p>并发编程模型。逻辑封装在Actor中。不直接操作线程。</p>
<p>由于每个Actor一次只能处理一条消息，因此不需要担心线程，每个Actor可以由框架独立调度。</p>
<p>分布式Actor框架中，编程模型被用来跨多节点进行scaling。位于不同节点之间的通讯可以使用encode decode的方式进行网络数据传输。</p>
<p>分布式Actor框架的实质是将消息代理（MQ等）和Actor编程模型集成到一个框架中。</p>
<p>三种流行的分布式Actor框架对于消息encoding的方式：</p>
<ul>
<li>默认情况下，Akka使用Java的内置序列化，不提供前向或后向兼容性。 但是，你可以用类似Protocol buffer的东西替代它，从而获得滚动升级的能力。</li>
<li>Orleans 默认使用不支持滚动升级部署的自定义数据编码格式; 要部署新版本的应用程序，您需要设置一个新的群集，将流量从旧群集迁移到新群集，然后关闭旧群集。 像Akka一样，可以使用自定义序列化插件。</li>
<li>在Erlang OTP中，对记录模式进行更改是非常困难的（尽管系统具有许多为高可用性设计的功能）。 滚动升级是可能的，但需要仔细计划。 一个新的实验性的maps数据类型（2014年在Erlang R17中引入的类似于JSON的结构）可能使得这个数据类型在未来更容易。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/Algorithim-String/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/Algorithim-String/" itemprop="url">Algorithim-String</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T14:12:42+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Removal"><a href="#Removal" class="headerlink" title="Removal"></a>Removal</h1><h2 id="remove-some-particular-char-from-string"><a href="#remove-some-particular-char-from-string" class="headerlink" title="remove some particular char from string"></a>remove some particular char from string</h2><p>slow,fast two pointer</p>
<h2 id="remove-all-leading-trailing-duplicated-empty-spaces-from-string"><a href="#remove-all-leading-trailing-duplicated-empty-spaces-from-string" class="headerlink" title="remove all leading/trailing/duplicated empty spaces from string"></a>remove all leading/trailing/duplicated empty spaces from string</h2><p>slow,fast two pointer, with handling special cases</p>
<h1 id="De-duplication"><a href="#De-duplication" class="headerlink" title="De-duplication"></a>De-duplication</h1><p>slow,fast two pointer</p>
<h1 id="Substring-gt-strstr"><a href="#Substring-gt-strstr" class="headerlink" title="Substring -&gt; strstr"></a>Substring -&gt; strstr</h1><h1 id="reversal"><a href="#reversal" class="headerlink" title="reversal"></a>reversal</h1><h1 id="replacement"><a href="#replacement" class="headerlink" title="replacement"></a>replacement</h1><p>Advance</p>
<h1 id="moving-letters-around-ABCD1234-gt-A1B2C3D4"><a href="#moving-letters-around-ABCD1234-gt-A1B2C3D4" class="headerlink" title="moving letters around(ABCD1234 =&gt; A1B2C3D4)"></a>moving letters around(ABCD1234 =&gt; A1B2C3D4)</h1><h1 id="permutation-use-DFS"><a href="#permutation-use-DFS" class="headerlink" title="permutation(use DFS)"></a>permutation(use DFS)</h1><h1 id="Decoding-Encoding"><a href="#Decoding-Encoding" class="headerlink" title="Decoding/Encoding"></a>Decoding/Encoding</h1><h1 id="Longest-substring-that-contains-unique-chars"><a href="#Longest-substring-that-contains-unique-chars" class="headerlink" title="Longest substring that contains unique chars"></a>Longest substring that contains unique chars</h1><h1 id="Reg-Matching"><a href="#Reg-Matching" class="headerlink" title="Reg Matching"></a>Reg Matching</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/DDIA-3-数据存储与检索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/DDIA-3-数据存储与检索/" itemprop="url">DDIA-3-数据存储与检索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T14:01:52+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据库只需要做两件事，1. 插入数据时候保存数据；2.之后读数据时，返回之前的结果。</p>
<h1 id="数据库核心：数据结构"><a href="#数据库核心：数据结构" class="headerlink" title="数据库核心：数据结构"></a>数据库核心：数据结构</h1><p>为了高效查找数据库中特定键的值，我们需要一个数据结构：索引（index）。索引是从主数据衍生的<strong>附加（additional）</strong>结构。这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。</p>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>key-value 数据的索引。</p>
<p>最简单的索引策略，保存一个内存中的hashmap，把每一个key映射到特定的字节偏移量，这样就可以找到每一个key的位置。</p>
<img src="/2019/05/05/DDIA-3-数据存储与检索/以类CSV格式存储键值对的日志，并使用内存哈希映射进行索引.png">
<p>这个理念是Bitcask（Riak中的默认索引引擎）的核心做法。只要所有key可以放入内存，只需要一次磁盘寻址，就可以把value加载到内存中。</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>所有的新的数据都以日志的样子追加到一个文件中，如何避免文件越来越大最后耗尽磁盘的空间？</p>
<ol>
<li>压缩。将日志分解成一定的大小的段，当超过时候，就关闭它。后续的写入会写入新的段文件中。然后可以分别压缩这些段。这样的压缩意味着，在每一个段日志中丢弃重复的key，只保留最近的更新。</li>
<li>多个段一起压缩，合并。由于段日志在写入后不会再修改，那么可以合并几个段的日志，到一个新的文件中。旧的日志可以删除。</li>
</ol>
<p>在这样的多段设计下，每个段都有自己的hashmap。查找过程就是一个段一个段的查询。由于有段合并，段的总数不会很多。</p>
<h3 id="实现中的重要问题"><a href="#实现中的重要问题" class="headerlink" title="实现中的重要问题"></a>实现中的重要问题</h3><ol>
<li>文件格式<br>CSV不是日志的最佳格式。更快更简单的是二进制格式，首字节存字符串长度，然后跟上原始字符串。</li>
<li>删除记录<br>插入墓碑标记</li>
<li>崩溃恢复<br>服务重启时，需要扫描所有的段来恢复hashmap，这样使得服务器重启变慢。Bitcask通过将每个hashmap的快照映射到磁盘，加速崩溃恢复。</li>
<li>部分写入的记录<br>Bitcask采用了校验和，发现损坏部分就丢弃。</li>
<li>并发控制<br>通常实现的选择只有一个写线程，简化了并发。而文件都是追加的写入，读并发更好。</li>
</ol>
<h3 id="为什么不原地更新？"><a href="#为什么不原地更新？" class="headerlink" title="为什么不原地更新？"></a>为什么不原地更新？</h3><ol>
<li>顺序写比随机写性能更好。特别是在磁盘。</li>
<li>文件是追加和不可变的，崩溃恢复更简单。</li>
<li>合并段的操作可以避免文件出现碎片。</li>
</ol>
<h3 id="哈希索引的局限性"><a href="#哈希索引的局限性" class="headerlink" title="哈希索引的局限性"></a>哈希索引的局限性</h3><ol>
<li>必须把key全部装入内存。即使在磁盘上维护hashmap，也很难保证高效的随机IO访问。处理哈希冲突也很复杂。</li>
<li>区间查询效率不高。只能逐一查询。</li>
</ol>
<h2 id="SSTables和LSM-Tree"><a href="#SSTables和LSM-Tree" class="headerlink" title="SSTables和LSM-Tree"></a>SSTables和LSM-Tree</h2><p>之前的段文件只可以追加，并且不要求key有序。现在我们可以对段文件的格式做一个简单的改变：我们要求<strong>键值对的序列按键排序</strong>。这就是<strong>SSTables（Sorted String Tables）</strong>的数据格式。我们还要求同一个key只会出现在一个段中。</p>
<p>SSTables优点：</p>
<ol>
<li>合并段更简单。就像merge sort一样。</li>
<li>内存中的hashmap索引是稀疏的。<br>在文件中查找key时，不需要在内存中保存所有的key。例如查询handiwork时，不需要handiwork在hashmap中有可以。而知道handbag和handsome的偏移量时，因为key已经排序，可以从handbag开始扫描到handsome就可以确定handiwork在不在。</li>
<li>压缩时，可以利用稀疏索引，降低了IO带宽。</li>
</ol>
<h3 id="构建和维护SSTables"><a href="#构建和维护SSTables" class="headerlink" title="构建和维护SSTables"></a>构建和维护SSTables</h3><p>要解决排序问题。方法是，</p>
<ol>
<li>在内存中保存一个排序结构，比如红黑树，AVL树。</li>
<li>在插入修改时候可以很快的响应。</li>
<li>可以顺序的读区它们。</li>
</ol>
<h4 id="存储引擎工作流程"><a href="#存储引擎工作流程" class="headerlink" title="存储引擎工作流程"></a>存储引擎工作流程</h4><ol>
<li>写入时，将数据加入内存表中，可以是红黑树实现。</li>
<li>当内存中的红黑树大小超过阀值时，把它用SSTable的格式写入磁盘。</li>
<li>处理读请求时，先尝试查询内存表，如果miss就查询磁盘段文件s。</li>
<li>周期性的执行合并和压缩。丢弃被覆盖和删除的值。</li>
</ol>
<h3 id="用SSTable实现LSM-Tree（Log-structured-Merge-Tree）"><a href="#用SSTable实现LSM-Tree（Log-structured-Merge-Tree）" class="headerlink" title="用SSTable实现LSM-Tree（Log-structured Merge-Tree）"></a>用SSTable实现LSM-Tree（Log-structured Merge-Tree）</h3><p>上面的算法时LevelDB和RocksDB使用的，用于嵌入到其他应用的key-value存储引擎。类似的存储引擎也用在了Cassandra和HBase中，这两个引擎都源于Google的BigTable论文。最初这个索引结构在早起的系统中被命名LSM-Tree。因此，基于合并和压缩的排序文件原理的存储引擎，通常都被称作LSM存储引擎。</p>
<p>全文搜索，Lucene是ElasticSearch和Solr的索引引擎。采用了类似的方法保存字典。全文索引复杂的多，但想法类似。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol>
<li>查询不存在的key时，会从内存开始扫描到磁盘的最后一个段。解决方法是，Bloom Filter。</li>
<li>压缩合并的时机。分为大小分级和分层压缩两个方法。一个是小的SSTables被连续合并到大的旧的SSTables。另一个是key的范围分裂成多个更小的SSTables，旧数据被移动到单独的层级。</li>
</ol>
<p>由于数据是按照排序存储，因此可以高效的执行区间查询。因为磁盘是顺序写入的，LSM-Tree的写入吞吐量可以非常高。</p>
<h2 id="B-trees索引"><a href="#B-trees索引" class="headerlink" title="B-trees索引"></a>B-trees索引</h2><p>应用最广泛的索引结构。和SSTable一样，B-tree保留按key排，也可以实现高效的范围查询。</p>
<p>B-tree将数据库分解成固定大小的块和页（4KB or more）。这种设计更接近底层硬件，因为磁盘也是固定大小的块的排列。</p>
<p>每个页，可以用地址标志，是磁盘地址，而不是内存。这样可以用这些页面引用构造一个树状页面进行索引。索引的根是一个页面，之后的查找根据地址，读取响应的页。</p>
<p>分支因子。</p>
<p>大多数数据库的索引适合3-4层的B-tree.因此不需要遍历非常深的页面层次即可找到所需的页。</p>
<p>B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；<br>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<h3 id="使B-tree可靠"><a href="#使B-tree可靠" class="headerlink" title="使B-tree可靠"></a>使B-tree可靠</h3><p>B-tree底层的基本操作是使用新数据覆盖磁盘的旧页。磁盘是覆盖扇区，对于SSD，擦除和重写的存储芯片块很大，情况更复杂。</p>
<p>页面溢出，需要分裂页时，也要覆盖其父页对更新后的两个子页的引用。属于复杂操作。在完成更新前发生崩溃，可能会产生孤儿页面。</p>
<p>崩溃恢复，使用redo Log。写数据之前先写日志。</p>
<p>并发控制。</p>
<h3 id="优化B-tree"><a href="#优化B-tree" class="headerlink" title="优化B-tree"></a>优化B-tree</h3><ol>
<li>一些数据库不是用覆盖页，而是做复制。</li>
<li>保存key的缩略信息而不是完整的key，来节省空间。只需要提供足够的信息来描述key的起止范围。</li>
<li>页可以存在磁盘的任何位置。可能回有随机的IO，而不是连续的。有些B-tree尝试实现对B-tree进行布局，但是随着树的增长，这个顺序会越来越难维护。</li>
<li>添加额外指针。左到右的指针，加速遍历。</li>
</ol>
<h2 id="对比B-tree-LSM-tree"><a href="#对比B-tree-LSM-tree" class="headerlink" title="对比B-tree, LSM-tree"></a>对比B-tree, LSM-tree</h2><p>根据经验，LSM-Tree写入更快，而B-tree读更快。读取通常在LSM—Tree中较慢，因为要检查多个不同的数据结构和SSTables。</p>
<h3 id="LSM-Tree优点"><a href="#LSM-Tree优点" class="headerlink" title="LSM-Tree优点"></a>LSM-Tree优点</h3><ol>
<li>LSM只写入一次数据（不考虑写放大（写入引起的压缩和合并）），而B-tree写入两次（一次redo log，一次数据本身）。</li>
<li>LSM可以成熟比B-tree更大的吞吐量。有时具有较低的写放大，顺序写入速度快。</li>
<li>可以支持更好的压缩，文件比B-tree小很多。没有B-tree产生碎片的问题。</li>
</ol>
<h3 id="LSM-Tree缺点"><a href="#LSM-Tree缺点" class="headerlink" title="LSM-Tree缺点"></a>LSM-Tree缺点</h3><ol>
<li>响应延迟不确定，因为压缩和合并。</li>
<li>由于配置问题，会出现压缩跟不上写入速度的问题。来不及合并，直到磁盘空间不足。</li>
<li>事务支持不如B-tree</li>
</ol>
<h2 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h2><h3 id="在索引中存储值"><a href="#在索引中存储值" class="headerlink" title="在索引中存储值"></a>在索引中存储值</h3><p>索引中存储行或则行的具体位置（堆文件法）。将索引行直接存在索引中，聚集索引。MySQL的InnoDB存储引擎中，表的主键是聚集索引，二级索引引用主键。</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>级联索引，通过将一列追加到另一列，将几个字段组合成一个键。只能从前到后匹配。B-tree和LSM-tree都无法高效的应对这种查询。</p>
<p>更常见的索引空间，R树。PostGIS使用PostgreSQL的广义搜索书索引实现了地理空间索引作为R树。</p>
<h3 id="全文搜索和模糊索引"><a href="#全文搜索和模糊索引" class="headerlink" title="全文搜索和模糊索引"></a>全文搜索和模糊索引</h3><p>之前的搜索都是准确匹配，而不能应对类似的key的搜索，例如错误的拼写。</p>
<p>Lucene引擎支持在某个编辑距离内的模糊搜索。LevelDB中这个内存中的索引是一些key的稀疏集合。但在Lucene中，内存中的索引是key中的字符串序列的有限状态机，类似字典树。这个自动机可以转换成Leveshtein自动机，支持编辑距离内的搜索。</p>
<h3 id="在内存中保存所有内容"><a href="#在内存中保存所有内容" class="headerlink" title="在内存中保存所有内容"></a>在内存中保存所有内容</h3><p>内存数据库。例如Memcached，做缓存。数据在重启后可以恢复。</p>
<p>内存数据可以更快的原因，是因为它们可以避免使用写磁盘的格式对内存数据结构编码的开销。</p>
<p>提供了给予磁盘索引难以实现的数据结构，例如Redis中的优先级队列和集合。</p>
<p>可以使用反缓存的方法，当没有足够的内存时，将一部分不常用数据倒入磁盘，类似操作系统的虚拟内存。</p>
<p>将来的NVM（non-volatile memory）技术广泛的普及，也可能很大的改变存储引擎的设计。</p>
<h1 id="事务处理OLTP与分析处理OLAP，"><a href="#事务处理OLTP与分析处理OLAP，" class="headerlink" title="事务处理OLTP与分析处理OLAP，"></a>事务处理OLTP与分析处理OLAP，</h1><p>事务意味着允许客户端进行低延迟读区和写入，相比于只能周期性的运行的批处理作业。事务不一定具有ACID属性。</p>
<p>OLTP每次返回少量的数据，随机访问，低延迟要求。OLAP对大量数据访问，批量导入（ETL）或事件流，内部分析师，为决策提供支持。</p>
<h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><p>数据仓库是一个单独的数据库，分析师可以在不影响OLTP的情况下，任意使用数据仓库。数据仓库包含公司所有OLTP数据库的只读副本。</p>
<p>单独使用数据仓库的优势在于数据仓库可以针对分析访问模式进行优化。本文前半部分讨论的索引模型只适合与OLTP而不适合做分析查询。</p>
<h3 id="OLTP数据库和数据仓库的差异"><a href="#OLTP数据库和数据仓库的差异" class="headerlink" title="OLTP数据库和数据仓库的差异"></a>OLTP数据库和数据仓库的差异</h3><p>数据仓库也支持SQL查询接口，但是和OLTP的实现差异很大。</p>
<p>一些数据库（SQL Server和SAP HANA）在同一产品中支持事务处理和数据仓库。然而，它们是两个独立的存储和查询引擎，只是通过一个SQL接口来访问。</p>
<p>一些商用的数据仓库，Teradata，Vertica，SAP HANA等很贵。还有开源的基于Hadoop的SQL项目，例如Apache Hive，Spark SQL，Cloudera Impala，Facebook Presto，Apache Tajo和Apache Drill. 其中一些是基于Google Dremel而构建的。</p>
<h3 id="星型与雪花型分析模式"><a href="#星型与雪花型分析模式" class="headerlink" title="星型与雪花型分析模式"></a>星型与雪花型分析模式</h3><p>许多数据仓库都使用了星型模式，也称为维度建模。</p>
<p>这种模式的中心是一个所谓的事实表。事实表的每一行表示在特定时间发生的事件。</p>
<img src="/2019/05/05/DDIA-3-数据存储与检索/用于数据仓库的星型模型例子.png">
<p>通常，事实被捕获为单独的事件，这样之后的分析具有很大的灵活性。</p>
<p>事实表中的列是属性，其他列可能会引用其他表的外键，成为维度表，这些维度代表事件的发生地点，时间，方式和原因。</p>
<p>名称<strong>星型模式</strong>来源于关系表可视化的适合，事实表位于中间，被一系列维度表包围。</p>
<p>该模型的一个变体成为<strong>雪花模型</strong>，其中维度进一步细分为子空间。例如，dimproduct表中的每一行可以再次向外引用品牌和类型的外键。这样更规范，但是更复杂。分析人员一般首选星型。</p>
<p>典型的数据仓库中，表都非常宽，事实表通常超过100列，甚至几百列。维度表也可能很宽。</p>
<h1 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h1><p>主要关注事实表的海量数据问题，通常有万亿行、PB级别的数据。</p>
<p>虽然通常事实表超过100列，但是一般一次分析也只会访问其中的4，5列。如何高效的执行这中类型的查询？</p>
<p>OLTP系统中，数据库的存储都是面向行的。如果属性超过100列，那么需要把很多不需要的数据读入内存，然后丢弃。非常低效。</p>
<p>面向列存储，不是将一行的内容存在一起，而是把每一列的所有值存在一起。</p>
<h2 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h2><p>面向列的存储非常适合压缩。一直技术是位图编码。</p>
<img src="/2019/05/05/DDIA-3-数据存储与检索/压缩位图索引存储布局.png">
<p>每一个不同的值一个位图，位图的位数是行数。</p>
<p>Bigtable模型仍然主要是面向行的。</p>
<h3 id="内存带宽和矢量化处理"><a href="#内存带宽和矢量化处理" class="headerlink" title="内存带宽和矢量化处理"></a>内存带宽和矢量化处理</h3><p>除了减少需要从磁盘加载的数据量之外，列存储也有利于高效利用CPU的周期性。</p>
<h2 id="列存储中的排序"><a href="#列存储中的排序" class="headerlink" title="列存储中的排序"></a>列存储中的排序</h2><p>列的存储如果是按照某个常见的顺序，例如date，就可以做类似于SSTables的索引机制。注意单独排序某列没用，需要正行排序。</p>
<p>数据仓库管理员需要基于经验选择合适的排序列，可以单列也可以是多列。这样查询优化器可以更高效。</p>
<p>另一个好处是可以进行压缩。可以进行游程编码，位图那样。</p>
<h3 id="几种不同的排序"><a href="#几种不同的排序" class="headerlink" title="几种不同的排序"></a>几种不同的排序</h3><ol>
<li>C-Store的改进。用不同的方式存储相同的数据。使不同的排序查询都获益。也就是通过排序后的冗余数据加速。</li>
<li>列排序，类似于面向行的二级索引。区别是，列的索引中，存的是值而不是地址。</li>
</ol>
<h2 id="列存储与写操作"><a href="#列存储与写操作" class="headerlink" title="列存储与写操作"></a>列存储与写操作</h2><p>上述的优化，都是对读的优化，这会让写变得更困难。类似B-tree的就地更新的操作，对压缩列是不可能的。</p>
<p>一个方案是类似LSM-tree。先写入内存的排序数据结构，然后在一定的时候把内存的数据顺序的倒入磁盘，接着进行有可能的文件合并。这样查询的时候需要检查内存中的数据，和磁盘中的数据。这对于查询方是透明的。</p>
<h2 id="聚合：数据立方体和物化视图"><a href="#聚合：数据立方体和物化视图" class="headerlink" title="聚合：数据立方体和物化视图"></a>聚合：数据立方体和物化视图</h2><p>数据仓库不是一定要用列存储的。但是列存储因为查询分析更快，所以正在迅速普及。数据仓库另一个方面是物化聚合，就是把常用的查询物理存储化，缓存一些查询结果。</p>
<p>实现：物化视图。 物化视图的常见特例称为数据立方体或OLAP立方。它是按不同维度分组的聚合网格。以沿着每行或每列应用相同的汇总，并获得一个维度减少的汇总（按产品的销售额，无论日期，还是按日期销售，无论产品如何）。</p>
<p>缺点是数据立方体不具有查询原始数据的灵活性。因此，大多数数据仓库试图保留尽可能多的原始数据，并将聚合数据（如数据立方体）仅用作某些查询的性能提升。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/DDIA-2-数据模型与查询语言/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/DDIA-2-数据模型与查询语言/" itemprop="url">DDIA-2-数据模型与查询语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T13:13:46+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>语言的边界就是世界的边界</p>
<p>数据模型可能是软件开发中最重要的部分了，因为它们的影响如此深远：不仅仅影响着软件的编写方式，而且影响着我们的解题思路。</p>
<h1 id="关系模型与文档模型"><a href="#关系模型与文档模型" class="headerlink" title="关系模型与文档模型"></a>关系模型与文档模型</h1><h2 id="关系型-RDBMS"><a href="#关系型-RDBMS" class="headerlink" title="关系型 RDBMS"></a>关系型 RDBMS</h2><p>关系模型致力于将数据库本身的实现细节隐藏在更简洁的接口之后。数据被组织成表，每个关系都是Tuple的无序集合。</p>
<p>应用场景<br>你今天在网上看到的大部分内容依旧是由关系数据库来提供支持，无论是在线发布，讨论，社交网络，电子商务，游戏，软件即服务生产力应用程序等等内容。</p>
<p>需求Transaction</p>
<h2 id="文档型-NoSQL"><a href="#文档型-NoSQL" class="headerlink" title="文档型 NoSQL"></a>文档型 NoSQL</h2><p>NoSQL数据库出现，有以下几个原因：</p>
<ol>
<li>关系型数据库的扩展性不够，包括对非常大的数据集或者非常高的写入吞吐量。</li>
<li>开源免费。</li>
<li>关系模型不能很好的支持特殊性的查询操作。</li>
<li>渴望一种更具多动态性与表现力的数据模型</li>
</ol>
<h2 id="对象关系不匹配"><a href="#对象关系不匹配" class="headerlink" title="对象关系不匹配"></a>对象关系不匹配</h2><p>如果数据存储在关系表中，那么需要一个<strong>笨拙的转换层</strong>，处于应用程序代码中的对象和表，行，列的数据库模型之间。模型之间的不连贯有时被称为阻抗不匹配（impedance mismatch)<br>像ActiveRecord和Hibernate这样的<strong>对象关系映射（object-relational mapping, ORM）</strong>框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异</p>
<h3 id="LinkedIn简历的例子，一对多"><a href="#LinkedIn简历的例子，一对多" class="headerlink" title="LinkedIn简历的例子，一对多"></a>LinkedIn简历的例子，一对多</h3><img src="/2019/04/21/DDIA-2-数据模型与查询语言/LinkedIn建立使用关系模型表示.png">
<p>一个User和他相关的项目有一对多的关系。除了使用在其他表中加入UserID作为外键；使用有些SQL数据库支持的列的数据格式为JSON/XML，<br>它更适合用JSON来表示。因为，<strong>简单</strong>，它主要是一个自包含的文档。文档模型优势在于如果要读区一份简历，<strong>局部性</strong>更好。一次查询就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;user_id&quot;: 251,</span><br><span class="line">  &quot;first_name&quot;: &quot;Bill&quot;,</span><br><span class="line">  &quot;last_name&quot;: &quot;Gates&quot;,</span><br><span class="line">  &quot;summary&quot;: &quot;Co-chair of the Bill &amp; Melinda Gates... Active blogger.&quot;,</span><br><span class="line">  &quot;region_id&quot;: &quot;us:91&quot;,</span><br><span class="line">  &quot;industry_id&quot;: 131,</span><br><span class="line">  &quot;photo_url&quot;: &quot;/p/7/000/253/05b/308dd6e.jpg&quot;,</span><br><span class="line">  &quot;positions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;job_title&quot;: &quot;Co-chair&quot;,</span><br><span class="line">      &quot;organization&quot;: &quot;Bill &amp; Melinda Gates Foundation&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;job_title&quot;: &quot;Co-founder, Chairman&quot;,</span><br><span class="line">      &quot;organization&quot;: &quot;Microsoft&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;education&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;school_name&quot;: &quot;Harvard University&quot;,</span><br><span class="line">      &quot;start&quot;: 1973,</span><br><span class="line">      &quot;end&quot;: 1975</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;school_name&quot;: &quot;Lakeside School, Seattle&quot;,</span><br><span class="line">      &quot;start&quot;: null,</span><br><span class="line">      &quot;end&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;contact_info&quot;: &#123;</span><br><span class="line">    &quot;blog&quot;: &quot;http://thegatesnotes.com&quot;,</span><br><span class="line">    &quot;twitter&quot;: &quot;http://twitter.com/BillGates&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的结构意味着数据存在一对多的关系，也就是<strong>树状结构</strong></p>
<img src="/2019/04/21/DDIA-2-数据模型与查询语言/树状结构的简历.png">
<h3 id="多对一，多对多"><a href="#多对一，多对多" class="headerlink" title="多对一，多对多"></a>多对一，多对多</h3><p>建立例子中的region_id, industry_id,主要解决了重复问题。可以避免歧义，做本地化支持，更好的搜索，等等。消除重复，就是数据库范式化的核心思想。</p>
<h4 id="IMS的层次模型"><a href="#IMS的层次模型" class="headerlink" title="IMS的层次模型"></a>IMS的层次模型</h4><p>支持多对多的关系有些困难，而且不支持联结。</p>
<h4 id="网络模型（network-model）-已经淘汰"><a href="#网络模型（network-model）-已经淘汰" class="headerlink" title="网络模型（network model） 已经淘汰"></a>网络模型（network model） 已经淘汰</h4><p>存指针，而不是外键。是一条开始于根（root）的路径。更改变得很困难。</p>
<h4 id="关系模型（relational-model）"><a href="#关系模型（relational-model）" class="headerlink" title="关系模型（relational model）"></a>关系模型（relational model）</h4><p>关系模型使用外键访问，也类似一选择了一条访问路径，区别在于，这个是由查询优化器自动生产的，一般不必过多的考虑。</p>
<h4 id="文档数据库的比较"><a href="#文档数据库的比较" class="headerlink" title="文档数据库的比较"></a>文档数据库的比较</h4><p>在表示多对多关系时候，关系模型与文档模型并没有不同，都是有相关的一项唯一标示符引用。关系模型中叫<strong>外键</strong>，文档模型中叫<strong>文档引用</strong>。可以使用链接操作或者后续的操作来解析这个引用。</p>
<h2 id="选哪个"><a href="#选哪个" class="headerlink" title="选哪个"></a>选哪个</h2><p>要考虑多方面的差异，包括容错性，并发处理。</p>
<p>关于模型中的差异，以下，</p>
<h3 id="哪个更简单"><a href="#哪个更简单" class="headerlink" title="哪个更简单"></a>哪个更简单</h3><p>如果应用本身有着类似文档的结构（树状结构，一对多），那么使用NoSQL。</p>
<p>关系型模型，倾向于模型中数据的分解。他把文档结构分解成多个表，有可能使得模式更为笨重，增加代码复杂度。</p>
<p>文档模型的局限性有，不能直接读取文档中的嵌套项，而是要全部读取，例如读区用户id为251的用户中职位列表的第二个。</p>
<p>对于连接的支持，是否是问题取决于应用本身，需不需要这种场景。</p>
<p>对于高度关联的数据，文档模型可能不是很适合。</p>
<h3 id="文档模式的灵活性"><a href="#文档模式的灵活性" class="headerlink" title="文档模式的灵活性"></a>文档模式的灵活性</h3><p>可以将任何key-value添加到文档数据库中，而且读取时，客户端也无法保证文档会包含那些字段。</p>
<p>文档模型是schema on read，<br>关系模型是schema on write。</p>
<p>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大的争议性一样【22】，数据库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案。</p>
<p>允许某些原因下，集合中数据是异构的。</p>
<h3 id="查询数据的局部性"><a href="#查询数据的局部性" class="headerlink" title="查询数据的局部性"></a>查询数据的局部性</h3><p>局部性优势在于，需要同时访问文档中大部分内容时，加载一次文档即可。但如果每次只访问文档中的一小部分，有些浪费。</p>
<p>更改文档时，会重写整个文档，因此通常建议，文档应该尽量的小，并且避免写入时候增加文档大小。</p>
<p>NoSQL在为文档分配空间时候，会多分配一些，以防修改更新时候，空间不足，引起空间搬家的昂贵操作。</p>
<h3 id="NoSQL与关系型数据库的结合"><a href="#NoSQL与关系型数据库的结合" class="headerlink" title="NoSQL与关系型数据库的结合"></a>NoSQL与关系型数据库的结合</h3><h1 id="数据查询语言"><a href="#数据查询语言" class="headerlink" title="数据查询语言"></a>数据查询语言</h1><p>SQL是一种声明式查询语言，与IMS和CODASYL命令式不同。</p>
<p>声明式查询语言不需要关心实现。由数据库查询引擎来优化实现。可以在不改变查询语句的情况下提高性能。可以利用并行执行的优化。</p>
<h2 id="Web中的声明式查询就是CSS，比Javascript的命令式查询要好。"><a href="#Web中的声明式查询就是CSS，比Javascript的命令式查询要好。" class="headerlink" title="Web中的声明式查询就是CSS，比Javascript的命令式查询要好。"></a><strong>Web中的声明</strong>式查询就是CSS，比Javascript的命令式查询要好。</h2><h2 id="MapReduce查询-介于声明式和命令式之间"><a href="#MapReduce查询-介于声明式和命令式之间" class="headerlink" title="MapReduce查询 介于声明式和命令式之间"></a><strong>MapReduce查询</strong> 介于声明式和命令式之间</h2><p>一些NoSQL数据存储（包括MongoDB和CouchDB）支持有限形式的MapReduce，作为在多个文档中执行只读查询的机制。</p>
<p>查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用。它基于map（也称为collect）和reduce（也称为fold或inject）函数，两个函数存在于许多函数式编程语言中。</p>
<p>map和reduce函数在功能上有所限制：它们必须是纯函数，这意味着它们只使用传递给它们的数据作为输入，它们不能执行额外的数据库查询，也不能有任何副作用。这些限制允许数据库以任何顺序运行任何功能，并在失败时重新运行它们。然而，map和reduce函数仍然是强大的：它们可以解析字符串，调用库函数，执行计算等等。</p>
<p>MapReduce是一个相当底层的编程模型，用于计算机集群上的分布式执行。像SQL这样的更高级的查询语言可以用一系列的MapReduce操作来实现（见第10章），但是也有很多不使用MapReduce的分布式SQL实现。请注意，SQL中没有任何内容限制它在单个机器上运行，而MapReduce在分布式查询执行上没有垄断权。</p>
<h1 id="图状数据模型"><a href="#图状数据模型" class="headerlink" title="图状数据模型"></a>图状数据模型</h1><p>解决复杂的多对多关系。</p>
<p><strong>社交图谱</strong></p>
<p>顶点是人，边指示哪些人彼此认识。</p>
<p><strong>网络图谱</strong></p>
<p>顶点是网页，边缘表示指向其他页面的HTML链接。</p>
<p><strong>公路或铁路网络</strong></p>
<p>顶点是交叉路口，边线代表它们之间的道路或铁路线。</p>
<p>图的存储，就是存定点和边。</p>
<ol>
<li>任何顶点都可以有一条边连接到任何其他顶点。没有模式限制哪种事物可不可以关联。</li>
<li>给定任何顶点，可以高效地找到它的入边和出边，从而遍历图，即沿着一系列顶点的路径前后移动。（这就是为什么例2-2在tail_vertex和head_vertex列上都有索引的原因。）</li>
<li>通过对不同类型的关系使用不同的标签，可以在一个图中存储几种不同的信息，同时仍然保持一个清晰的数据模型。</li>
</ol>
<p>这些特性让建模很灵活。有利于演化：添加应用功能时，容易扩展用，更能应对变化，使用合适的的数据结构。</p>
<h2 id="Cypher查询语言"><a href="#Cypher查询语言" class="headerlink" title="Cypher查询语言"></a>Cypher查询语言</h2><p>Neo4j图形数据库</p>
<h2 id="SQL的图查询"><a href="#SQL的图查询" class="headerlink" title="SQL的图查询"></a>SQL的图查询</h2><p>与Cypher比显得笨拙</p>
<h2 id="三元存储与SPARQL"><a href="#三元存储与SPARQL" class="headerlink" title="三元存储与SPARQL"></a>三元存储与SPARQL</h2><p>所有信息都是三个部分存储（主体，谓语，客体）。</p>
<h3 id="RDF数据模型"><a href="#RDF数据模型" class="headerlink" title="RDF数据模型"></a>RDF数据模型</h3><p>类似XML，更冗长。 不区分属性和边。</p>
<p>有工具支持生成RDF格式的数据模型。</p>
<h3 id="SPARQL查询语言"><a href="#SPARQL查询语言" class="headerlink" title="SPARQL查询语言"></a>SPARQL查询语言</h3><p>采用RDF数据模型的三元存储查询语言。类似一次性SELECT操作完成。</p>
<h3 id="Datalog基础"><a href="#Datalog基础" class="headerlink" title="Datalog基础"></a>Datalog基础</h3><p>比较老，适合处理复杂数据。每次实现一块。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/" itemprop="url">DDIA-1-可靠可扩展可维护的应用系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-20T19:35:16+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据密集型应用的模块"><a href="#数据密集型应用的模块" class="headerlink" title="数据密集型应用的模块"></a>数据密集型应用的模块</h1><p>当今许多应用大多是数据数据密集（data-intensive）而不是计算密集型（compute-intensive）的。所以CPU的处理能力往往不是应用程序的瓶颈。关键在于数据的量、数据的复杂度以及数据的快速多变性。</p>
<p>应用往往包含以下模块：</p>
<ol>
<li>数据库：用于存储数据</li>
<li>高速缓存：缓存复杂或者操作代价昂贵的结果，加快下一次访问</li>
<li>索引：用户可以按照关键字搜索数据并支持各种过滤</li>
<li>流式处理：持续发送消息到另一个进程，处理采用异步方式</li>
<li>批处理：定期处理大量积累的数据</li>
</ol>
<h2 id="数据系统的架构"><a href="#数据系统的架构" class="headerlink" title="数据系统的架构"></a>数据系统的架构</h2><img src="/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/一个可能的组合使用多个组件的数据系统架构.png" title="一个数据架构系统，包含了不同的组件">
<h1 id="核心设计目标"><a href="#核心设计目标" class="headerlink" title="核心设计目标"></a>核心设计目标</h1><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>出现意外情况，比如硬件、软件故障、人为失误等，系统可以继续正常运转，至少确保功能正确。</p>
<h3 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h3><p>比较容易出现的，硬盘崩溃，内存故障，电网停电。</p>
<p>第一反应是为硬件冗余来减少系统故障率。例如磁盘RAID，服务器双电源，甚至热插拔CPU，数据中心添加备用电源、发电机。</p>
<p>这样当一个组件发生故障时，冗余组件可以快速接管，之后运维人员可以修复或者更换坏掉的组件。</p>
<p>直到最近，采用硬件冗余方案对于大多数应用场景还是足够的，它让单机完全失效的概率降到最低。只要可以把备份迅速恢复到新的机器上，故障的停机时间在大多数应用中并不是灾难性的。</p>
<p>现在，通过软件容错的方式来容易多机失效成为新的手段，或者成为硬件容错方案的有力补充。例如滚动升级。</p>
<h3 id="软件错误"><a href="#软件错误" class="headerlink" title="软件错误"></a>软件错误</h3><p>这类故障更难预料。各个节点直接是由软件关联的，可能会导致更多的系统故障。</p>
<p>例如，</p>
<ol>
<li>由于软件错误，导致特定的输入引发应用的崩溃。例如Linux内核bug，在2012年6月30的闰秒时候触发，导致很多应用程序被挂掉。</li>
<li>失控的进程把系统的资源耗尽，导致这些共享资源不能被释放。</li>
<li>系统的Dependency出了问题，返回值异常。</li>
<li>组件中的小故障触发另一个组件中的故障，进而触发更多的故障。</li>
</ol>
<p>没有快速的解决方法。只能仔细考虑很多细节。</p>
<ol>
<li>检查系统的假设条件和系统之间的交互</li>
<li>进行全面的测试</li>
<li>进程隔离，</li>
<li>允许进程崩溃后自动重启</li>
<li>反复评估、监控并分析生产环境中的行为表现。</li>
</ol>
<p>例如消息队列中，输出消息的数量应等于输入消息的数量。如果发现不一致，则立即告警。</p>
<h3 id="人为失误"><a href="#人为失误" class="headerlink" title="人为失误"></a>人为失误</h3><p>人无法做到万无一失。运维人员的配置错误可能是系统下线的第一大原因。</p>
<p>要保证系统可靠，如何减少人为错误对它的影响？</p>
<ol>
<li>用最小出错的方式来设计系统。让做错事更难。</li>
<li>想办法分离最容易出错的地方，容易引发故障的接口。使用Sandbox隔离真正的生产和测试环境。</li>
<li>充分的测试。单元测试，集成测试，手动测试。边界条件的考虑。</li>
<li>当出现人为失误时，有快速回滚或者回复的机制。滚动发布新代码。</li>
<li>监控子系统需要详细和清晰。</li>
<li>推行管理流程和相关培训。</li>
</ol>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>随着规模的增长，例如数据量、流量和复杂性，系统应该可以用合理的方式进行应对，满足这种增长。</p>
<p>当应用负载增加的时候，比如用户从1w到100w，从100w到1000w，应用程序如何应对增长的负载。</p>
<p>相关参数：Web服务的QPS，数据库的写入比例，DAU，缓存命中率。有时候平均值很重要，有时候短时间内的峰值会成为系统瓶颈。</p>
<p>Twitter的Fan-out结构，对数据量提出了挑战。当一个人发Tweet时候，怎么处理Timeline这个请求。根据粉丝的数量，区别处理。</p>
<h3 id="如何描述性能"><a href="#如何描述性能" class="headerlink" title="如何描述性能"></a>如何描述性能</h3><p>系统负载增加后，会发生什么，两种思考方式</p>
<ol>
<li>系统资源不变（CPU，内存，带宽），系统的性能会发生什么变化？</li>
<li>如果要保持性能不变，需要增加多少资源？</li>
</ol>
<p>不同类型的系统关心的性能指标不同</p>
<ol>
<li>批处理系统通常关心<strong>吞吐量（throughput）</strong>，例如Hadoop，每秒可以处理多少条数据或者完成一个作业总共需要多少时间。</li>
<li>Online系统中，更看重服务的<strong>响应时间（response time）</strong>，即客户端从发出请求到得到回复的总时间。</li>
</ol>
<img src="/2019/04/20/DDIA-1-可靠可扩展可维护的应用系统/响应时间.png" title="展示了一个服务100次请求响应时间的均值与百分位数、中位数">
<p>对于响应时间，如下图，有一些很长的，算异常请求，可能是由于数据大很多。但也有可能是其他因素造成的，例如上下文切换、进程调度、网络丢包、TCP重传、垃圾回收STW，缺页中断、磁盘IO。</p>
<p>最好使用百分位数，中位数（50%）来评估系统的响应时间。</p>
<p>采用较高的响应时间百分位数很重要，因为直接影响用户的总体服务体验。例如亚马逊采用99.9百分位来定义服务响应时间。优化99.9%的目标可能成本很高。能不能带来收益很关键。</p>
<p>​排队延迟（queueing delay）通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为头部阻塞（head-of-line blocking）</p>
<h3 id="应对负载增加"><a href="#应对负载增加" class="headerlink" title="应对负载增加"></a>应对负载增加</h3><p>垂直扩展和水平扩展。</p>
<p>好的系统有弹性特征，可以自动检测负载的变化，来自动添加更多的计算资源。</p>
<p>可扩展架构通常都是从通用模块逐步构建出来的。</p>
<h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>项目会随着时间的推移，项目会需要新的人员参与到开发和运维工作中，来满足系统的稳定和新场景的适应。系统应该高效的变化。</p>
<p>​软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常运行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。</p>
<p>为此，我们将特别关注软件系统的三个设计原则：</p>
<h3 id="可操作性（Operability）"><a href="#可操作性（Operability）" class="headerlink" title="可操作性（Operability）"></a>可操作性（Operability）</h3><p>​    便于运维团队保持系统平稳运行。<br>良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。数据系统可以通过各种方式使日常任务更轻松：</p>
<h3 id="简单性（Simplicity）"><a href="#简单性（Simplicity）" class="headerlink" title="简单性（Simplicity）"></a>简单性（Simplicity）</h3><p>​    从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。）<br>   <strong>复杂度（complexity）</strong>有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等等，</p>
<h3 id="可演化性（evolability）"><a href="#可演化性（evolability）" class="headerlink" title="可演化性（evolability）"></a>可演化性（evolability）</h3><p>​    使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。<br>    组织流程方面，敏捷开发，TDD，重构。<br>    修改数据系统并使其适应不断变化需求的容易程度，是与简单性和抽象性密切相关的：简单易懂的系统通常比复杂系统更容易修改</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/文明之光-近代音乐发展/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/文明之光-近代音乐发展/" itemprop="url">文明之光-近代音乐发展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-13T17:19:18+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>透过古典音乐的发展历程，可以感受到近代人文主义的兴起和发展，以及时代的变迁。</p>
<h1 id="巴洛克音乐"><a href="#巴洛克音乐" class="headerlink" title="巴洛克音乐"></a>巴洛克音乐</h1><h2 id="形成时期"><a href="#形成时期" class="headerlink" title="形成时期"></a>形成时期</h2><p>早起音乐与宗教有关。后来人们富裕之后，音乐的宗教气息逐渐减少，世俗的元素开始增加。欧洲音乐第二次走向世俗是发生在文艺复兴时期，而其中产生质变是在18世纪初的巴洛克时期。因此巴洛克音乐是所有古典音乐的基础。</p>
<h2 id="什么是巴洛克"><a href="#什么是巴洛克" class="headerlink" title="什么是巴洛克"></a>什么是巴洛克</h2><p>源于西班牙语Barocco，引申的意思是充满细节。主要是指文艺复兴后期，豪华的建筑和精致的装饰风格。后来被用到了绘画和音乐中，也是类似的意思。巴洛克音乐华丽精致，加入了大量的修饰性音符。巴洛克时期的影响力最大的音乐家是巴赫。</p>
<img src="/2019/04/13/文明之光-近代音乐发展/barocco.png" title="巴洛克建筑的立柱">
<h2 id="巴赫（1685-1750）"><a href="#巴赫（1685-1750）" class="headerlink" title="巴赫（1685-1750）"></a>巴赫（1685-1750）</h2><iframe width="100%" height="400px" src="//player.bilibili.com/player.html?aid=5990334&cid=9724899&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>出身音乐世家。音乐天才。小时候因为父母趋势的早，被养在哥哥家。由于家庭负担问题15岁就要自己去挣钱养活自己。在教会表演，王公贵族的乐队里担任管风琴师。</p>
<p>下了很多苦功夫学习，21岁成为德意志地区有名的乐器师，担任城市乐团首席音乐总监。1717年在柯腾宫廷担任首席乐队长，在此期间创作了《勃兰登堡协奏曲》，创作水平到了炉火纯青的地步。</p>
<p>巴赫在音乐上的贡献非常高。</p>
<p><strong>在音乐之道上</strong>，有些人认为他比之后的贝多芬莫扎特地位还要高，原因就是在于他奠定了古典音乐的基础。巴赫教会了后人如何使用音符构建出音乐作品。<br>另一个贡献，帮音乐从宗教走向世俗。把严肃的沉重的宗教曲目，变化成美妙的优雅的表演。<br>巴赫确立了德意志地区在几百年之后中古典音乐的地位。巴赫之前，意大利比较厉害。巴赫是第一个把南欧丰富新颖的音乐表现形式容易单一呆板的德意志音乐的。</p>
<p><strong>在音乐之术上</strong>，有声乐和器乐两个方面。<br>声乐方面，巴赫的声乐作品中，康塔塔的数量占比很高。在巴赫的康塔塔中，首尾都是宗教的赞歌，中段是围绕主题的独唱咏叹调、重唱和合唱构成。这样的结构非常合理，既能表现宗教音乐的神圣，又带有民间艺术的美感。<br>在器乐曲上，巴赫是我们今天经常听到的奏鸣曲和协奏曲的先驱。协奏曲诞生于意大利。巴赫整天沉醉与各种乐器的组合实验。从此有了一种乐器为主，其他乐器为辅的协奏曲。配器有弦乐、羽管键琴、双簧管、小号、圆号、低音奥维尔，等等。最著名的就是《勃兰登堡协奏曲》。巴赫之后的音乐家，莫扎特、贝多芬等人在他的基础上不断完善协奏曲的创作技巧。</p>
<p>巴赫时代并不具备将创作的音乐普及全欧洲的条件。因此在他去世几十年后就被人们遗忘了。巴赫作品的重新发现和认识，要感谢浪漫主义时期的<strong>门德尔松</strong>（1809-1847）。门德尔松整理和出版了巴尔德音乐，在巴赫去世百年之后，人们才重新认识到这位奠定了现代音乐基础的作曲家的伟大。</p>
<p>巴赫一生作品之多，质量之高，让后世音乐家难以望其项背。作品包括几百首康塔塔，大量协奏曲，五部弥撒，大量的赋格。</p>
<h1 id="古典主义音乐"><a href="#古典主义音乐" class="headerlink" title="古典主义音乐"></a>古典主义音乐</h1><p>古典主义是指欧洲18世纪末19世纪初的文化和艺术思潮。那时正是资产阶级取代贵族统治欧洲的时期，音乐和艺术都是姨资产阶级追求的自由和人性解放为背景创作的。讲究理性、秩序、和谐。</p>
<h2 id="海顿"><a href="#海顿" class="headerlink" title="海顿"></a>海顿</h2><p>海顿、莫扎特和贝多芬。生于奥地利的海顿不仅是古典主义时期第一位重要的作曲家，也是<strong>交响乐之父</strong>。海顿不仅确立了交响乐的形式，而且一生创作了108首交响乐，超过莫扎特，贝多芬、舒伯特、舒曼、门德尔松、柴可夫斯基、马勒等人的创作总和。</p>
<p>海顿最大的贡献在于确定了交响乐的形式，即由四个乐章组成，分别是快板-慢板-诙谐曲或者小步舞曲-快板。直到今天大部分交响乐依然沿用这个传统。</p>
<h2 id="莫扎特"><a href="#莫扎特" class="headerlink" title="莫扎特"></a>莫扎特</h2><p>神童、天才。六岁就在维也纳宫廷为特蕾莎女王表演钢琴。莫扎特音乐轻柔曼妙，充满了阳光。可能不再年轻、有一些闲暇并且积累了一些人生经历时，才会发现莫扎特很适合自己。</p>
<iframe width="100%" height="400px" src="//player.bilibili.com/player.html?aid=7779069&cid=12755148&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h2 id="贝多芬"><a href="#贝多芬" class="headerlink" title="贝多芬"></a>贝多芬</h2><img src="/2019/04/13/文明之光-近代音乐发展/2019-04-13-21-12-59.png" title="贝多芬的肖像，收藏于贝多芬波恩故居，手中作品是《庄严弥撒曲》">
<p>乐圣。罗曼罗兰说贝多芬时人类历史上最伟大的英雄。1770年生于波恩。爷爷是宫廷乐队长，父亲是男高音。拜师奈弗，在两年后成为乐队的管风琴师并发布了三首奏鸣曲。</p>
<p>波恩大公弗朗兹十分欣赏年轻的贝多芬，成了他早起的保护人。介绍他去维也纳拜师莫扎特。不过由于莫扎特当时在忙于创作，没有成功。后来贝多芬回到波恩遇到了海顿，波恩建议他到维也纳学习。贝多芬1792年第二次到维也纳，并在那里度过了他一生的大部分时间。</p>
<p>接受了法国启蒙运动平等自由博爱的思想。成为自由主义者。贝多芬一生追求人性的解放，他的作品一直体现出一种向上的理想主义倾向。《第二交响曲》，形成自己的风格，英雄主义倾向很明显。两年后《第三（英雄）交响曲》，本来想献给拿破仑，最后听说拿破仑成帝了，起的把拿破仑名字划掉。</p>
<p>英雄交响曲分为四个乐章。第一乐章为快板，描写了法国大革命的情景，场面宏大。第二乐章，《葬礼进行曲》，描写英雄牺牲，人民为他送葬。第三乐章为快节奏诙谐曲。第四乐章为快板，奔放和柔美交替，越来越强烈，直到最后一个壮丽的高潮。</p>
<p>贝多芬有两段重要的爱情，最后都没有变成婚姻。第一段中写下了《月光奏鸣曲》，这段感情深深的伤害了贝多芬，甚至想到自杀。第二段特蕾莎，刻骨铭心，完成《第四交响曲》，《热情奏鸣曲》，《致爱丽丝》。</p>
<p>贝多芬30岁后耳聋越来越严重，把自己和命运抗争的心情写在《第五交响曲》，东亚又称为《命运交响曲》。恩格斯评价，如果你没听过这部壮丽的作品的话，那么可以说你一生什么作品都没听过。</p>
<p>《第六交响曲》，打破了四个乐章的限制，并且给每个乐章起了标题，在该曲中，用乐器模仿自然的声音。</p>
<p>最后的理想是想把《欢乐颂》的文字通过合唱的形式加到交响乐中，创作了被称为《合唱》的《第九交响曲》。1824年5月7日在维也纳首演，结束后整个音乐厅爆发出雷鸣般的掌声，可是贝多芬已经听不到了。女高音牵着贝多芬转过身来后，贝多芬激动的昏了过去。当时热烈的场面如同暴动，观众给予了五次掌声。而对国王也只有三次。</p>
<p>小说《约翰·克里斯朵夫》，前一半是以贝多芬为原型写的。</p>
<iframe width="100%" height="400px" src="//player.bilibili.com/player.html?aid=7844540&cid=12871747&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h1 id="浪漫主义音乐"><a href="#浪漫主义音乐" class="headerlink" title="浪漫主义音乐"></a>浪漫主义音乐</h1><p>拿破仑战争之后，欧洲进入平稳。浪漫主义音乐家更注重感情和音乐本身的外在表现，而不看重形式和结构。</p>
<h2 id="舒伯特"><a href="#舒伯特" class="headerlink" title="舒伯特"></a>舒伯特</h2><p>600首歌曲，10部交响曲，22部钢琴奏鸣曲和大量的其他作品。</p>
<h2 id="门德尔松"><a href="#门德尔松" class="headerlink" title="门德尔松"></a>门德尔松</h2><p>《仲夏夜之梦》等作品。收集整理了从巴赫到舒曼等著名音乐家的大量作品，对欧洲音乐的传承贡献很大。</p>
<h2 id="肖邦"><a href="#肖邦" class="headerlink" title="肖邦"></a>肖邦</h2><p>1810年出生于波兰。六岁开始学钢琴，8岁登台演出，被认为是继莫扎特贝多芬后的又一位神童。<br>《A大调军队波兰舞曲》和《降A大调英雄波兰舞曲》最有阳刚之气。<br>在法国生活了半辈子，一直眷恋故乡波兰。一生创作很多钢琴曲。作品四类，一类波兰的民族音乐，二类是法国的沙龙音乐，包括圆舞曲、即兴曲、夜曲；三类是炫技类作品；四类是表述内心情感作品。</p>
<h1 id="民族主义音乐"><a href="#民族主义音乐" class="headerlink" title="民族主义音乐"></a>民族主义音乐</h1><p>19世纪末，欧洲人的国家意识加强，浪漫主义音乐渐渐演变成民族主义音乐。成就最高的是俄罗斯的作曲家。</p>
<h2 id="柴可夫斯基"><a href="#柴可夫斯基" class="headerlink" title="柴可夫斯基"></a>柴可夫斯基</h2><p>出身于俄罗斯贵族家庭，父亲从小要求他学习法律，从事相关法律工作。但是他并不喜欢，22岁后考入圣彼得堡音乐学院学习音乐创作。1876年写出了《天鹅湖》芭蕾舞剧。梅克夫人与柴可夫斯基精神上交往了13年并在经济上支持他，并为他排忧解难。成为专职作曲家。但从未谋面。《1812序曲》纪念俄罗斯人在1812年打败拿破仑。1893年创作出了最重要的作品《第六（悲怆）交响曲》写尽了自己的一生酸甜苦辣。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Roger Guo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roger Guo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
