<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Roger Guo&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Roger Guo&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roger Guo&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Roger Guo's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Roger Guo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/11/Java并发编程-性能与活跃性以及并发程序测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/Java并发编程-性能与活跃性以及并发程序测试/" itemprop="url">Java并发编程-性能与活跃性以及并发程序测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-11T10:58:03+08:00">
                2018-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><p>我们通过加锁来确保线程安全，但是如果过度使用加锁，可能引起死锁。我们通过信号量和线程池，来限制对有限资源的使用，但是在有些情况下，这也可能造成死锁。<br>Java程序无法自动从死锁状态恢复，所以我们在设计程序时候，要找到可能导致死锁的条件。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>经典的死锁问题就是哲学家进餐问题。<br><img src="./Dining.jpg" alt="Dining philosophers problem"><br>有些筷子管理算法能够让每个人都吃到东西，但有些算法可能导致一部分或者所有哲学家都饿死。</p>
<p>后一种情况就是死锁：每个人拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所需要的所有资源前都不会放弃已经拥有的资源。</p>
<h4 id="顺序死锁"><a href="#顺序死锁" class="headerlink" title="顺序死锁"></a>顺序死锁</h4><p><img src="./LeftRightDeadLock.gif" alt="Left Right Deadlock"><br>如果所有线程都按照固定的顺序来获得锁，那么就不会出现顺序死锁问题。<br>如果想要验证锁的顺序的一致性，需要对程序中的加锁行为进行全局分析。</p>
<h5 id="动态的顺序死锁问题"><a href="#动态的顺序死锁问题" class="headerlink" title="动态的顺序死锁问题"></a>动态的顺序死锁问题</h5><p>有时候并不是可以很清楚的知道是否会发生顺序死锁。<br><figure class="highlight java"><figcaption><span>动态的顺序死锁</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeadLock！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount, DollarAmout amount)</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAccount.debit(amount);</span><br><span class="line">                toAccount.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>transferMoney在什么时候会发生死锁？看起来线程是按照相同的顺序来加锁的，但事实上，加锁的顺序取决于传入参数的顺序。<br>A: transferMoney(myAccount, yourAccount, 10);<br>B: transferMoney(yourAccount, myAccount, 20);</p>
<p>要解决上面的问题，则一定要定义锁的顺序。比较直观的，就是在要加锁的所有参数上做一个排序。可以使用System.identityHashCode方法，该方法返回Object.hashCode的返回值。</p>
<p>下边是一个经典的解决方法<br><figure class="highlight java"><figcaption><span>通过合理顺序来避免死锁</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(<span class="keyword">final</span> Account fromAcct, <span class="keyword">final</span> Account toAcct, DollarAmount amount)</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAcct.debit(amount);</span><br><span class="line">                toAcct.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</span><br><span class="line">    <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fromHash &lt; toHash) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(toAcct) &#123;</span><br><span class="line">                <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(fromAcct) &#123;</span><br><span class="line">                <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(tieLock) &#123; <span class="comment">// 极少数情况下，两个对象可能有相同的HashCode，通过一个‘加时赛’锁，保证每次只有一个线程会处理这种情况，避免死锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(toAcct) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="协作对象之间发生死锁"><a href="#协作对象之间发生死锁" class="headerlink" title="协作对象之间发生死锁"></a>协作对象之间发生死锁</h4><p>有些获取多个锁的操作并不像之前的例子那么明显，两个锁可能不是在同一个方法中被获得的。在持有所锁的情况下调用外部的方法，需要警惕死锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeadLock！ Don't do this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispather)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispather = dispather;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        <span class="keyword">if</span>(location.equals(destination))</span><br><span class="line">            dispathcher.notifyAvaiable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis.add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span>(Taxi t: taxis) </span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管没有任何方法会显示的获取两个锁，但是setLocation和getImage等方法的调用者都会获得两个锁。但是他们的顺序是相反的。所有可能产生死锁。</p>
<p>如果在持有锁的情况下调用外部方法，那么有可能会出现活跃性问题。如果这个外部方法去获得其他的锁，或者阻塞时间过长，那么会导致其他的线程无法获得当前被持有的锁。</p>
<p>解决方法。调用这种依赖外部方法的函数时，使用开放调用。也就是不对整个方法使用synchronized，而是对需要涉及共享状态的操作加锁，来保证加锁的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeadLock！ Don't do this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> reachedLocation;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.location = location;</span><br><span class="line">            reachedLocation = location.equals(desitination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(reachedLocation)</span><br><span class="line">            dispathcher.notifyAvaiable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis.add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;Taxi&gt; copy;</span><br><span class="line">        sychronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">           copy  = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</span><br><span class="line">        &#125;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="keyword">for</span>(Taxi t: taxis)</span><br><span class="line">            image.drawMarker(t.getLocation());</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用开放调用，更容易分析加锁顺序，找出死锁的可能性。</p>
<p>有时候，把原来的同步代码块用开放调用的形式重写后，会发生一些意想不到的结果。因为可能会失去一些原子性。多数情况可以接受失去原子性。而某些情况下，失去原子性会引发错误。这需要通过一些调用的协议，而非加锁来解决。</p>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><p>例如几个服务需要两个数据库连接来完成任务，而数据库连接池很小，会发生资源死锁。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果一个程序在执行每个任务时只能获得一个锁，那么永远都不会产生因为锁顺序引起的死锁。当然这样并不现实。<br>如果必须获得多个锁，那么在设计时一定要考虑锁的顺序问题：减少潜在的加锁交互的数量，将获取锁时需要遵循的协议写入文档。<br>在使用细粒度的加锁时，首先找出什么地方会获得多个锁，然后进行全局分析，确保顺序一致。<br>尽可能的使用开放调用，这可以简化分析过程。</p>
<p>可以使用指定超时时限的锁，tryLock，超时后会返回一个失败信息。可以记录这个失败信息，然后进行分析，或者可以retry。<br>通过JVM的Thread Dump来帮助识别死锁的发生。Dump的信息包括运行中的各个线程的栈信息，还包括加锁信息，例如每个线程持有哪些锁，在那些被阻塞的线程正在等待哪个锁。</p>
<p>在Unix平台上出发Thread Dump，是向JVM进行发送SIGQUIT信号(kill-3)，或者Ctrl-\按键。Windows下Ctrl-Break。</p>
<h3 id="其他的活跃性问题"><a href="#其他的活跃性问题" class="headerlink" title="其他的活跃性问题"></a>其他的活跃性问题</h3><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>最多的例子是因为优先级问题，有些任务永远得不到执行。<br>尽量不去使用线程的优先级。在大多数并发应用中，都可以使用默认的优先级。</p>
<h4 id="响应性"><a href="#响应性" class="headerlink" title="响应性"></a>响应性</h4><p>CPU密集型的后台任务可能会对性能造成影响，因为它们会与事件线程/主线程共同竞争CPU时钟周期。</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>线程中出现了谦让，到这线程之前都无法完成任务，时间都消耗在不断的拿锁，放弃，拿锁，放弃。<br>类似于过独木桥，两个人在桥上遇到后堵住了对方，然后都退后，过相同的时间后双方有重试，周而复始，永远没有人能前进。</p>
<h2 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>想要通过并发来获得更好的性能，需要做好两件事情：</p>
<ol>
<li>更有效的利用现有的计算与处理资源。</li>
<li>在添加了新的计算和处理资源后，尽可能的利用这些新的资源。</li>
</ol>
<p>从性能监测的角度来看，CPU需要一直处于忙碌状态。如果程序无法使现有的CPU保持忙碌，那么再添加新的CPU也没用。</p>
<p>可伸缩性是指当计算资源增加时（CPU，内存，I/O带宽等），程序的吞吐量或者处理能力能够相应的增加。</p>
<p>对于服务器应用来说，“多少”这个方面————可伸缩性，吞吐量，生产量，往往要比“多快”这个方面更受重视。</p>
<h4 id="性能权衡"><a href="#性能权衡" class="headerlink" title="性能权衡"></a>性能权衡</h4><p>在几乎所有的工程决策中都会涉及某些形式的权衡。在建设桥梁时，使用更粗的钢筋可以提高桥的负载能力和安全性，但是也会提高建造成本。在软件工程中谁绕路会涉及资金和人身安全，但是做出正确的权衡时也需要考虑很多方面的信息。<br>不要乱优化。首先要使程序正确，如果运行的还不够快，再去设法提高他的运行速度。<br>在任何与性能相关的决策时，都应该考虑以下问题：</p>
<ol>
<li>怎么理解更快，可以有数字比较吗？</li>
<li>在什么环境和情况下这个方法可以运行的更快？能否有实验数据支持？</li>
<li>这些情况发生的频率有多高？</li>
<li>其他情况下不同环境中能否重用这些代码？</li>
<li>有没有其他隐形的代价？例如开发风险和维护风险？</li>
</ol>
<p>要以测试为基准，不可以猜测。利用现有的成熟的工具，perbar等，可以监测CPU的忙碌程度。</p>
<h4 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h4><p>有些任务并行可以提高效率，有些并不能。</p>
<p>Amdahl定律描述的是，再增加计算资源的情况下，程序在理论上能够实现的最高加速比。F是必须串行与所有任务的比值，N是处理器数量<br><img src="./Amdahl.gif" alt="Amdahl"><br>当N区域无穷大时，最高的加速比时1/F，因此加入有50%的计算需要串行执行，那么最高的加速比是2。</p>
<p>下图可以看出，处理器的利用率在不同串行比例（0.25%，0.5%……）以及处理器数量下的变化曲线。可以明显的看到串行比例对CPU利用率的影响是很大的。<br><img src="./Amdahl-curv.gif" alt="Amdahl-curv"></p>
<p>Amdahl定律的作用，主要是量化当有更多资源时，可以加速的比率。更重要的时对出现的可伸缩性局限有清醒的认识。</p>
<h3 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h3><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>在大多数通用的处理器中，上下文切换的开销相当于5000~10000个时钟周期，也就是几微妙。<br>UNIX系统的vmstat命令和Windows的perfmon工具都能够查看上下文切换次数以及在内核中执行时间所占比例等信息。如果内核占用率较高（超过10%），那么表示调度活动发生的很频繁，可能是由I/O或竞争锁导致的阻塞引起的。</p>
<h4 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h4><p>在synchronized和volatile提供的可见性保证中，会使用一些特殊指令，也就是内存栅栏Memory Barrier，来刷新缓存。内存栅栏时缓存无效刷新硬件的写缓冲。<br>所以内存栅栏可能会对性能带来间接的影响，因为它在抑制一些优化，包括编译器的优化，重排序。<br>现代的JVM能够通过优化来去掉一些不会发生竞争的锁，从而减少不必要的同步开销。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>竞争的同步可能需要操作系统接入，从而增加开销。在锁上发生竞争后，竞争失败的线程肯定会阻塞。JVM在实现阻塞行为时，可以采用自旋等待，或者通过操作系统挂起被阻塞的线程。大多数JVM在等待锁时都是将线程挂起。</p>
<h3 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h3><ol>
<li><p>缩小锁的范围，快进快出，在访问完共享资源后尽快释放</p>
</li>
<li><p>减小锁的粒度，只锁自己需要的资源</p>
</li>
<li><p>锁分段，Lock Striping, 例如ConcurrentHashMap</p>
</li>
<li><p>避免热点域，例如每个操作都会修改一个变量，HashMap的Size方法</p>
</li>
<li><p>使用ReadWriteLock,原子变量来代替独占锁</p>
</li>
<li><p>避免使用对象池</p>
</li>
</ol>
<h2 id="并发程序测试"><a href="#并发程序测试" class="headerlink" title="并发程序测试"></a>并发程序测试</h2><p>由于并发程序有一些不确定性，这和串行程序比，要增加</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/Java并发编程-结构化并发应用程序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Java并发编程-结构化并发应用程序/" itemprop="url">Java并发编程-结构化并发应用程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T09:40:36+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>大多数并发应用程序都是围绕任务执行来构造的。任务，在理想状态下，是一些离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的并行结构来提升工作的并发性。</p>
<h3 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h3><p>当围绕任务执行来设计应用程序的结构时，第一步就是要找到清晰的任务边界。大多数服务器应用程序都提供一种自然的任务边界选择方式：以独立的客户请求为边界。Web服务器，邮件服务器，文件服务器，数据库服务器等。将独立的请求作为任务表边界，既可以实现任务的独立性，又可以实现合理的任务规模。</p>
<h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><figure class="highlight java"><figcaption><span>Serialized Web Server</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket connection = socket.accept();</span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>串行的处理请求，一般来说无法提供高吞吐率或快速的响应。服务器的资源利用率会非常低，多数时间都耗费在IO操作上。</p>
<h4 id="显示的创建线程"><a href="#显示的创建线程" class="headerlink" title="显示的创建线程"></a>显示的创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't do this way</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        whilte(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不停创建线程的缺点"><a href="#不停创建线程的缺点" class="headerlink" title="不停创建线程的缺点"></a>不停创建线程的缺点</h4><ol>
<li>线程生命周期的开销非常高</li>
<li>资源消耗，大量的空闲线程会占用很多内存.</li>
<li>稳定性，OutOfMemoryError<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Executor提供了一种标准的方法把任务提交与任务执行解耦开来。Executor基于生产者消费者模式，提交任务的操作是生产者，执行人物的消费者。<h4 id="例，基于Executor的Web服务器"><a href="#例，基于Executor的Web服务器" class="headerlink" title="例，基于Executor的Web服务器"></a>例，基于Executor的Web服务器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过使用Executor，将请求处理任务的提交与任务的实际执行解耦。只要改变Executor的实现，便可改变任务的执行方式，策略和服务器的行为。<h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4>不同的执行策略，是不同的资源管理方式，最好的策略要根据当时可用的计算资源以及对服务质量的需求而定。<br>通过限制并发线程数量，可以避免程序因为过多的请求而耗尽服务器资源，最终导致失败。或者由于资源短缺，发生竞争，而导致性能问题。<br>把任务提交，与执行策略分离开来，有助于在部署时选择与可用资源最匹配的策略，发挥最大效能。<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4>线程池，管理一组同类型工作线程的资源池。线程池与工作队列密切相关。工作队列保存了所有等待执行的任务。</li>
</ol>
<p>java.util.concurrent.Executors中提供了常用的静态工厂方法，来创建线程池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">newFixedThreadPool(int nThreads)</span><br><span class="line">Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.</span><br><span class="line"></span><br><span class="line">newCachedThreadPool()</span><br><span class="line">Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available.</span><br><span class="line"></span><br><span class="line">newSingleThreadExecutor()</span><br><span class="line">Creates an Executor that uses a single worker thread operating off an unbounded queue.</span><br><span class="line"></span><br><span class="line">newScheduledThreadPool(int corePoolSize)</span><br><span class="line">Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.</span><br></pre></td></tr></table></figure>
<p>其中前三个方法都是对java.util.concurrent.ThreadPoolExecutor这个类的包装使用，而ThreadPoolExecutor实现了ExecutorService接口。</p>
<h4 id="Executor生命周期"><a href="#Executor生命周期" class="headerlink" title="Executor生命周期"></a>Executor生命周期</h4><p>Executor的生命周期有三种状态：运行，关闭，已终止。<br><figure class="highlight java"><figcaption><span>Life cycle management API of ExecutorService</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="title">entends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>; <span class="comment">// Stop accept new request</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>; <span class="comment">// Stop accept, and immediately stop all the executing threads</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// wait until it is terminated.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h4><p>通过使用ScheduledThreadPoolExecutor来执行延迟任务或者周期任务。</p>
<h3 id="可利用并行性"><a href="#可利用并行性" class="headerlink" title="可利用并行性"></a>可利用并行性</h3><p>大多数服务器应用程序，明显的任务边界是每个客户的请求。在单个客户请求中仍可以发掘并发的可能性。</p>
<h4 id="例，串行页面渲染器"><a href="#例，串行页面渲染器" class="headerlink" title="例，串行页面渲染器"></a>例，串行页面渲染器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadRenderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        renderText(source);</span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ImageInfo imageInfo: scanForImageInfo(source))</span><br><span class="line">            imageData.add(imageInfo.downloadImage()); <span class="comment">// During this loop, the CPU is almost in idle state due to I/O, not utilize the resources fully. </span></span><br><span class="line">        <span class="keyword">for</span> (ImageData data: imageData)</span><br><span class="line">            renderImage(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有结果的任务Callable与Future"><a href="#有结果的任务Callable与Future" class="headerlink" title="有结果的任务Callable与Future"></a>有结果的任务Callable与Future</h4><p>Runnable的最大局限在于，他不能返回一个值，或者抛出受检查的异常。<br>Callable是一种更好的抽象。<br>Future表示一个任务的生命周期，可以判断任务是否完成或者已经取消。<br>ExecutorService中的submit方法会返回一个Future。或者可以显示的为某个指定的Runnable或者Callable实例化一个FutureTask，用newTaskFor方法或者其构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceleed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, CancellationException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, CancellationException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>提交Runnable或者Callable时，就是把Runnable从任务提交的线程，安全的发布到最终执行任务的线程，等待执行。<br>同样的在给Future的结果赋值时，也是把结果从计算线程，安全的发布到调用get方法的线程中。</p>
<h4 id="例，使用Future实现页面渲染器"><a href="#例，使用Future实现页面渲染器" class="headerlink" title="例，使用Future实现页面渲染器"></a>例，使用Future实现页面渲染器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = ...;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = <span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">                <span class="keyword">for</span>(ImageInfo imageInfo: imageinfos)</span><br><span class="line">                    result.add(imageInfo.downloadImage());</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;ImageData&gt; imageData = future.get();</span><br><span class="line">            <span class="keyword">for</span>(ImageData data: imageData)</span><br><span class="line">                renderImage(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码把渲染文字与下载图像分开，稍微提升了一点性能。但是问题在于，必须要等所有图像都下载完毕，Future才能完成，才可以渲染图像。<br>我们可以使用CompletionService来更好地利用并行资源。CompletionService把Executor和BlockingQueue的功能融合，可以通过submit来提交Callable，也可以使用take和poll方法，来获得已经完成的任务结果。<br>ExecutorCompletionService的实现也很简单。他需要一个BlockingQueue来保存结果。当提交任务时，我们把任务包装成一个叫QueueingFuture的类，这个类继承FutureTask，并且改写protected的方法done，在这方法中加入把结果放入BlockingQueue的逻辑。当一个计算任务结束时，就调用FutureTask的done方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    QueueingFuture(Callable&lt;V&gt; c) &#123; <span class="keyword">super</span>(c); &#125;</span><br><span class="line">    QueueingFuture(Runnable t, V r) &#123; <span class="keyword">super</span>(t, r); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        completionQueue.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用CompletionService的页面渲染器"><a href="#使用CompletionService的页面渲染器" class="headerlink" title="使用CompletionService的页面渲染器"></a>使用CompletionService的页面渲染器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    Renderer(ExecutorService executor) &#123; <span class="keyword">this</span>.executor = executor; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageImage(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">final</span> ImageInfo imageInfo: info) </span><br><span class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;ImageData&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>, n = info.size(); t &lt; n; t++) &#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                ImageData data = f.get();</span><br><span class="line">                renderImage(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h2><p>把任务和线程安全、快速、可靠的停止下来，不是一件容易的事情。<br>中断是一种协作机制，可以使一个线程种植另一个线程的当前工作。这种协作模式的好处在于，当需要停止时，它们会首先清除当前正在执行的工作，然后在结束。</p>
<h3 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h3><p>取消一个任务的原因有，<br>用户请求取消，例如用户点击了取消按钮；<br>有时间限制的操作，例如超时；<br>应用程序事件，例如算法中可能并行的去计算多个空间，当其中一个得出结果时，可以取消其他的分支；<br>错误，例如写入文件是空间不足会报错；<br>关闭，当程序要关闭时，需要处理正在运行和在等待的任务。</p>
<p>Java中没有一种安全的抢占式的停止方式来终止一个任务线程，而协作模式是更好的一种方式。</p>
<p>一个可取消的任务必须有它的取消策略。这个策略中详细的定义了其他代码如何取消该任务，任务在何时检查是否已经请求了取消，以及响应取消时会执行哪些操作。</p>
<p>一个原始的办法时任务在执行过程中不断的检查一个自定义变量，在被设置后退出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGeneraor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger p = BigIntger.ONE;</span><br><span class="line">        <span class="keyword">while</span>(!cancelled) &#123;</span><br><span class="line">            p = p.nextProbalePrime();</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; cancelled = <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>使用检查自定义变量的方法的问题在于，当执行一个阻塞方法时，例如阻塞队列put方法调用时队列满，就不会再有机会检查到这个标志位。</p>
<p>每个线程都有一个boolean类型的中断状态。当线程中断时，这个线程的中断状态将被设置为true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123; ... &#125; <span class="comment">// 中断目标线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123; ... &#125; <span class="comment">// 返回目标线程是否中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123; ... &#125; <span class="comment">// 清除当前线程的中断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对中断操作的正确理解是，它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由下一个适合的时刻中断自己。<br>使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果调用interrupted时返回了true，那么除非你想屏蔽这个中断，否则一定要处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line"></span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) </span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterrunptedException consumed) &#123;</span><br><span class="line">            <span class="comment">// exit...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; interrupt(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h4><p>中断策略规定线程如何解释某个中断请求————当发现中断请求时，应该做哪些工作，那些工作单元对于终端来说是原子操作，以及以多块的速度来响应中断。<br>最合理的中断策略是某种形式的线程级取消操作或者服务级取消操作：尽快推出，在必要时清理，通知某个所有者该线程已经退出。<br>由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</p>
<h4 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h4><p>当调用可中断的阻塞函数时，有两种使用的策略处理中断异常：</p>
<ol>
<li>传递异常</li>
<li>恢复中断状态</li>
</ol>
<p>如果不想传递或无法传递InterruptedException，那么需要寻找另一种方式来保存中断请求。一个方法就是通过再次调用interrupt来恢复中断状态。<br>只有实现了线程中断策略的代码才可以屏蔽中断请求。常规的任务和库函数代码中都不应屏蔽中断请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 如果在这里恢复中断状态，会引起无限循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(interrupted)</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 在返回前恢复中断状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="例，计时运行"><a href="#例，计时运行" class="headerlink" title="例，计时运行"></a>例，计时运行</h4><p>下面的代码，是一个任意的Runnable在指定时间内运行完成的例子。在调用这个timedRun方法的线程中运行这个任务，并安排了一个取消操作。<br><figure class="highlight java"><figcaption><span>scheduling an Interrupt on a Borrowed Thread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService cancelExec = ...;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread taskThread = Thread.currentThread();</span><br><span class="line">    cancelExec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            taskThread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeout, unit);</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法非常简单，但是破坏了规则，就是在中断线程前，应该了解他的中断策略。因为timedRun可以从任意一个线程中调用，它无法知道这个调用线程的中断策略。如果run方法在超时限制前完成，那么线程中断操作是什么代码我们就不得而知了。反过来，如果任务不响应中断，那么timedRun会在任务结束时才返回。会给调用者带来负面影响。</p>
<h4 id="通过Future实现取消"><a href="#通过Future实现取消" class="headerlink" title="通过Future实现取消"></a>通过Future实现取消</h4><p>将任务提交交给一个ExecutorService，并通过一个定时的get方法获得结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r, <span class="keyword">long</span> timeout, Timeunit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.get(timeout, unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        <span class="comment">// 接下来任务将被取消</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="comment">// 如果在任务中抛出了异常，那么重新抛出该异常</span></span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务已经结束，那么执行取消操作也没有任何负面影响</span></span><br><span class="line">        <span class="comment">// 如果任务正在执行，那么会被中断</span></span><br><span class="line">        task.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h4><p>并非所有的可阻塞方法或者阻塞机制都能响应中断。如果一个线程由于执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置现成的中断状态，除此之外没有其他任何作用。<br>对于由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些县城，但要求我们必须知道线程阻塞的原因。</p>
<ol>
<li><strong>同步的Socket I/O</strong>。虽然InputStream和OutputStream中的read，write都不会响应中断，但是通过关闭底层的Socket，可以使线程抛出一个SocketException。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ignored) &#123;&#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Java.io 中的同步I/O</strong>。Channel会派出AsynchronousCloseException。</li>
<li><strong>异步的Socket I/O</strong>，也是调用close或者wakeup方法。</li>
<li><strong>获取某个锁</strong>。无法响应。但是通过Lock类中提供的lockInterruptibly方法，运行在等待一个锁时仍能响应中断。</li>
</ol>
<h3 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h3><p>包括了LogWrite，LogService，关闭ExecutorService，Poison Pill，等例子。</p>
<h3 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h3><p>任何代码都可能抛出一个RuntimeException。每当调用另一个方法时，都要对他的行为保持怀疑。<br><figure class="highlight java"><figcaption><span>典型的线程池Worker线程结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted())</span><br><span class="line">            runTask(getTaskFromQueue());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        thrown = e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadExited(<span class="keyword">this</span>, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>未捕获异常处理，UncaughtExceptionHandler。</p>
<h3 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h3><h4 id="Shutdown-Hook"><a href="#Shutdown-Hook" class="headerlink" title="Shutdown Hook"></a>Shutdown Hook</h4><h4 id="Daemon-Thread的使用场景与局限"><a href="#Daemon-Thread的使用场景与局限" class="headerlink" title="Daemon Thread的使用场景与局限"></a>Daemon Thread的使用场景与局限</h4><h4 id="避免使用finalize"><a href="#避免使用finalize" class="headerlink" title="避免使用finalize"></a>避免使用finalize</h4><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="在任务与执行策略之间的隐耦合"><a href="#在任务与执行策略之间的隐耦合" class="headerlink" title="在任务与执行策略之间的隐耦合"></a>在任务与执行策略之间的隐耦合</h3><p>包括</p>
<ol>
<li>依赖性任务。两个并行的任务之间有依赖。</li>
<li>使用线程封闭机制的任务。</li>
<li>对时间响应铭感的任务，GUI程序。</li>
<li>使用ThreadLocal的任务。线程池中不该使用。</li>
</ol>
<h3 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h3><p>根据CPU个数，目标使用率等参数决定。<br>ThreadPoolExecutor的设计。</p>
<h2 id="GUI界面的程序"><a href="#GUI界面的程序" class="headerlink" title="GUI界面的程序"></a>GUI界面的程序</h2><h3 id="为什么GUI是单线程的"><a href="#为什么GUI是单线程的" class="headerlink" title="为什么GUI是单线程的"></a>为什么GUI是单线程的</h3><p>因为简单。对线程的GUI系统容易死锁。</p>
<p>当前的GUI框架使用了专门的事件分发线程（Event Dispath Thread, EDT）来处理GUI事件。也就是主线程。</p>
<p>GUI应用程序需要处理一些细粒度的时间，例如点击鼠标、按下键盘或定时器超时等。因为只有单个线程来处理所有的GUI任务，因此会采用串行处理的方式。串行任务处理的不利之处在于，如果某个任务执行的时间很长，那么其他任务必须等到该任务执行结束。<br>在事件线程中执行的任务必须尽快的把控制权交还给事件线程。</p>
<p>短时间的GIU任务和长时间的GUI任务，处理有区别。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/28/Java并发編程基础知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/Java并发編程基础知识/" itemprop="url">Java并发編程实践读书笔记1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T22:07:43+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h2><p>“编写正确的程序很难，而编写正确的并发程序则难上加难。”这句话是《Java并发编程实践》里的第一句话。我很喜欢。</p>
<p>线程是Java语言的重要功能。它将复杂的异步代码变的更容易。</p>
<h3 id="并发的好处"><a href="#并发的好处" class="headerlink" title="并发的好处"></a>并发的好处</h3><ol>
<li>资源利用率, 在IO等待时去做其他的任务来提高资源利用率。</li>
<li>公平。时间片，让不同的用户和程序公平的使用计算资源，而不是一个程序从头跑到尾。</li>
<li>便利性。在同时完成多个任务时，编写多线程能相比于写一个单一线程的程序要简单。</li>
</ol>
<h3 id="线程带来的问题"><a href="#线程带来的问题" class="headerlink" title="线程带来的问题"></a>线程带来的问题</h3><ol>
<li>安全性。 不正确的结果。</li>
<li>活跃性。死锁与饥饿，活锁</li>
<li>性能。响应不及时，频繁的上下文切换开销</li>
</ol>
<h3 id="多线程的应用广泛"><a href="#多线程的应用广泛" class="headerlink" title="多线程的应用广泛"></a>多线程的应用广泛</h3><ul>
<li>JVM本身就是多线程的，主线程main，后台线程垃圾回收，终结操作等。</li>
<li>Servlet， RMI</li>
<li>Swing，AWT</li>
</ul>
<h2 id="线程的安全性"><a href="#线程的安全性" class="headerlink" title="线程的安全性"></a>线程的安全性</h2><h3 id="线程安全性的定义。核心就是正确性。"><a href="#线程安全性的定义。核心就是正确性。" class="headerlink" title="线程安全性的定义。核心就是正确性。"></a>线程安全性的定义。核心就是正确性。</h3><ul>
<li>核心是正确性</li>
<li></li>
<li>线程安全类</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><pre><code>读取 修改 写入的序列。依赖于之前的状态。
</code></pre><ul>
<li>Race condition</li>
<li>延迟初始化的例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't do this</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExpensiveObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>( instance == <span class="keyword">null</span>)</span><br><span class="line">             instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复合操作/原子类<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3>在单个原子操作中更新所有相关变量</li>
<li>内置锁(Intrisic Lock)。Synchronized</li>
<li>重入。获取锁的操作粒度是线程而不是调用</li>
<li>用锁来保护状态<h3 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3></li>
<li>同步块的代码大小分割。分得过细，可能带来开销问题。</li>
<li>分的过大 锁持有时间长。活跃性不好。</li>
</ul>
<h2 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h2><p>编写正确的并发程序，关键在于访问共享的可变状态时，要进行正确的管理。Synchronized关键字除了实现原子性，还有内存可见性。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>   没有同步的情况下 编译器 处理器 运行时 都可能<strong>重排序</strong>。</p>
<ul>
<li>失效数据</li>
<li>非原子的64位操作</li>
<li>加锁与可见性<br><img src="./3-1.gif" alt="Image of visibilty and lock"><br>加锁的含义不仅仅局限于护持行为，还包括内存可见性。</li>
<li>volatile变量<br>volatile变量对可见性的影响比volatile变量本身更为重要。</li>
</ul>
<h3 id="发布、逸出（Escape）"><a href="#发布、逸出（Escape）" class="headerlink" title="发布、逸出（Escape）"></a>发布、逸出（Escape）</h3><p>   发布是指对象能在当前作用于之外的代码中访问使用。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't do this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">"AK"</span>, <span class="string">"AL"</span>, ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123; <span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   如果按照上边的代码发布states，就会出现问题，因为任何调用者都可以修改这个数组的内容。</p>
<ul>
<li>定义。某个不该发布的对象被发布。</li>
<li>对象逸出后必须假定外部会误用该对象。</li>
<li>封装能够简化程序的正确性分析。</li>
<li>this隐式逸出，引用一个未构造完的对象。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't do this</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerLisenter(</span><br><span class="line">            <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                    doSomething(e); <span class="comment">// source may use 'this' before constructor finished.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用私有构造函数+工厂方法来避免逸出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listerner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><ul>
<li>adhoc线程封闭。维护线程的封闭性完全由程序去实现。非常脆弱。</li>
<li>栈封闭。有点functional的感觉 线程之间独立。</li>
<li>ThreadLocal类。为每个使用该变量的线程都存储一个独立的副本。</li>
</ul>
<h3 id="不变性（Immutable）"><a href="#不变性（Immutable）" class="headerlink" title="不变性（Immutable）"></a>不变性（Immutable）</h3><p>   不变性的条件</p>
<ul>
<li>对象创建后其状态就不能修改</li>
<li>对象所有的域都是final类型</li>
<li>对象是正确创建的。this没有在构造期间逸出</li>
<li>final域</li>
<li>用volatile类型来发布不可变对象</li>
</ul>
<h3 id="安全发布，针对可变对象"><a href="#安全发布，针对可变对象" class="headerlink" title="安全发布，针对可变对象"></a>安全发布，针对可变对象</h3><ul>
<li>不正确的发布，会使正确的对象被破坏。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n != n)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果上边的Holder类没有被正确发布，那么另一个线程调用assertSanity就可能会抛出AssertionError。问题不在Holder本身，而在于Holder没有被正确的发布。如果n是final类型，那么没有问题。<br>Object的构造函数会在Holder构造函数运行前先将默认值写入n，也就是0.因此默认值可能被视为失效的。</li>
<li>任何线程都可以在不需要额外同步的情况下安全的访问不可变对象。</li>
<li>安全发布的常用模式。<br>（首先对象构造要正确，也就是this没有逸出。）<br>在静态出书画函数中初始化对象的引用<br>将对象引用保存到volatile类型的域<br>将对象引用保存到某个正确构造对象的final域<br>将对象引用保存到一个由锁保护的域中</li>
<li>事实不可变对象</li>
<li>可变对象 需要同步或者线程安全的方式来发布以及修改可变对象</li>
<li>安全的共享对象</li>
</ul>
<h2 id="对象组合"><a href="#对象组合" class="headerlink" title="对象组合"></a>对象组合</h2><h3 id="如何设计线程安全的类？如何判断一个类是否是线程安全的？"><a href="#如何设计线程安全的类？如何判断一个类是否是线程安全的？" class="headerlink" title="如何设计线程安全的类？如何判断一个类是否是线程安全的？"></a>如何设计线程安全的类？如何判断一个类是否是线程安全的？</h3><ol>
<li>分析构成对象的状态的所有变量；分为基本类型和引用类型，被引用对象的域。例如LinkedList的状态就包括该链表中所有节点的对象的状态。</li>
<li>约束状态的不变条件；例如最大值最小值等独立限制。</li>
<li>可变状态的并发访问管理策略。也就是同步策略，对其状态的访问操作进行协同。</li>
</ol>
<h3 id="设计线程安全类的步骤"><a href="#设计线程安全类的步骤" class="headerlink" title="设计线程安全类的步骤"></a>设计线程安全类的步骤</h3><ol>
<li>收集同步需求<br>final类型的域使用的越多，就能简化对象可能状态的分析过程。<ul>
<li>首先确保不可变条件不会破坏。例如一个计数器一定是正数。</li>
<li>后验条件。例如Counter的当前状态是17，那么下一个有效状态只能是18。</li>
<li>状态转换的约束，需要复合操作。只适用于下一个状态需要依赖当前状态的情况。</li>
</ul>
</li>
<li>依赖状态的操作<ul>
<li>某个操作中包含有基于状态的先验条件。例如删除元素前，队列必须是非空。</li>
<li>简单的方法是使用现有的类库，例如阻塞队列，信号量等。</li>
</ul>
</li>
<li>状态的所有权<ul>
<li>所有权和封装性相关联。对象封装他拥有的状态，即对他封装的状态有所有权。封装的好，则分析起来简单。</li>
<li>如果发布了某个可变状态的引用，则不再拥有独占的控制权。</li>
<li>容器类通常表现出所有权分离的形式。</li>
</ul>
</li>
</ol>
<h3 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h3><p>针对非线程安全的对象，要使用别的招数来让它安全。</p>
<ol>
<li>当一个对象被封装在一个类里，那么能够访问这个对象的所有代码都是已知的。更易于分析。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        mySet.add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsPerson</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySet.contains(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实例封闭是构建线程安全类的一个最简单方式。</li>
<li>Java类库中线程封闭实例。Collections.synchronizedList。</li>
</ol>
<h3 id="线程安全性的委托"><a href="#线程安全性的委托" class="headerlink" title="线程安全性的委托"></a>线程安全性的委托</h3><p>大多数对象都是组合对象。如果类中的各个组件都已经是线程安全的，是否需要再额外的加一个线程安全层要视情况而定。<br>不可变类一定时线程安全的。<br>CopyOnWriteArrayList是一个线程安全的链表。</p>
<h3 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h3><p>通过继承扩展方法比直接将代码添加到类中更脆弱，因为现在的同步策略实现被分不到多个单独维护的源代码文件中。</p>
<h4 id="客户端加锁"><a href="#客户端加锁" class="headerlink" title="客户端加锁"></a>客户端加锁</h4><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><h3 id="将同步策略文档化"><a href="#将同步策略文档化" class="headerlink" title="将同步策略文档化"></a>将同步策略文档化</h3><p>客户以及维护人员可以了解线程安全方面的策略。</p>
<h2 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h2><h3 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h3><h4 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h4><p>同步容器类包括Vector和Hashtable… 这些类实现线程安全的方法是将它的状态封装起来，并且对public方法同步，所以每次都只有一个线程能访问。</p>
<p>问题在于复合操作，包括迭代，跳转，条件计算（如putIfAbsent）。我们在自定义符合操作时，要知道要在哪个对象上加锁。</p>
<h4 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h4><p>要想避免出现ConcurrentModificationException，就必须在迭代过程持有容器的锁</p>
<h4 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h4><p>例子：隐式调用集合类Set的toString方法会出发调用迭代器</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>粒度更细的加锁机制，称为分段锁（Lock Striping）。可以在并发环境下实现更高的吞吐量。</p>
<p>ConcurrentHashMap返回的迭代器如有弱一致性，意思就是容忍并发的修改。size返回的结果是一个估计值。</p>
<p>size与isEmpty的弱一致性换得了其他更重要操作的性能。</p>
<h5 id="额外的原子Map操作"><a href="#额外的原子Map操作" class="headerlink" title="额外的原子Map操作"></a>额外的原子Map操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V newValue)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>每次修改时都会创建并重新发布一个新的容器的副本。</p>
<p>仅当迭代操作远远多于修改操作时，才应该使用CopyOnWrite容器。适用于事件通知系统，因为多数情况下，注册和撤销注册listener的操作要远远少于接受事件通知的操作。</p>
<h3 id="阻塞队列和生产者-消费者模式"><a href="#阻塞队列和生产者-消费者模式" class="headerlink" title="阻塞队列和生产者-消费者模式"></a>阻塞队列和生产者-消费者模式</h3><p>生产者消费者·模式能简化开发过程，因为它消除了生产者和消费者类之间的代码依赖性。</p>
<p>BlockingQueue简化了生产者消费者设计的实现过程，它支持任意数量的生产者消费者。一种常见的例子就是线程池和工作队列的组合，Executor任务执行框架中就体现了这种模式。阻塞特点，让编码更为简单。</p>
<p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具，他们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下更加健壮。</p>
<p>BlockingQueue的实现包括LinkedBlockingQueue, ArrayBlockingQueue, PriorityBlockingQueue.</p>
<p>SynchronousQueue是一个特殊的实现，实际上它不是一个真正的队列，因为它不会为队列中的元素维护空间。它维护一组线程，这些线程在等待着把元素加入或移除队列。由于是线程直接交付数据，put和take会一直阻塞。</p>
<h3 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h3><p>阻塞方法的执行线程在被阻塞后，必须等待某个不受他控制的事件发生后才能继续执行。<br>BlockingQueue的put和take方法会抛出Checked Exception，InterruptedException，这与类库中其他的一些方法做法相同，例如Thread.sleep。当某个方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这个方法被中断，那么他将努力提前结束阻塞状态。</p>
<p>当一个方法调用了阻塞方法时，他本身也变成了阻塞方法，并且必须要处理中断响应。一般有两种处理方式，一是传递，二是恢复中断。</p>
<h3 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h3><h4 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h4><p>CountDownLatch</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><h4 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h4><h4 id="栅栏-CyclicBarrier"><a href="#栅栏-CyclicBarrier" class="headerlink" title="栅栏 CyclicBarrier"></a>栅栏 CyclicBarrier</h4><h3 id="构建高效且伸缩的结果缓存"><a href="#构建高效且伸缩的结果缓存" class="headerlink" title="构建高效且伸缩的结果缓存"></a>构建高效且伸缩的结果缓存</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/Javascript异步编程2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/Javascript异步编程2/" itemprop="url">Javascript异步编程2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T12:39:37+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><h3 id="Generator-介绍"><a href="#Generator-介绍" class="headerlink" title="Generator 介绍"></a>Generator 介绍</h3><p>我们可能都不自觉的有一个认识，那就是JavaScript的函数有一个特点，run to completion。意思是说在一个时间点，只会有一个函数在运行。当这个函数运行结束前，没有任何一个外部函数可以从外部抢占执行的权利。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">Generator</a>是在ES6引入的。Generator函数可以在执行的过程中让出执行的机会，自己暂停下来。在需要的时候，外部主动调用Generator的next方法继续执行剩下的部分。<br>可以参考<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">阮一峰博客</a>。这里先给一个简单的代码示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line">it.next(); <span class="comment">// hello</span></span><br><span class="line">it.next(); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><br>创建一个Generator需要用<strong>function*</strong> 的关键字，以区别于普通的function定义。还有一个新的关键字是<strong>yield</strong>。它的功能就像我们的播放器上的暂停按钮一样，暂停了Generator函数的执行。注意，Generator函数暂停的点是由函数定义的时候制定好的。外部无法主动地去设置Generator停在哪一行。我们把这个叫Coorperate concurrency，而不是Preemptive concurrency。Preemptive意思就是抢占式的。在调用gen()时，只是创建一个generator对象，函数并没有开始执行。调用Generator产生一个iterator，iterator就是用来遍历数据的。我们在第8行调用next函数，这个Generator由暂停状态变为执行状态，等到运行到yield的时候，这个Generator再次变为暂停状态。第9行再次调用next，函数继续执行。</p>
<h3 id="Generator-消息"><a href="#Generator-消息" class="headerlink" title="Generator 消息"></a>Generator 消息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value: 1, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: 2, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value: undifined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们之前的例子yield没有返回任何值，那么他返回的就是undifined。上边这个例子中我们yield反回了1,2,3，可以看出，<br>yield 1时，也就是我们的第9行执行的时候，返回了value为1，done为false的object。yield 2时，执行第10行，返回了value为2，done为false的object。<br>yield 3时，执行第11行，返回了value为2，看起来我们的Generator没有其他可以再执行的了，但是这个Generator还没有还行完毕，所以我们的done还是false。<br>当执行最后一次next时，我们才得到done为true，value是undefined。那么undefined是哪里来的呢？这是因为所以得JavaScript函数如果没有return语句的话，那么返回值就是undefined。如果我们的Generator最后return返回了一个值，例如42，那么这里的值就是value:42, done: true。<br>ES6引入了for of循环，来遍历任何一个iterator。所以我们可以用一个循环来执行Generator，直到到结束。</p>
<p>以下内容可能产生不适。。因为如果从来没有用过generator的话会很不习惯。我们先定义一个generator的执行器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coroutine</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = g();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.next.apply(it, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>coroutine函数其实就是一个generator的wrapper，第2行我们把传入的generator直接初始化，每当我们的调用由coroutine返回的函数时，其实就是调用generator的next函数。</p>
<p>下面看这个代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> run =  coroutine(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span>);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span> + (<span class="keyword">yield</span>);</span><br><span class="line">    <span class="keyword">yield</span> (x + y);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line">run(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Meaning of life: "</span> + run(<span class="number">30</span>).value);</span><br></pre></td></tr></table></figure><br>我们调用coroutine来包装起来我们的generator函数，返回一个run方法，初始化这个generator。每一次调用run都是在调用next方法。</p>
<p>第7行调用run，开始执行generator，运行第2行，执行语句var x = 1 +, 然后我们遇到了yield。generator要暂停，把执行权返回到第8行。generator只有等待外部的输入值时才可以继续计算完这个表达式。第7行，我们继续调用run，也就是next，传入10，完成第一个表达式的计算的到x=11;generator继续执行var y = 1 +,我们遇到yield，让出执行权到第8行。run(30), 将30传入generator，完成y的计算y=31,generator继续执行，yield（x+y），generator暂停，把42作为value传出去。</p>
<p>从generator外部看，也就是第7行开始，我们每运行一次next，就会暂停下来，把值传入到generator，让generator继续运行到下一个yield的地方。<br>从generator内部看，每一次yield，其实是generator缺少一个依赖的值，不能继续计算，而暂停下来。只有等待外部的传入的值和继续执行的信号，才能继续。<br>每一个yield，可以理解为，我这个地方需要一个value，我会一直等待，直到有人在外边给我传入一个值。 </p>
<h3 id="异步Generator"><a href="#异步Generator" class="headerlink" title="异步Generator"></a>异步Generator</h3><p>我们改造一下上边的例子，做一个异步的Generator<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; run(d); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> run = coroutine(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">var</span> answer = (<span class="keyword">yield</span> getData(<span class="string">"Meaning of life: "</span> + (x + y)));</span><br><span class="line">    <span class="built_in">console</span>.log(answer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure></p>
<p>先看getData方法，我们注册一个timeout，从而异步的在第2行调用run方法，让generator继续执行。<br>我们在generator里，yield了一个表达式，也就是getData。在执行var x = 1 + (yield getData(10))时，generator暂停，把执行权交给外部，同时getData开始运行。当getData中的回调函数运行，执行run，传入10，这样让generator继续完成表达式的计算，x=11。继续执行下一行var y = 1 + (yield getData(30)),遇到yield暂停，并且执行getData(30)。同样等timeout的回调执行时，把30传回generator，继续完成y的计算，y=41;同理下一行计算answer，yield暂停，等timeout回来再继续完成计算。最后console输出。</p>
<p>在上边这个例子的generator中我们的代码看上去是同步的，背后的getData是异步的。这样的代码结构跟我们的思维方式是一样的，代码可读性增强了很多，比之前的promise还要好。</p>
<h3 id="Promise-and-Generator"><a href="#Promise-and-Generator" class="headerlink" title="Promise and Generator"></a>Promise and Generator</h3><p>我们之前的代码中还是有一些缺点。就是我们的run方法被放在了callback中执行，这就是inversion of control。程序继续的调用的控制不够清晰。<br>而且我们之前的代码中yield都是undifined。所以我们考虑能不能yield一个promise，也就是让getData返回一个promise，等这个promise完成时，也就是getData完成时，调用Generator的next方法继续执行。等到下一个语句再yield另一个promise，等promise完成继续调用next，如此下去，等到next返回done为true时，也就是我们的generator执行完毕的时候。<br>后边的流程很像递归。也是一个跟业务逻辑无关的流程控制器。外边的lib有很多开源实现，就是一个返回promise的generator的执行器。下边的代码是我自己随意实现了的一个执行器，里边没有包含出错处理这方面的代码，只是为了给出一个大概的样子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">         setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; resolve(d); &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">var</span> answer = (<span class="keyword">yield</span> getData(<span class="string">"Meaning of life: "</span> + (x + y)));</span><br><span class="line">    <span class="built_in">console</span>.log(answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> next = it.next(value);</span><br><span class="line">    <span class="keyword">if</span>( next.done )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next.value.then(handleNext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleNext();</span><br></pre></td></tr></table></figure><br>我们把这个通用的执行器<strong>runner</strong>方法提出来以后也可以用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runner</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = gen();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> next = it.next(value);</span><br><span class="line">        <span class="keyword">if</span>( next.done )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next.value.then(handleNext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Generator练习"><a href="#Generator练习" class="headerlink" title="Generator练习"></a>Generator练习</h3><p>还是之前的情景，我们来思考一下用Generator是怎么解决的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		fakeAjax(file,resolve);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request all files at once in</span></span><br><span class="line"><span class="comment">// "parallel" via `getFile(..)`.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Render as each one finishes,</span></span><br><span class="line"><span class="comment">// but only once previous rendering</span></span><br><span class="line"><span class="comment">// is done.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p1 = getFile(<span class="string">"file1"</span>);</span><br><span class="line">    <span class="keyword">var</span> p2 = getFile(<span class="string">"file2"</span>);</span><br><span class="line">    <span class="keyword">var</span> p3 = getFile(<span class="string">"file3"</span>);</span><br><span class="line">    output(<span class="keyword">yield</span> p1);</span><br><span class="line">    output(<span class="keyword">yield</span> p2);</span><br><span class="line">    output(<span class="keyword">yield</span> p3);</span><br><span class="line">    output(<span class="string">'completed'</span>);</span><br><span class="line">&#125;</span><br><span class="line">runner(gen);</span><br><span class="line"></span><br><span class="line"><span class="comment">//use map</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promises = [<span class="string">"file1"</span>, <span class="string">"file2"</span>, <span class="string">"file3"</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">fname</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFile(fname);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(p <span class="keyword">of</span> promises)&#123;</span><br><span class="line">        output((<span class="keyword">yield</span> p));</span><br><span class="line">    &#125;</span><br><span class="line">    output(<span class="string">'completed'</span>);</span><br><span class="line">&#125;</span><br><span class="line">runner(gen);</span><br></pre></td></tr></table></figure>
<p>有了之前的例子，这里的的示例代码更容易写出来，其实就是利用Promise和Generator，我们的解也分为用普通的流程和用list的map和循环来写。<br>可以看出来这样的代码更为清晰易懂，比之前用promise解决可读性更胜一筹。</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><h3 id="Events-and-promises"><a href="#Events-and-promises" class="headerlink" title="Events and promises"></a>Events and promises</h3><p>前端的代码中的并发，异步，我们之前也说过，核心问题是流程控制的管理。比如之前说过的promise，处理的是单个请求和单个回复的情况。<br>如果我们要处理一个消息流，也就是连续不断地同类event，该如何？Promise还能胜任吗？<br>而且我们在编程中大部分要出里的异步问题，是面向event stream的。在UI中的，用户的操作，比如点击;服务器发来的数据处理，都是面向event的。在这种情况下我们把promise套如，可能会有些问题。<br>举个例子，我的页面上可能有一些处理用户点击的代码。我想记录一些btn点击的log。我知道promise怎么创建，套用到这个情景中应该是这样的，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, rejct</span>)</span>&#123;</span><br><span class="line">    $(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> className = evt.target.className;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/foobar/</span>.test(className))&#123;</span><br><span class="line">            resolve(className);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(className);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可是上面的代码有一个问题，就是promise只能resolve一次。我创建了一个promise，但是只能响应一次用户点击。我们之前介绍了那么多工具，promise，generator的高级工具，可是遇到这个最最常见的情景，好像不是很好使。我们该怎么办？</p>
<p>可能你会这么想，我反一下，把promise的创建搬到event的listener里边，如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> className = evt.target.className;</span><br><span class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/foobar/</span>.test(className))&#123;</span><br><span class="line">            resolve(className);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(className);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>我们每次在click的callback中都创建一个新的promise，这样就可以每次都resolve了。这样看起来挺不错，可是，我们为什么要这样做？这与我们一开始的callback hell不是一样了吗？我们立即resolve了一个promise，并且调用了then。我们之前的代码还可以在一个地方设置好我的消息源，而在我程序的另外一个地方处理这个消息。现在全部都回到了一起，我们把两个不同的任务混在了一个地方。</p>
<p>其实问题在于我们的promise并不是特别适合于一个面向event的环境。我们需要更好地工具。我们需要把两个任务分开，也就是消息源的设置，以及消息的处理。</p>
<h3 id="Observables"><a href="#Observables" class="headerlink" title="Observables"></a>Observables</h3><p>现在的Obserable还不是JavaScript原生支持的。也就是说ES6中没有这个东西，我们都需要用第三方的lib。但未来Observable很可能会成为JavaScript的一部分。现在外部有一个很好的Observable的lib，也就是Rxjs。</p>
<h4 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h4><p>在Excel中，我们知道有计算单元格这个东西。就是说有些单元格的数据是通过计算其他源单元格的数据得到的。例如求和，求平均值，甚至更复杂的计算。当源数据发生改变的时候，这些计算单元数据也会相应的变化。假如我们的源数据被多个计算单元格依赖，那么就会触发所有这些计算单元格的更新。源数据单元的变化可能有好多次，变化的事件就像流一样。而依赖这个数据源的计算单元格都需要订阅这个<strong>变化</strong>，并且执行相应的步骤来更新自己的数据。</p>
<p>Observable或者Reactive Programming（响应式编程）就是类似的概念。Observable是一个事件的转换器，它连接在事件的源上边，每一次有一个新的事件发生，它就产生一个新的promise。重点在于，我可以在一个地方设置好这个转换器，而在程序的另一个地方甚至多个不同的地方，再定义如何处理这个事件流。我们不用和之前举得反例一样把事件的订阅初始化代码和处理代码放在同一个地方。</p>
<h4 id="Rxjs例子"><a href="#Rxjs例子" class="headerlink" title="Rxjs例子"></a>Rxjs例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obsv = Rx.Observable.fromEvent(btn, <span class="string">"click"</span>);</span><br><span class="line"></span><br><span class="line">obsv</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> evt.target.className;</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span> <span class="title">filterer</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/foobar/</span>.test(className);</span><br><span class="line">    &#125;)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> className = data[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(className);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>例子中的第一行我们创建了一个Observable，使用了Rx.Observable.fromEvent这个常用的工具。它可以把一个dom元素上的事件变成一个Observable。Rxjs还有很多强大的工具可以使用。<br>在程序的其他地方，我可以定义我想如何处理这个事件流。这里的map和filter等等，都是Observable的工具，用来对这个事件流进行一些转换和处理，也是十分易于理解使用。最后调用subscribe，来操作转换好的事件。我们就好像定义好了一系列的步骤来处理这个流过来的事件一样。我们把Observable甚至可以当做数组一样对待，数组其实也是一个数据流。</p>
<p>这里比较有意思的一个工具是distinctUntilChanged，这个是说加入现在连续来了5个event，都是hello，那么只有第一个可以进入下一步，其他4个都被过滤，因为重复了。然后来了连续的5个world，那么只有第一个world可以流入下一步。这是distinct的意思。那么接着，又来了5个hello，那么还是只有第一个hello可以通过。这是untilchanged的意思。</p>
<p><a href="http://rxmarbles.com/" target="_blank" rel="noopener">RxMarbles</a>有一个很好的这些工具的图示化介绍。</p>
<h3 id="Rxjs常用工具"><a href="#Rxjs常用工具" class="headerlink" title="Rxjs常用工具"></a>Rxjs常用工具</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From an event</span></span><br><span class="line">Rx.Observable.fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'button'</span>), <span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// From array of values</span></span><br><span class="line">Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// From one or multiple values</span></span><br><span class="line">Rx.Observable.of(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Externally produce new events.</span></span><br><span class="line"><span class="keyword">var</span> myObservable = <span class="keyword">new</span> Rx.Subject();</span><br><span class="line">myObservable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br><span class="line">myObservable.next(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge Observables</span></span><br><span class="line"><span class="comment">// Creates an output Observable which concurrently emits all values from every given input Observable.</span></span><br><span class="line"><span class="keyword">var</span> observable1 = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> observable2 = Rx.Observable.interval(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> merged = Rx.Observable.merge(observable1, observable2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zip</span></span><br><span class="line"><span class="comment">// Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.</span></span><br><span class="line"><span class="keyword">let</span> age$ = Observable.of(<span class="number">27</span>, <span class="number">25</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> name$ = Observable.of(<span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Beer'</span>);</span><br><span class="line"><span class="keyword">let</span> isDev$ = Observable.of(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">Observable</span><br><span class="line">    .zip(age$,</span><br><span class="line">         name$,</span><br><span class="line">         isDev$,</span><br><span class="line">         (age, name, isDev) =&gt; (&#123; age, name, isDev &#125;))</span><br><span class="line">    .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<h3 id="Observable练习"><a href="#Observable练习" class="headerlink" title="Observable练习"></a>Observable练习</h3><p>这次是一个新的的练习。需求是对页面上的btn点击行为进行采样。注意不是debounce，同一个btn在短时间内点击多次，例如每一秒内，我只响应一次点击。<br>我在下面的codepen中，已经引用了jQeury和Rxjs。有兴趣的可以打开试着写一写。<br> <iframe id="cp_embed_eygMWK" src="//codepen.io/guoyongxin/embed/eygMWK?height=300&theme-id=theme&slug-hash=eygMWK&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe></p>
<p>有人可能会考虑用zip来解决这个问题，但是zip其实不能完成采样的任务。那样的话，我们的clicks的队列会不断地增长，而不是真正的采样。我在下边给出两份参考代码<br>Solution1：<br>  <iframe id="cp_embed_ZvLpNQ" src="//codepen.io/guoyongxin/embed/ZvLpNQ?height=300&theme-id=theme&slug-hash=ZvLpNQ&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe></p>
<p>Solution2:<br>  <iframe id="cp_embed_OzWvrm" src="//codepen.io/guoyongxin/embed/OzWvrm?height=300&theme-id=theme&slug-hash=OzWvrm&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe></p>
<p>可以看出来Rxjs中的工具还是非常的多和实用的。我这里是抛砖引玉，更多的内容都在官网上有。掌握或者了解Rxjs的各种工具的适用场景，我认为是成为一个合格的Reactive Programmer的基本。</p>
<p>我在刚刚接触Observable的时候，也是理解了好几次，特别是event stream。看官方的文档，资料，也看了几次。看多了用多了也就有一些感觉，代码的质量也就能提升。</p>
<p>我们的工具箱中又多了一个工具。没有任何一个工具是万金油。不同的场景有不同的合适的方法，对每个的特点都理解，不要用的太死板是我们的该做到的。</p>
<h2 id="CSP-Communicating-Sequential-Processes-Channels"><a href="#CSP-Communicating-Sequential-Processes-Channels" class="headerlink" title="CSP (Communicating Sequential Processes)/ Channels"></a>CSP (Communicating Sequential Processes)/ Channels</h2><p>CSP的目的是用Channel来设计并发程序。和我们之前所介绍的各种方法一样。</p>
<p>CSP的提出在<a href="http://www.usingcsp.com/cspbook.pdf" target="_blank" rel="noopener">这里</a>，说实话我也没怎么看过这篇文章，作者Hoare现在仍在更新CSP的理论。CSP的理念在Go语言和Clojure Script中使用的很多</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>那么Channel是什么？Channel有些像Stream，也类似于管道Pipe。如果了解Actor模型的话（<a href="https://doc.akka.io/docs/akka/2.5.5/scala/actors.html" target="_blank" rel="noopener">Scala中大量使用的并发模型</a>），Channel确实和Actor很类似。但Channel有一个重点在于，默认情况下他没有缓冲区，因此Channel自然有了这样一个特点就是，反向压力（Back Pressure）。举个生活中的例子，我拿着水管接在水龙头上边给外边的花草浇水，我打开洒水口的开关就行了;当我浇完了我直接把洒水口的开关关掉就行了，我并不需要告诉源头我要开还是要关，我只需要操作我手边的开关就可以了。这是反向的从消费者到生产者的一个交流，告诉上边的生产者说，我不需要水了。Channel的Back Presse，也就是说Channnel的send动作是阻塞的。只有当Channel在另一方，调用了取消息take后，才会解除阻塞，反之亦然。而Actor的send是异步的，也就是非阻塞的。</p>
<p>在我们的程序中，我们有这样的代码，我们的生产者和消费者之间没有直接的联系，因为我们需要这么做，以达到职责清晰，代码的局部性更好。我们需要生产者和消费者之间有一个交流，但是如果我们不想引入一个类似于全局变量的东西，告诉生产者需不需要继续生产，别给我发了。（Rxjs Observable中有Hot Cold）。<br>另外一种设计方式就是用我们的Channel，利用Back Pressure，可以做到，你不能往Channel放更多地东西，直到我准备好了可以继续取;你不能继续取东西，直到我可以再往里边放东西。</p>
<p>我们提到了阻塞，你可能会联想到JavaScript唯一有阻塞功能的工具，就是我们刚才讲过的Generator函数。确实如此，CSP的JavaScript版本需要用到Generator。</p>
<p>看点代码吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = chan();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">process1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> put(ch, <span class="string">"hello"</span>); <span class="comment">// 1. put hello into ch and pause proc1 until someone take it from the ch</span></span><br><span class="line">    <span class="keyword">var</span> msg = <span class="keyword">yield</span> take(ch); <span class="comment">// 2. resume proc1 because someone take hello out, and wait for someone to put something into the ch</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg); <span class="comment">// 3. someone put something into ch to let proc1 to resume.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">process2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="keyword">yield</span> take(ch); <span class="comment">// 1. pause proc2 until someone put something into ch</span></span><br><span class="line">    <span class="keyword">yield</span> put(ch, greeting + <span class="string">" world"</span>); <span class="comment">// 2. resume proc2 because someone has put data in ch, and put data into ch, then pause proc2 again until someone have take that from ch </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"done"</span>); <span class="comment">// 3. resume proc2 because someone take the data from ch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure></p>
<p>chan, put, take我们先当做现有的函数来理解这段代码。我们用到了yield，因为我们需要阻塞或者说暂停我们的函数。 假设proc1和proc2在两个不同的线程运行，他们通过ch就可以协调消费者生产者的运行时交流与相互控制。</p>
<h3 id="Blocking-Channel"><a href="#Blocking-Channel" class="headerlink" title="Blocking Channel"></a>Blocking Channel</h3><p>再看一个例子，我们用了一个csp的lib，里边用到了go函数，因为是模仿了Go语言的方式调用类似线程运行的功能。csp.timeout返回一个channel，而我们并不需要关心这个channel到底在哪，我们只需要知道过500ms他会在里边放一个消息，让我们的yield的地方继续执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = chan();</span><br><span class="line"></span><br><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> csp.put(ch, <span class="built_in">Math</span>.random()); <span class="comment">// repeately put random number in ch, pause when blocking</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">yield</span> csp.take( csp.timeout(<span class="number">500</span>) ); <span class="comment">// wait 500ms</span></span><br><span class="line">        <span class="keyword">var</span> num = <span class="keyword">yield</span> csp.take(ch); <span class="comment">// take data from ch</span></span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>下面的例子alts，功能比较像promise的race。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> msg = <span class="keyword">yield</span> csp.alts(ch1, ch2, ch3);</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>再来一个<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> table = csp.chan();</span><br><span class="line">    </span><br><span class="line">    csp.go(player, [<span class="string">"ping"</span>, table]); <span class="comment">// setup ping 'proc'</span></span><br><span class="line">    csp.go(player, [<span class="string">"pong"</span>, table]); <span class="comment">// setup pong 'proc'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> csp.put(table, &#123;<span class="attr">hits</span>: <span class="number">0</span>&#125;); <span class="comment">// start the game by put msg into channel table</span></span><br><span class="line">    <span class="keyword">yield</span> csp.timeout(<span class="number">1000</span>); <span class="comment">// wait for 1000ms to close the channel table</span></span><br><span class="line">    table.close();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">player</span>(<span class="params">name, table</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ball = <span class="keyword">yield</span> csp.take(table); <span class="comment">// try to get the ball from table</span></span><br><span class="line">        <span class="keyword">if</span>( ball === csp.CLOSED) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(name +  <span class="string">": table's gone"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ball.hits += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">" "</span> + ball.hits);</span><br><span class="line">        <span class="keyword">yield</span> csp.timeout(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">yield</span> csp.put(table, ball); <span class="comment">// put updated ball back to ch</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Event-Channel"><a href="#Event-Channel" class="headerlink" title="Event Channel"></a>Event Channel</h3><p>我们在Observable有一个工具是fromEvent，我们这里用csp的方法设计一个自己的fromEvent。这里用了putAsync，我想从字面也能理解这个是非阻塞的put。我为什么用putAsnc呢，因为这个函数不是一个Generator，而是一个普通的JavaScript函数。putAyns会返回一个promise，当这个put成功是resolve。但是我这里并不关心她什么时候put成功。这里是不是很像我们在Observable中不停地调用next函数？csp与Observable的核心区别在于有Back Pressure。如果Channel数据没有被取走，生产者无法继续往队列里放数据。连续不停地调用putAsync，并不会覆盖Channel的数据，每一个putAsync都会返回promise，他们排着队等待往Channel里放数据。直到有人从Channel中开始取数据时，这个队列才会向前。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromEvent</span>(<span class="params">el, eventType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ch = csp.chan();</span><br><span class="line">    $(el).bind(eventType, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        csp.putAsync(ch, evt);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ch = fromEvent(el, <span class="string">"mousemove"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> evt = <span class="keyword">yield</span> csp.take(ch);</span><br><span class="line">        <span class="built_in">console</span>.log(evt.clientX + <span class="string">","</span> + evt.clientY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="CSP练习"><a href="#CSP练习" class="headerlink" title="CSP练习"></a>CSP练习</h3><p>我认为下面这个练习的情景有些生硬，不是特别适合Channel的场景，没能完全体现出Channel的优势。而且我认为原来培训中的参考答案并不完全正确的。但是还是可以参考一下这个题目吧。需求跟Observable的btn采样是一样的。我给直接给出了我的代码。我们最后还是用到了shouldWrite变量来控制写，而且好像没有更好地办法。</p>
<p>这里我引用了<a href="https://github.com/ubolonton/js-csp/blob/master/doc/basic.md" target="_blank" rel="noopener">js-csp</a>。对于看过Rethinking的，我一直没有使用Trainer的<a href="https://github.com/getify/asynquence" target="_blank" rel="noopener">ASQ</a>库是因为我觉得他的lib东西太多了，什么都可以做，而且使用什么都要在前面加ASQ，看上去有些奇怪。不过他确实很厉害，自己写了这么多工具的实现。</p>
 <iframe id="cp_embed_Ozpbxq" src="//codepen.io/guoyongxin/embed/Ozpbxq?height=300&theme-id=theme&slug-hash=Ozpbxq&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<h3 id="大练习-A-tale-of-three-lists"><a href="#大练习-A-tale-of-three-lists" class="headerlink" title="大练习 A tale of three lists"></a>大练习 A tale of three lists</h3><p>Trainer的这个练习还是很赞的，给出地址<a href="https://github.com/getify/A-Tale-Of-Three-Lists" target="_blank" rel="noopener">git</a>，有兴趣的可以clone下来，用我们讲过的各种工具（Callback, thunk, promise, generator, obserable, csp）都实现以下这个练习。还是很有挑战的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>两篇文章介绍了各种JavaScript异步编程的工具。我的理解是，没有一个万金油可以解决所有的问题。如果你听身边有人说Observable可以解决一切异步编程的问题，或者说CSP可以搞定所有的异步编程设计，那么他一定是过分沉浸在自己的世界了，所谓生搬硬套。我们需要做的就是掌握这个工具箱里的所有工具，在适合的时候拿出来，写出漂亮的代码，解决这个问题。</p>
<p>最后推荐一些我写第二篇时看到的一些有关的好文章的连接</p>
<p><a href="https://juejin.im/entry/56f480ccc4c9710051bffd2b" target="_blank" rel="noopener">https://juejin.im/entry/56f480ccc4c9710051bffd2b</a><br><a href="https://www.zhihu.com/question/26192499" target="_blank" rel="noopener">https://www.zhihu.com/question/26192499</a><br><a href="http://lucasmreis.github.io/blog/quick-introduction-to-csp-in-javascript/" target="_blank" rel="noopener">http://lucasmreis.github.io/blog/quick-introduction-to-csp-in-javascript/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/18/JavaScript异步编程1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/18/JavaScript异步编程1/" itemprop="url">JavaScript异步编程1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-18T12:13:35+08:00">
                2017-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近看了Lynda上的一个课程叫做Rethinking Asynchronous Javascript。 在此写一写整理一下自己的心得。</p>
<h2 id="异步与并发"><a href="#异步与并发" class="headerlink" title="异步与并发"></a>异步与并发</h2><p>其实谈到异步编程我们基本上会讲到并发（Parallel）和异步(Async)。从很高的角度来看，他们说的是同一个事情。然而他们在实际工作中一般各有所指。</p>
<p>从理念上看，并发指的是优化，资源同时的得到执行，加快了时间。比如玩过山车，如果每次只让一个人上车，那么其他人都要等待。如果一次上去30个人，那么这30个人就是同时享受到了服务。从计算机的角度看，那就是线程和多核，内核最终支持多少个线程并发，就是类似于过山车一次可以装多少个人上去。所以说一般谈到并发，讲的是资源的最大利用率和效率的问题，最终让请求或者任务得到快速的响应。</p>
<p>谈到异步，则是从编程的角度来看，其实也就是说的非阻塞。如果说到Javascript中我们最最基本的应该就是Callback了。通常我们会在一段代码中有一些需要XHR或者SetTimeout类似的工作，然后我们可以注册一个Callback，然后在等这个注册的函数在任务完成后执行。然而注册这个Callback并不会影响他之后代码的执行。</p>
<p>传统的Web服务器，例如Apache，是多线程的。每一个用户的请求都会编程一个线程，在服务器端执行，只有在服务器完成了用户请求后才可以返回。这样，如果访问的人越来越多，那么线程也会越来越多。所以并发和多线程在这种设计情景下，就是要最大限度的利用服务器的资源。</p>
<p>有关Javascript，我们都知道JS是单线程的执行的,因为它一开始设计得时候就是为了操作浏览器中的DOM元素，单线程也是最简单的设计。我们也都知道Android和iOS程序所有修改UI的操作都需要在主线程也就是UI线程进行。所以JS一定是顺序执行的。而所有的阻塞操作，都是通过回调的方式进行的。还有一个话题就是JS的Event Loop。这个放一放。<br>Nodejs的服务器是单线程的，因为用了Chrome V8的JS Engine。也是因为js的单线程特性，所以js的代码必须是异步的，也就是说是非阻塞的。如果包含例如文件读写，网络请求等，那么这些操作<br>程都会被这个线程接收，然后转到<em>后台</em>的MicroTask任务执行。线程只负责转发这个任务而不是真正执行。只有当任务完成后，这个线程又会得到消息，再把这个结果返回给用户。这样，这个线程所做的工作就比较简单。</p>
<h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>Callback，不用多说，js最最原始的异步调用方式。每注册一次Callback会产生两片代码区域。他们的执行是异步的。看下边的code中的setTimeout注册了一个回调，一段代码在callback函数外边，包括了doSomething，setTimeout的调用和doOtherThing，另一段代码是setTimeout里的回调函数，console.log。第一段代码不知道第二段代码是否已经执行，何时执行。第二段代码也不会知道第一段代码执行到了哪里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doSomething();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"callback!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">doOtherThings();</span><br></pre></td></tr></table></figure></p>
<h3 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h3><p>下边的代码就是所谓的Callback Hell。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"One"</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Two"</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Three"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><br>Callback Hell，大家都知道的一点叫Indentation Nesting。就是层数越多，缩进越多，代码越难看，越难以维护。<br>其实这个只是表象，我们甚至可以改写上边的代码，如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one"</span>)；</span><br><span class="line">    setTimeout(cb, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"two"</span>)；</span><br><span class="line">    setTimeout(cb, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"three"</span>)；</span><br><span class="line">&#125;</span><br><span class="line">one(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    two(three);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样我们没有之前代码那样的缩进，但是这个代码还是看着很别扭。</p>
<h3 id="一个模拟的实际问题"><a href="#一个模拟的实际问题" class="headerlink" title="一个模拟的实际问题"></a>一个模拟的实际问题</h3><p>再看下边一个稍实际一点例子（之后会继续用这个例子）。<br>需求有三点：</p>
<ol>
<li><em>并行</em>的请求3个文件 </li>
<li>尽快的输出文件内容，但是不要等所有请求都完成再去输出</li>
<li>输出是有顺序的，file1内容先输出，之后file2,最后输出file3</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"><span class="comment">// The old-n-busted callback way</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	fakeAjax(file,<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// what do we do here?</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request all files at once in "parallel"</span></span><br><span class="line">getFile(<span class="string">"file1"</span>);</span><br><span class="line">getFile(<span class="string">"file2"</span>);</span><br><span class="line">getFile(<span class="string">"file3"</span>);</span><br></pre></td></tr></table></figure>
<p>我们该怎么办？因为要满足并发，在代码最后三行我们同时调用了getFile。那么如何让结果及时输出并有序呢？那么一定是在fakeAjax里的回调函数中处理。而我们并不知道每一个请求到底要花多少时间才能返回，所以我们需要在回调函数中通过一些变量或者状态，知道目前这三个请求的状态，才能顺序输出。例如,如果我们file3最先返回了结果，但是file1或者file2还没有返回，那么我们并不能立即输出file3的内容，而要等到file1和file2的内容都已经输出了再输出。所以我们的回调函数中，需要知道几乎所有的事情。那么我们看看我们该怎么做：</p>
<ol>
<li>我们需要定义输出顺序，也就是file1 &gt; file2 &gt; file3。</li>
<li>我们需要知道每一个文件请求结果，以及这个内容是否已经输出过</li>
</ol>
<p>实现参考以下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"><span class="comment">// The old-n-busted callback way</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	fakeAjax(file,<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		fileReceived(file,text);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileReceived</span>(<span class="params">file,text</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// haven't received this text yet?</span></span><br><span class="line">	<span class="keyword">if</span> (!responses[file]) &#123;</span><br><span class="line">		responses[file] = text;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> files = [<span class="string">"file1"</span>,<span class="string">"file2"</span>,<span class="string">"file3"</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop through responses in order for rendering</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;files.length; i++) &#123;</span><br><span class="line">		<span class="comment">// response received?</span></span><br><span class="line">		<span class="keyword">if</span> (files[i] <span class="keyword">in</span> responses) &#123;</span><br><span class="line">			<span class="comment">// response needs to be rendered?</span></span><br><span class="line">			<span class="keyword">if</span> (responses[files[i]] !== <span class="literal">true</span>) &#123;</span><br><span class="line">				output(responses[files[i]]);</span><br><span class="line">				responses[files[i]] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// can't render yet</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// not complete!</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	output(<span class="string">"Complete!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hold responses in whatever order they come back</span></span><br><span class="line"><span class="keyword">var</span> responses = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request all files at once in "parallel"</span></span><br><span class="line">getFile(<span class="string">"file1"</span>);</span><br><span class="line">getFile(<span class="string">"file2"</span>);</span><br><span class="line">getFile(<span class="string">"file3"</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们的回调函数中的逻辑还是比较复杂的。 我们遍历了输出文件顺序的files数组，然后依次查看responses有没有返回信息，以及目前正在遍历到的file有没有被输出过。如果结果还没有返回，那么就退出，把这个输出的调用留到下一个回调函数触发的时候。如果返回了，那么还要看输出过了没，如果输出过了，那就过掉。<br>我们的回调函数中有了不少代码，跟这个回调本身该做的事情没有关系。这些代码，都是跟时间或者说状态有关的。输出的顺序，输出过的状态。而我们人脑的思维方式是习惯于顺序思考的。比如上面这个例子如果不考虑阻塞什么的，写伪代码的话我们大概会这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch( file1 );</span><br><span class="line">fetch( file2 );</span><br><span class="line">fetch( file3 );</span><br><span class="line">var file1Result = getFileContent (&quot;file1&quot;);</span><br><span class="line">var file2Result = getFileContent (&quot;file2&quot;);</span><br><span class="line">var file3Result = getFileContent (&quot;file3&quot;);</span><br><span class="line">output(file1Result);</span><br><span class="line">output(file2Result);</span><br><span class="line">output(file3Result);</span><br></pre></td></tr></table></figure></p>
<p>上面的伪代码，是我们一般喜欢的思考方式，代码读起来也很容易。<br>反观Callback Hell，我们把本该做纯粹输出的Callback函数加了很多他本不应该具备的功能，比如，把程序运行的控制逻辑放入了Callback函数中。造成了Non-Local， Non-Sequential的代码。课程中，把这个叫做Inversion Of Control。这里的IOC只是指这种我们刚才描述现象，而跟其他我们一般说起的IOC不想关，比如Java的一些设计模式，以及流行的框架Spring。</p>
<h2 id="Thunk"><a href="#Thunk" class="headerlink" title="Thunk"></a>Thunk</h2><p>我们再看一个叫做Thunk的模式。Thunk出现的非常早，比JavaScript语言出现要早很多。<br><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">阮一峰的博客里讲到了thunk</a><br>从同步的角度来看Thunk是一种不需要你传入任何参数的函数，不用传入任何状态，任何时候你调用他，你可以得到相同的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add(<span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunk();<span class="comment">//42</span></span><br></pre></td></tr></table></figure><br>Thunk从上面的例子看出，我们创建了一个Thunk，在里边Hard Code了调用add函数的参数。只要调用这个Thunk，他都会返回相同的值42。在这个Thunk中，我们用它包裹了一个状态的集合，之后我们不管把这个thunk传到哪里，只要调用他就能得到一个确定的值。我并不需要传递任何状态的值，我只需要这个Wrapper，并且调用他就可以得到我需要的值。这其实也是Promise设计的重要基础之一。而Promise要更为的高级，复杂。<br>我们可以把thunk从同步的模式，转换到异步的模式。那么什么是一个异步的thunk？其实这也没有标准答案。按照之前我们同步版thunk的特点，我们的thunk是一个状态和值的wrapper。那么，比较直接的想法，一个异步的thunk，是我们不传入任何跟值或者状态有关的东西，而只需要把回调的函数传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAsync</span>(<span class="params">x, y, cb</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(x + y);</span><br><span class="line">	&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">	addSync(<span class="number">11</span>, <span class="number">31</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunk(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">	sum;<span class="comment">//42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>每一次调用thunk，把Callback传入，我们知道我们会得到相应的结果。外部的代码并不知道，也不需要关心thunk里的参数或者计算倒地是什么细节。从thunk内部来说，他里边可能有复杂的计算，或者ajax call；他甚至可以记录计算后的结果，当你第二次调用他的时候立即返回这个结果。但是外部的代码并不需要关心这些，只要你调用thunk，就可以期待一个值在Callback中返回。<br>创建一个异步thunk，就是创建了一个返回值的wrapper，而且这个值是多少，与调用的时间无关。而时间，是程序代码中最复杂的状态因子。管理好程序执行的时机，是最难的工作之一。<br>Thunk就是一个value的wrapper，我不管把他传到哪里，我想知道这个value是，传入Callback，都会得到结果。<br>这其实跟promise的概念很相似。理解了这一点也就很容易理解promise。promise更为的复杂。</p>
<h3 id="Lazy-Thunk-Active-Thunk"><a href="#Lazy-Thunk-Active-Thunk" class="headerlink" title="Lazy Thunk, Active Thunk"></a>Lazy Thunk, Active Thunk</h3><p>我们之前的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAsync</span>(<span class="params">x, y, cb</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(x + y);</span><br><span class="line">	&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">	addSync(<span class="number">11</span>, <span class="number">31</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunk(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">	sum;<span class="comment">//42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>只有在调用Thunk时，才回去请求addAsync函数。再联系到我们之前Callback最后那个题目的情景，如果我们要同时、并发去请求文件，这样的thunk是做不到的。我们起个名字，把这种叫Lazy Thunk。<br>那怎么实现我们的并发需求呢？Lazy Thunk似乎并不能满足我们的并发需求。我再把之前的例子贴过来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// what do we do here?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request all files at once in "parallel"</span></span><br><span class="line"><span class="comment">// ???</span></span><br></pre></td></tr></table></figure><br>我们的getFile应该返回一个接受一个Callback参数的thunk，所以我们最后的代码应该有这样一段，前三个调用创建三个thunk，并且创建时就去请求，最后顺序输出结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> th1 = getFile(<span class="string">'file1'</span>);</span><br><span class="line"><span class="keyword">var</span> th2 = getFile(<span class="string">'file2'</span>);</span><br><span class="line"><span class="keyword">var</span> th3 = getFile(<span class="string">'file3'</span>);</span><br><span class="line">th1(<span class="function"><span class="keyword">function</span>(<span class="params">file1</span>)</span>&#123;</span><br><span class="line">	output(file1);</span><br><span class="line">	th2(<span class="function"><span class="keyword">function</span>(<span class="params">file2</span>)</span>&#123;</span><br><span class="line">		output(file2);</span><br><span class="line">		th3(<span class="function"><span class="keyword">function</span>(<span class="params">file3</span>)</span>&#123;</span><br><span class="line">			output(file3);</span><br><span class="line">			output(<span class="string">'Compeleted!'</span>);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>下面是重点getFile怎么实现。而要满足并发这个需求，我们必须要在getFile中，第一时间去调用fakeAjax。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	fakeAjax(file, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//Do something</span></span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//Do other thing</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面有一个时机问题，我们的fakeAjax的回调函数执行时间，与thunk里传入的回调函数，倒地哪个先执行？</p>
<ol>
<li>fakeAjax中的cb先执行。<br>那么我们需要把response存在一个local变量中，等thunk里的cb执行时，直接调用cb，传入这个变量存好的值就可以了</li>
<li>thunk传入的cb先执行。<br>这个看上去不是很直接，我们的返回值还没有，怎么调用这个cb？其实我们要做的事情跟前边的一样，只需要把这个cb存到local的变量中，等fakeAjax返回，再去执行这个cb，把返回的response传入。<br>最后的参考代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> content, fn;</span><br><span class="line">	fakeAjax(file, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(fn)&#123;</span><br><span class="line">			fn(response);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			content = response;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(content) cb(content)</span><br><span class="line">		<span class="keyword">else</span> fn = cb;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可能看上去还不大习惯，但是这个代码风格还是很实用的。这个就是Active Thunk。<br>Thunk并不能解决我们之前在Callback中遇到的大部分缺陷，比如IOC，我们还是会有callback，callback hell的问题。但是这个模式比callback那个代码清晰许多，代码可读性，可维护性都增加了不少。<br>这个用纯js代码实现的异步工具，十分的实用，利用这样的代码可以构建很多有用的工具方法。理解了这个，也就更容易理解promise。</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise，大家肯定都知道了。Promise也成了ES6的标准，主流浏览器的都支持。可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN，Promise</a>。<br>Promise中比较重要的一点是一个Promise只能Resolve一次。举个例子，你做了一个电商网站，专门卖电视。其中有下单，给用户信用卡扣款的流程。如果使用callback，可能的代码是这样的。其中trackCheckout返回一个listener，你注册一个时间监听comletion，之后完成扣款。但是这个方法，可能来自于一个别人写的Module，甚至有可能是一个第三方的lib。如果这个模块中有bug，同一个订单的completion在某些情况下被触发了两次，那么这样的代码下，会扣两次款。这样的callback形式的代码对这种bug特别敏感，要处理这样的情况也需要做很多的额外代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">functiion finish()&#123;</span><br><span class="line">	chargeCreditCard(purchaseInfo);</span><br><span class="line">	showThankYouPage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	logStatsError(err);</span><br><span class="line">	finish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = trackCheckout(purchaseInfo);</span><br><span class="line">listener.on(<span class="string">'completion'</span>, finish);</span><br><span class="line">listener.on(<span class="string">'error'</span>, error);</span><br></pre></td></tr></table></figure><br>如果使用Promise，让trackCheckout返回一个promise，利用promise只能resolve一次的特点，就不会有个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trackCheckout</span>(<span class="params">purchaseInfo</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//call resolve when task complete</span></span><br><span class="line">		<span class="comment">//call rejct when task encounter error</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prommise = trackCheckout(purchageInfo);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">	finish,</span><br><span class="line">	error</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>不管你在trackCheckout中调用resolve多少次，then只会执行一次。<br>Promise保证</p>
<ol>
<li>only resolve once</li>
<li>either success or error</li>
<li>messages are kept/ passed</li>
<li>exceptions treat as error</li>
<li>immutable once resolved</li>
</ol>
<p>Promise可以理解成一个callback manager，让我们的callback调用更有保证，更清晰明白，</p>
<h3 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a>Flow Control</h3><p>下面看看我们一般从外边资料学习到的promise是哪些内容<br>一般我们写的js代码做一些复杂的事情，比如同时发request，等得到结果了以后做什么事情。就跟我们之前做的callback，thunk的练习一样。这就是flow control。我们看看promise做我们的flow control</p>
<h4 id="Chaining-Promise"><a href="#Chaining-Promise" class="headerlink" title="Chaining Promise"></a>Chaining Promise</h4><p>一个重要的特点，也是设计Promise API的最重要的点。就是Chaining。Promise A代表步骤A, Promise B代表步骤B，…<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doFirstThing()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doSecondThing();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doThirdThing():</span><br><span class="line">&#125;)</span><br><span class="line">.then(</span><br><span class="line">	complete,</span><br><span class="line">	error</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>Promise不仅是flow control，也是data flow的体现。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>跟之前的例子一样，我们看看如何用promise完成输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// what do we do here?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要在getFile中立马发出ajax请求，并且返回一个promise。<br>我们需要按顺序输出，这里应该要用到chaining.如果用过promise这个代码应该很容易写出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		fakeAjax(file,resolve);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request all files at once in</span></span><br><span class="line"><span class="comment">// "parallel" via `getFile(..)`.</span></span><br><span class="line"><span class="keyword">var</span> p1 = getFile(<span class="string">"file1"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = getFile(<span class="string">"file2"</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = getFile(<span class="string">"file3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render as each one finishes,</span></span><br><span class="line"><span class="comment">// but only once previous rendering</span></span><br><span class="line"><span class="comment">// is done.</span></span><br><span class="line">p1</span><br><span class="line">.then(output)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p2;</span><br><span class="line">&#125;)</span><br><span class="line">.then(output)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p3;</span><br><span class="line">&#125;)</span><br><span class="line">.then(output)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	output(<span class="string">"Complete!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有一些问题</p>
<ol>
<li>我们需要自己new 一个Promise吗？<br>一般的Library都会把异步操作封装好，直接返回一个promise。但是我们有时候还是需要和上面的代码一样，做一个异步操作的封装，封装的有可能是一个callback或者其他的调用。</li>
<li>能不能把output写到function里面？<br>可以，但是function应该有一个单一的功能，能分开的功能尽量分开</li>
<li>output的chain后面的promise.then的传入参数是什么？<br>传入一个新的promise，传入的参数是output的返回值。</li>
<li>resolve是哪里来的？<br>来自Promise库函数。</li>
<li>catch逻辑是怎么样的？</li>
</ol>
<h3 id="Promise-Hell"><a href="#Promise-Hell" class="headerlink" title="Promise Hell"></a>Promise Hell</h3><p>Promise一定要用对，不然很容易写成promise hell。如果你发现自己陷入了嵌套迭代很深的缩进时，说明你的promise代码很可能写错了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">	output(text);</span><br><span class="line">	p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		output(text);</span><br><span class="line">		p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">			output(text);</span><br><span class="line">			output(<span class="string">'completed!'</span>);</span><br><span class="line">		&#125; )</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure></p>
<p>上边的练习里边我们有三个文件要去请求，那么如果我们的请求的文件数目增加我们是不是要写很多的.then呢？有没有更好的办法？<br>可以用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">map</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">reduce</a>方法来减少我们的重复代码。<br>我们可以把任意个file的list转换成promise的list，再用reduce函数一一处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		fakeAjax(file,resolve);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request all files at once in</span></span><br><span class="line"><span class="comment">// "parallel" via `getFile(..)`.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Render as each one finishes,</span></span><br><span class="line"><span class="comment">// but only once previous rendering</span></span><br><span class="line"><span class="comment">// is done.</span></span><br><span class="line">[<span class="string">"file1"</span>,<span class="string">"file2"</span>,<span class="string">"file3"</span>]</span><br><span class="line">.map(getFile)</span><br><span class="line">.reduce(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">chain,filePromise</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> chain</span><br><span class="line">			.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> filePromise;</span><br><span class="line">			&#125;)</span><br><span class="line">			.then(output);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">Promise</span>.resolve() <span class="comment">// fulfilled promise to start chain</span></span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	output(<span class="string">"Complete!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-其他的API"><a href="#Promise-其他的API" class="headerlink" title="Promise 其他的API"></a>Promise 其他的API</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>如果任何一个里面的promise reject，那么all立刻reject<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">	doTask1a(),</span><br><span class="line">	doTask1b(),</span><br><span class="line">	doTask1c()</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doTask2(</span><br><span class="line">		<span class="built_in">Math</span>.max(</span><br><span class="line">			results[<span class="number">0</span>],</span><br><span class="line">			results[<span class="number">1</span>],</span><br><span class="line">			results[<span class="number">2</span>],</span><br><span class="line">		);</span><br><span class="line">	);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>只要有一个promise完成，resolve或者reject<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = trySomeAsyncThing();</span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">	p,</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">_, reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			reject(<span class="string">'timeout!'</span>);</span><br><span class="line">		&#125;, <span class="number">3000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">])</span><br><span class="line">.then(</span><br><span class="line">	success,</span><br><span class="line">	error</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Roger Guo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roger Guo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
