<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Roger Guo&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Roger Guo&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roger Guo&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>Roger Guo's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Roger Guo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/Javascript异步编程2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/Javascript异步编程2/" itemprop="url">Javascript异步编程2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T12:39:37+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><h3 id="Generator-介绍"><a href="#Generator-介绍" class="headerlink" title="Generator 介绍"></a>Generator 介绍</h3><p>我们可能都不自觉的有一个认识，那就是JavaScript的函数有一个特点，run to completion。意思是说在一个时间点，只会有一个函数在运行。当这个函数运行结束前，没有任何一个外部函数可以从外部抢占执行的权利。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">Generator</a>是在ES6引入的。Generator函数可以在执行的过程中让出执行的机会，自己暂停下来。在需要的时候，外部主动调用Generator的next方法继续执行剩下的部分。<br>可以参考<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">阮一峰博客</a>。这里先给一个简单的代码示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line">it.next(); <span class="comment">// hello</span></span><br><span class="line">it.next(); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><br>创建一个Generator需要用<strong>function*</strong> 的关键字，以区别于普通的function定义。还有一个新的关键字是<strong>yield</strong>。它的功能就像我们的播放器上的暂停按钮一样，暂停了Generator函数的执行。注意，Generator函数暂停的点是由函数定义的时候制定好的。外部无法主动地去设置Generator停在哪一行。我们把这个叫Coorperate concurrency，而不是Preemptive concurrency。Preemptive意思就是抢占式的。在调用gen()时，只是创建一个generator对象，函数并没有开始执行。调用Generator产生一个iterator，iterator就是用来遍历数据的。我们在第8行调用next函数，这个Generator由暂停状态变为执行状态，等到运行到yield的时候，这个Generator再次变为暂停状态。第9行再次调用next，函数继续执行。</p>
<h3 id="Generator-消息"><a href="#Generator-消息" class="headerlink" title="Generator 消息"></a>Generator 消息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value: 1, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: 2, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value: undifined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们之前的例子yield没有返回任何值，那么他返回的就是undifined。上边这个例子中我们yield反回了1,2,3，可以看出，<br>yield 1时，也就是我们的第9行执行的时候，返回了value为1，done为false的object。yield 2时，执行第10行，返回了value为2，done为false的object。<br>yield 3时，执行第11行，返回了value为2，看起来我们的Generator没有其他可以再执行的了，但是这个Generator还没有还行完毕，所以我们的done还是false。<br>当执行最后一次next时，我们才得到done为true，value是undefined。那么undefined是哪里来的呢？这是因为所以得JavaScript函数如果没有return语句的话，那么返回值就是undefined。如果我们的Generator最后return返回了一个值，例如42，那么这里的值就是value:42, done: true。<br>ES6引入了for of循环，来遍历任何一个iterator。所以我们可以用一个循环来执行Generator，直到到结束。</p>
<p>以下内容可能产生不适。。因为如果从来没有用过generator的话会很不习惯。我们先定义一个generator的执行器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coroutine</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = g();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.next.apply(it, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>coroutine函数其实就是一个generator的wrapper，第2行我们把传入的generator直接初始化，每当我们的调用由coroutine返回的函数时，其实就是调用generator的next函数。</p>
<p>下面看这个代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> run =  coroutine(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span>);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span> + (<span class="keyword">yield</span>);</span><br><span class="line">    <span class="keyword">yield</span> (x + y);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line">run(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Meaning of life: "</span> + run(<span class="number">30</span>).value);</span><br></pre></td></tr></table></figure><br>我们调用coroutine来包装起来我们的generator函数，返回一个run方法，初始化这个generator。每一次调用run都是在调用next方法。</p>
<p>第7行调用run，开始执行generator，运行第2行，执行语句var x = 1 +, 然后我们遇到了yield。generator要暂停，把执行权返回到第8行。generator只有等待外部的输入值时才可以继续计算完这个表达式。第7行，我们继续调用run，也就是next，传入10，完成第一个表达式的计算的到x=11;generator继续执行var y = 1 +,我们遇到yield，让出执行权到第8行。run(30), 将30传入generator，完成y的计算y=31,generator继续执行，yield（x+y），generator暂停，把42作为value传出去。</p>
<p>从generator外部看，也就是第7行开始，我们每运行一次next，就会暂停下来，把值传入到generator，让generator继续运行到下一个yield的地方。<br>从generator内部看，每一次yield，其实是generator缺少一个依赖的值，不能继续计算，而暂停下来。只有等待外部的传入的值和继续执行的信号，才能继续。<br>每一个yield，可以理解为，我这个地方需要一个value，我会一直等待，直到有人在外边给我传入一个值。 </p>
<h3 id="异步Generator"><a href="#异步Generator" class="headerlink" title="异步Generator"></a>异步Generator</h3><p>我们改造一下上边的例子，做一个异步的Generator<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; run(d); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> run = coroutine(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">var</span> answer = (<span class="keyword">yield</span> getData(<span class="string">"Meaning of life: "</span> + (x + y)));</span><br><span class="line">    <span class="built_in">console</span>.log(answer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure></p>
<p>先看getData方法，我们注册一个timeout，从而异步的在第2行调用run方法，让generator继续执行。<br>我们在generator里，yield了一个表达式，也就是getData。在执行var x = 1 + (yield getData(10))时，generator暂停，把执行权交给外部，同时getData开始运行。当getData中的回调函数运行，执行run，传入10，这样让generator继续完成表达式的计算，x=11。继续执行下一行var y = 1 + (yield getData(30)),遇到yield暂停，并且执行getData(30)。同样等timeout的回调执行时，把30传回generator，继续完成y的计算，y=41;同理下一行计算answer，yield暂停，等timeout回来再继续完成计算。最后console输出。</p>
<p>在上边这个例子的generator中我们的代码看上去是同步的，背后的getData是异步的。这样的代码结构跟我们的思维方式是一样的，代码可读性增强了很多，比之前的promise还要好。</p>
<h3 id="Promise-and-Generator"><a href="#Promise-and-Generator" class="headerlink" title="Promise and Generator"></a>Promise and Generator</h3><p>我们之前的代码中还是有一些缺点。就是我们的run方法被放在了callback中执行，这就是inversion of control。程序继续的调用的控制不够清晰。<br>而且我们之前的代码中yield都是undifined。所以我们考虑能不能yield一个promise，也就是让getData返回一个promise，等这个promise完成时，也就是getData完成时，调用Generator的next方法继续执行。等到下一个语句再yield另一个promise，等promise完成继续调用next，如此下去，等到next返回done为true时，也就是我们的generator执行完毕的时候。<br>后边的流程很像递归。也是一个跟业务逻辑无关的流程控制器。外边的lib有很多开源实现，就是一个返回promise的generator的执行器。下边的代码是我自己随意实现了的一个执行器，里边没有包含出错处理这方面的代码，只是为了给出一个大概的样子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">         setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; resolve(d); &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span> + (<span class="keyword">yield</span> getData(<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">var</span> answer = (<span class="keyword">yield</span> getData(<span class="string">"Meaning of life: "</span> + (x + y)));</span><br><span class="line">    <span class="built_in">console</span>.log(answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> next = it.next(value);</span><br><span class="line">    <span class="keyword">if</span>( next.done )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next.value.then(handleNext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleNext();</span><br></pre></td></tr></table></figure><br>我们把这个通用的执行器<strong>runner</strong>方法提出来以后也可以用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runner</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = gen();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> next = it.next(value);</span><br><span class="line">        <span class="keyword">if</span>( next.done )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next.value.then(handleNext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Generator练习"><a href="#Generator练习" class="headerlink" title="Generator练习"></a>Generator练习</h3><p>还是之前的情景，我们来思考一下用Generator是怎么解决的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		fakeAjax(file,resolve);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request all files at once in</span></span><br><span class="line"><span class="comment">// "parallel" via `getFile(..)`.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Render as each one finishes,</span></span><br><span class="line"><span class="comment">// but only once previous rendering</span></span><br><span class="line"><span class="comment">// is done.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p1 = getFile(<span class="string">"file1"</span>);</span><br><span class="line">    <span class="keyword">var</span> p2 = getFile(<span class="string">"file2"</span>);</span><br><span class="line">    <span class="keyword">var</span> p3 = getFile(<span class="string">"file3"</span>);</span><br><span class="line">    output(<span class="keyword">yield</span> p1);</span><br><span class="line">    output(<span class="keyword">yield</span> p2);</span><br><span class="line">    output(<span class="keyword">yield</span> p3);</span><br><span class="line">    output(<span class="string">'completed'</span>);</span><br><span class="line">&#125;</span><br><span class="line">runner(gen);</span><br><span class="line"></span><br><span class="line"><span class="comment">//use map</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promises = [<span class="string">"file1"</span>, <span class="string">"file2"</span>, <span class="string">"file3"</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">fname</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFile(fname);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(p <span class="keyword">of</span> promises)&#123;</span><br><span class="line">        output((<span class="keyword">yield</span> p));</span><br><span class="line">    &#125;</span><br><span class="line">    output(<span class="string">'completed'</span>);</span><br><span class="line">&#125;</span><br><span class="line">runner(gen);</span><br></pre></td></tr></table></figure>
<p>有了之前的例子，这里的的示例代码更容易写出来，其实就是利用Promise和Generator，我们的解也分为用普通的流程和用list的map和循环来写。<br>可以看出来这样的代码更为清晰易懂，比之前用promise解决可读性更胜一筹。</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><h3 id="Events-and-promises"><a href="#Events-and-promises" class="headerlink" title="Events and promises"></a>Events and promises</h3><p>前端的代码中的并发，异步，我们之前也说过，核心问题是流程控制的管理。比如之前说过的promise，处理的是单个请求和单个回复的情况。<br>如果我们要处理一个消息流，也就是连续不断地同类event，该如何？Promise还能胜任吗？<br>而且我们在编程中大部分要出里的异步问题，是面向event stream的。在UI中的，用户的操作，比如点击;服务器发来的数据处理，都是面向event的。在这种情况下我们把promise套如，可能会有些问题。<br>举个例子，我的页面上可能有一些处理用户点击的代码。我想记录一些btn点击的log。我知道promise怎么创建，套用到这个情景中应该是这样的，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, rejct</span>)</span>&#123;</span><br><span class="line">    $(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> className = evt.target.className;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/foobar/</span>.test(className))&#123;</span><br><span class="line">            resolve(className);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(className);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可是上面的代码有一个问题，就是promise只能resolve一次。我创建了一个promise，但是只能响应一次用户点击。我们之前介绍了那么多工具，promise，generator的高级工具，可是遇到这个最最常见的情景，好像不是很好使。我们该怎么办？</p>
<p>可能你会这么想，我反一下，把promise的创建搬到event的listener里边，如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> className = evt.target.className;</span><br><span class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/foobar/</span>.test(className))&#123;</span><br><span class="line">            resolve(className);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(className);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>我们每次在click的callback中都创建一个新的promise，这样就可以每次都resolve了。这样看起来挺不错，可是，我们为什么要这样做？这与我们一开始的callback hell不是一样了吗？我们立即resolve了一个promise，并且调用了then。我们之前的代码还可以在一个地方设置好我的消息源，而在我程序的另外一个地方处理这个消息。现在全部都回到了一起，我们把两个不同的任务混在了一个地方。</p>
<p>其实问题在于我们的promise并不是特别适合于一个面向event的环境。我们需要更好地工具。我们需要把两个任务分开，也就是消息源的设置，以及消息的处理。</p>
<h3 id="Observables"><a href="#Observables" class="headerlink" title="Observables"></a>Observables</h3><p>现在的Obserable还不是JavaScript原生支持的。也就是说ES6中没有这个东西，我们都需要用第三方的lib。但未来Observable很可能会成为JavaScript的一部分。现在外部有一个很好的Observable的lib，也就是Rxjs。</p>
<h4 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h4><p>在Excel中，我们知道有计算单元格这个东西。就是说有些单元格的数据是通过计算其他源单元格的数据得到的。例如求和，求平均值，甚至更复杂的计算。当源数据发生改变的时候，这些计算单元数据也会相应的变化。假如我们的源数据被多个计算单元格依赖，那么就会触发所有这些计算单元格的更新。源数据单元的变化可能有好多次，变化的事件就像流一样。而依赖这个数据源的计算单元格都需要订阅这个<strong>变化</strong>，并且执行相应的步骤来更新自己的数据。</p>
<p>Observable或者Reactive Programming（响应式编程）就是类似的概念。Observable是一个事件的转换器，它连接在事件的源上边，每一次有一个新的事件发生，它就产生一个新的promise。重点在于，我可以在一个地方设置好这个转换器，而在程序的另一个地方甚至多个不同的地方，再定义如何处理这个事件流。我们不用和之前举得反例一样把事件的订阅初始化代码和处理代码放在同一个地方。</p>
<h4 id="Rxjs例子"><a href="#Rxjs例子" class="headerlink" title="Rxjs例子"></a>Rxjs例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obsv = Rx.Observable.fromEvent(btn, <span class="string">"click"</span>);</span><br><span class="line"></span><br><span class="line">obsv</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> evt.target.className;</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span> <span class="title">filterer</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/foobar/</span>.test(className);</span><br><span class="line">    &#125;)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> className = data[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(className);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>例子中的第一行我们创建了一个Observable，使用了Rx.Observable.fromEvent这个常用的工具。它可以把一个dom元素上的事件变成一个Observable。Rxjs还有很多强大的工具可以使用。<br>在程序的其他地方，我可以定义我想如何处理这个事件流。这里的map和filter等等，都是Observable的工具，用来对这个事件流进行一些转换和处理，也是十分易于理解使用。最后调用subscribe，来操作转换好的事件。我们就好像定义好了一系列的步骤来处理这个流过来的事件一样。我们把Observable甚至可以当做数组一样对待，数组其实也是一个数据流。</p>
<p>这里比较有意思的一个工具是distinctUntilChanged，这个是说加入现在连续来了5个event，都是hello，那么只有第一个可以进入下一步，其他4个都被过滤，因为重复了。然后来了连续的5个world，那么只有第一个world可以流入下一步。这是distinct的意思。那么接着，又来了5个hello，那么还是只有第一个hello可以通过。这是untilchanged的意思。</p>
<p><a href="http://rxmarbles.com/" target="_blank" rel="noopener">RxMarbles</a>有一个很好的这些工具的图示化介绍。</p>
<h3 id="Rxjs常用工具"><a href="#Rxjs常用工具" class="headerlink" title="Rxjs常用工具"></a>Rxjs常用工具</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From an event</span></span><br><span class="line">Rx.Observable.fromEvent(<span class="built_in">document</span>.querySelector(<span class="string">'button'</span>), <span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// From array of values</span></span><br><span class="line">Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// From one or multiple values</span></span><br><span class="line">Rx.Observable.of(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Externally produce new events.</span></span><br><span class="line"><span class="keyword">var</span> myObservable = <span class="keyword">new</span> Rx.Subject();</span><br><span class="line">myObservable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br><span class="line">myObservable.next(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge Observables</span></span><br><span class="line"><span class="comment">// Creates an output Observable which concurrently emits all values from every given input Observable.</span></span><br><span class="line"><span class="keyword">var</span> observable1 = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> observable2 = Rx.Observable.interval(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> merged = Rx.Observable.merge(observable1, observable2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zip</span></span><br><span class="line"><span class="comment">// Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.</span></span><br><span class="line"><span class="keyword">let</span> age$ = Observable.of(<span class="number">27</span>, <span class="number">25</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> name$ = Observable.of(<span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Beer'</span>);</span><br><span class="line"><span class="keyword">let</span> isDev$ = Observable.of(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">Observable</span><br><span class="line">    .zip(age$,</span><br><span class="line">         name$,</span><br><span class="line">         isDev$,</span><br><span class="line">         (age, name, isDev) =&gt; (&#123; age, name, isDev &#125;))</span><br><span class="line">    .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<h3 id="Observable练习"><a href="#Observable练习" class="headerlink" title="Observable练习"></a>Observable练习</h3><p>这次是一个新的的练习。需求是对页面上的btn点击行为进行采样。注意不是debounce，同一个btn在短时间内点击多次，例如每一秒内，我只响应一次点击。<br>我在下面的codepen中，已经引用了jQeury和Rxjs。有兴趣的可以打开试着写一写。<br> <iframe id="cp_embed_eygMWK" src="//codepen.io/guoyongxin/embed/eygMWK?height=300&theme-id=theme&slug-hash=eygMWK&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe></p>
<p>有人可能会考虑用zip来解决这个问题，但是zip其实不能完成采样的任务。那样的话，我们的clicks的队列会不断地增长，而不是真正的采样。我在下边给出两份参考代码<br>Solution1：<br>  <iframe id="cp_embed_ZvLpNQ" src="//codepen.io/guoyongxin/embed/ZvLpNQ?height=300&theme-id=theme&slug-hash=ZvLpNQ&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe></p>
<p>Solution2:<br>  <iframe id="cp_embed_OzWvrm" src="//codepen.io/guoyongxin/embed/OzWvrm?height=300&theme-id=theme&slug-hash=OzWvrm&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe></p>
<p>可以看出来Rxjs中的工具还是非常的多和实用的。我这里是抛砖引玉，更多的内容都在官网上有。掌握或者了解Rxjs的各种工具的适用场景，我认为是成为一个合格的Reactive Programmer的基本。</p>
<p>我在刚刚接触Observable的时候，也是理解了好几次，特别是event stream。看官方的文档，资料，也看了几次。看多了用多了也就有一些感觉，代码的质量也就能提升。</p>
<p>我们的工具箱中又多了一个工具。没有任何一个工具是万金油。不同的场景有不同的合适的方法，对每个的特点都理解，不要用的太死板是我们的该做到的。</p>
<h2 id="CSP-Communicating-Sequential-Processes-Channels"><a href="#CSP-Communicating-Sequential-Processes-Channels" class="headerlink" title="CSP (Communicating Sequential Processes)/ Channels"></a>CSP (Communicating Sequential Processes)/ Channels</h2><p>CSP的目的是用Channel来设计并发程序。和我们之前所介绍的各种方法一样。</p>
<p>CSP的提出在<a href="http://www.usingcsp.com/cspbook.pdf" target="_blank" rel="noopener">这里</a>，说实话我也没怎么看过这篇文章，作者Hoare现在仍在更新CSP的理论。CSP的理念在Go语言和Clojure Script中使用的很多</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>那么Channel是什么？Channel有些像Stream，也类似于管道Pipe。如果了解Actor模型的话（<a href="https://doc.akka.io/docs/akka/2.5.5/scala/actors.html" target="_blank" rel="noopener">Scala中大量使用的并发模型</a>），Channel确实和Actor很类似。但Channel有一个重点在于，默认情况下他没有缓冲区，因此Channel自然有了这样一个特点就是，反向压力（Back Pressure）。举个生活中的例子，我拿着水管接在水龙头上边给外边的花草浇水，我打开洒水口的开关就行了;当我浇完了我直接把洒水口的开关关掉就行了，我并不需要告诉源头我要开还是要关，我只需要操作我手边的开关就可以了。这是反向的从消费者到生产者的一个交流，告诉上边的生产者说，我不需要水了。Channel的Back Presse，也就是说Channnel的send动作是阻塞的。只有当Channel在另一方，调用了取消息take后，才会解除阻塞，反之亦然。而Actor的send是异步的，也就是非阻塞的。</p>
<p>在我们的程序中，我们有这样的代码，我们的生产者和消费者之间没有直接的联系，因为我们需要这么做，以达到职责清晰，代码的局部性更好。我们需要生产者和消费者之间有一个交流，但是如果我们不想引入一个类似于全局变量的东西，告诉生产者需不需要继续生产，别给我发了。（Rxjs Observable中有Hot Cold）。<br>另外一种设计方式就是用我们的Channel，利用Back Pressure，可以做到，你不能往Channel放更多地东西，直到我准备好了可以继续取;你不能继续取东西，直到我可以再往里边放东西。</p>
<p>我们提到了阻塞，你可能会联想到JavaScript唯一有阻塞功能的工具，就是我们刚才讲过的Generator函数。确实如此，CSP的JavaScript版本需要用到Generator。</p>
<p>看点代码吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = chan();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">process1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> put(ch, <span class="string">"hello"</span>); <span class="comment">// 1. put hello into ch and pause proc1 until someone take it from the ch</span></span><br><span class="line">    <span class="keyword">var</span> msg = <span class="keyword">yield</span> take(ch); <span class="comment">// 2. resume proc1 because someone take hello out, and wait for someone to put something into the ch</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg); <span class="comment">// 3. someone put something into ch to let proc1 to resume.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">process2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="keyword">yield</span> take(ch); <span class="comment">// 1. pause proc2 until someone put something into ch</span></span><br><span class="line">    <span class="keyword">yield</span> put(ch, greeting + <span class="string">" world"</span>); <span class="comment">// 2. resume proc2 because someone has put data in ch, and put data into ch, then pause proc2 again until someone have take that from ch </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"done"</span>); <span class="comment">// 3. resume proc2 because someone take the data from ch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure></p>
<p>chan, put, take我们先当做现有的函数来理解这段代码。我们用到了yield，因为我们需要阻塞或者说暂停我们的函数。 假设proc1和proc2在两个不同的线程运行，他们通过ch就可以协调消费者生产者的运行时交流与相互控制。</p>
<h3 id="Blocking-Channel"><a href="#Blocking-Channel" class="headerlink" title="Blocking Channel"></a>Blocking Channel</h3><p>再看一个例子，我们用了一个csp的lib，里边用到了go函数，因为是模仿了Go语言的方式调用类似线程运行的功能。csp.timeout返回一个channel，而我们并不需要关心这个channel到底在哪，我们只需要知道过500ms他会在里边放一个消息，让我们的yield的地方继续执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = chan();</span><br><span class="line"></span><br><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> csp.put(ch, <span class="built_in">Math</span>.random()); <span class="comment">// repeately put random number in ch, pause when blocking</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">yield</span> csp.take( csp.timeout(<span class="number">500</span>) ); <span class="comment">// wait 500ms</span></span><br><span class="line">        <span class="keyword">var</span> num = <span class="keyword">yield</span> csp.take(ch); <span class="comment">// take data from ch</span></span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>下面的例子alts，功能比较像promise的race。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> msg = <span class="keyword">yield</span> csp.alts(ch1, ch2, ch3);</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>再来一个<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> table = csp.chan();</span><br><span class="line">    </span><br><span class="line">    csp.go(player, [<span class="string">"ping"</span>, table]); <span class="comment">// setup ping 'proc'</span></span><br><span class="line">    csp.go(player, [<span class="string">"pong"</span>, table]); <span class="comment">// setup pong 'proc'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> csp.put(table, &#123;<span class="attr">hits</span>: <span class="number">0</span>&#125;); <span class="comment">// start the game by put msg into channel table</span></span><br><span class="line">    <span class="keyword">yield</span> csp.timeout(<span class="number">1000</span>); <span class="comment">// wait for 1000ms to close the channel table</span></span><br><span class="line">    table.close();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">player</span>(<span class="params">name, table</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ball = <span class="keyword">yield</span> csp.take(table); <span class="comment">// try to get the ball from table</span></span><br><span class="line">        <span class="keyword">if</span>( ball === csp.CLOSED) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(name +  <span class="string">": table's gone"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ball.hits += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">" "</span> + ball.hits);</span><br><span class="line">        <span class="keyword">yield</span> csp.timeout(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">yield</span> csp.put(table, ball); <span class="comment">// put updated ball back to ch</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Event-Channel"><a href="#Event-Channel" class="headerlink" title="Event Channel"></a>Event Channel</h3><p>我们在Observable有一个工具是fromEvent，我们这里用csp的方法设计一个自己的fromEvent。这里用了putAsync，我想从字面也能理解这个是非阻塞的put。我为什么用putAsnc呢，因为这个函数不是一个Generator，而是一个普通的JavaScript函数。putAyns会返回一个promise，当这个put成功是resolve。但是我这里并不关心她什么时候put成功。这里是不是很像我们在Observable中不停地调用next函数？csp与Observable的核心区别在于有Back Pressure。如果Channel数据没有被取走，生产者无法继续往队列里放数据。连续不停地调用putAsync，并不会覆盖Channel的数据，每一个putAsync都会返回promise，他们排着队等待往Channel里放数据。直到有人从Channel中开始取数据时，这个队列才会向前。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromEvent</span>(<span class="params">el, eventType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ch = csp.chan();</span><br><span class="line">    $(el).bind(eventType, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        csp.putAsync(ch, evt);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">csp.go(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ch = fromEvent(el, <span class="string">"mousemove"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> evt = <span class="keyword">yield</span> csp.take(ch);</span><br><span class="line">        <span class="built_in">console</span>.log(evt.clientX + <span class="string">","</span> + evt.clientY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="CSP练习"><a href="#CSP练习" class="headerlink" title="CSP练习"></a>CSP练习</h3><p>我认为下面这个练习的情景有些生硬，不是特别适合Channel的场景，没能完全体现出Channel的优势。而且我认为原来培训中的参考答案并不完全正确的。但是还是可以参考一下这个题目吧。需求跟Observable的btn采样是一样的。我给直接给出了我的代码。我们最后还是用到了shouldWrite变量来控制写，而且好像没有更好地办法。</p>
<p>这里我引用了<a href="https://github.com/ubolonton/js-csp/blob/master/doc/basic.md" target="_blank" rel="noopener">js-csp</a>。对于看过Rethinking的，我一直没有使用Trainer的<a href="https://github.com/getify/asynquence" target="_blank" rel="noopener">ASQ</a>库是因为我觉得他的lib东西太多了，什么都可以做，而且使用什么都要在前面加ASQ，看上去有些奇怪。不过他确实很厉害，自己写了这么多工具的实现。</p>
 <iframe id="cp_embed_Ozpbxq" src="//codepen.io/guoyongxin/embed/Ozpbxq?height=300&theme-id=theme&slug-hash=Ozpbxq&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<h3 id="大练习-A-tale-of-three-lists"><a href="#大练习-A-tale-of-three-lists" class="headerlink" title="大练习 A tale of three lists"></a>大练习 A tale of three lists</h3><p>Trainer的这个练习还是很赞的，给出地址<a href="https://github.com/getify/A-Tale-Of-Three-Lists" target="_blank" rel="noopener">git</a>，有兴趣的可以clone下来，用我们讲过的各种工具（Callback, thunk, promise, generator, obserable, csp）都实现以下这个练习。还是很有挑战的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>两篇文章介绍了各种JavaScript异步编程的工具。我的理解是，没有一个万金油可以解决所有的问题。如果你听身边有人说Observable可以解决一切异步编程的问题，或者说CSP可以搞定所有的异步编程设计，那么他一定是过分沉浸在自己的世界了，所谓生搬硬套。我们需要做的就是掌握这个工具箱里的所有工具，在适合的时候拿出来，写出漂亮的代码，解决这个问题。</p>
<p>最后推荐一些我写第二篇时看到的一些有关的好文章的连接</p>
<p><a href="https://juejin.im/entry/56f480ccc4c9710051bffd2b" target="_blank" rel="noopener">https://juejin.im/entry/56f480ccc4c9710051bffd2b</a><br><a href="https://www.zhihu.com/question/26192499" target="_blank" rel="noopener">https://www.zhihu.com/question/26192499</a><br><a href="http://lucasmreis.github.io/blog/quick-introduction-to-csp-in-javascript/" target="_blank" rel="noopener">http://lucasmreis.github.io/blog/quick-introduction-to-csp-in-javascript/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/18/JavaScript异步编程1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roger Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roger Guo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/18/JavaScript异步编程1/" itemprop="url">JavaScript异步编程1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-18T12:13:35+08:00">
                2017-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近看了Lynda上的一个课程叫做Rethinking Asynchronous Javascript。 在此写一写整理一下自己的心得。</p>
<h2 id="异步与并发"><a href="#异步与并发" class="headerlink" title="异步与并发"></a>异步与并发</h2><p>其实谈到异步编程我们基本上会讲到并发（Parallel）和异步(Async)。从很高的角度来看，他们说的是同一个事情。然而他们在实际工作中一般各有所指。</p>
<p>从理念上看，并发指的是优化，资源同时的得到执行，加快了时间。比如玩过山车，如果每次只让一个人上车，那么其他人都要等待。如果一次上去30个人，那么这30个人就是同时享受到了服务。从计算机的角度看，那就是线程和多核，内核最终支持多少个线程并发，就是类似于过山车一次可以装多少个人上去。所以说一般谈到并发，讲的是资源的最大利用率和效率的问题，最终让请求或者任务得到快速的响应。</p>
<p>谈到异步，则是从编程的角度来看，其实也就是说的非阻塞。如果说到Javascript中我们最最基本的应该就是Callback了。通常我们会在一段代码中有一些需要XHR或者SetTimeout类似的工作，然后我们可以注册一个Callback，然后在等这个注册的函数在任务完成后执行。然而注册这个Callback并不会影响他之后代码的执行。</p>
<p>传统的Web服务器，例如Apache，是多线程的。每一个用户的请求都会编程一个线程，在服务器端执行，只有在服务器完成了用户请求后才可以返回。这样，如果访问的人越来越多，那么线程也会越来越多。所以并发和多线程在这种设计情景下，就是要最大限度的利用服务器的资源。</p>
<p>有关Javascript，我们都知道JS是单线程的执行的,因为它一开始设计得时候就是为了操作浏览器中的DOM元素，单线程也是最简单的设计。我们也都知道Android和iOS程序所有修改UI的操作都需要在主线程也就是UI线程进行。所以JS一定是顺序执行的。而所有的阻塞操作，都是通过回调的方式进行的。还有一个话题就是JS的Event Loop。这个放一放。<br>Nodejs的服务器是单线程的，因为用了Chrome V8的JS Engine。也是因为js的单线程特性，所以js的代码必须是异步的，也就是说是非阻塞的。如果包含例如文件读写，网络请求等，那么这些操作<br>程都会被这个线程接收，然后转到<em>后台</em>的MicroTask任务执行。线程只负责转发这个任务而不是真正执行。只有当任务完成后，这个线程又会得到消息，再把这个结果返回给用户。这样，这个线程所做的工作就比较简单。</p>
<h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>Callback，不用多说，js最最原始的异步调用方式。每注册一次Callback会产生两片代码区域。他们的执行是异步的。看下边的code中的setTimeout注册了一个回调，一段代码在callback函数外边，包括了doSomething，setTimeout的调用和doOtherThing，另一段代码是setTimeout里的回调函数，console.log。第一段代码不知道第二段代码是否已经执行，何时执行。第二段代码也不会知道第一段代码执行到了哪里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doSomething();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"callback!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">doOtherThings();</span><br></pre></td></tr></table></figure></p>
<h3 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h3><p>下边的代码就是所谓的Callback Hell。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"One"</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Two"</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Three"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><br>Callback Hell，大家都知道的一点叫Indentation Nesting。就是层数越多，缩进越多，代码越难看，越难以维护。<br>其实这个只是表象，我们甚至可以改写上边的代码，如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one"</span>)；</span><br><span class="line">    setTimeout(cb, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"two"</span>)；</span><br><span class="line">    setTimeout(cb, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"three"</span>)；</span><br><span class="line">&#125;</span><br><span class="line">one(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    two(three);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样我们没有之前代码那样的缩进，但是这个代码还是看着很别扭。</p>
<h3 id="一个模拟的实际问题"><a href="#一个模拟的实际问题" class="headerlink" title="一个模拟的实际问题"></a>一个模拟的实际问题</h3><p>再看下边一个稍实际一点例子（之后会继续用这个例子）。<br>需求有三点：</p>
<ol>
<li><em>并行</em>的请求3个文件 </li>
<li>尽快的输出文件内容，但是不要等所有请求都完成再去输出</li>
<li>输出是有顺序的，file1内容先输出，之后file2,最后输出file3</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"><span class="comment">// The old-n-busted callback way</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	fakeAjax(file,<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// what do we do here?</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request all files at once in "parallel"</span></span><br><span class="line">getFile(<span class="string">"file1"</span>);</span><br><span class="line">getFile(<span class="string">"file2"</span>);</span><br><span class="line">getFile(<span class="string">"file3"</span>);</span><br></pre></td></tr></table></figure>
<p>我们该怎么办？因为要满足并发，在代码最后三行我们同时调用了getFile。那么如何让结果及时输出并有序呢？那么一定是在fakeAjax里的回调函数中处理。而我们并不知道每一个请求到底要花多少时间才能返回，所以我们需要在回调函数中通过一些变量或者状态，知道目前这三个请求的状态，才能顺序输出。例如,如果我们file3最先返回了结果，但是file1或者file2还没有返回，那么我们并不能立即输出file3的内容，而要等到file1和file2的内容都已经输出了再输出。所以我们的回调函数中，需要知道几乎所有的事情。那么我们看看我们该怎么做：</p>
<ol>
<li>我们需要定义输出顺序，也就是file1 &gt; file2 &gt; file3。</li>
<li>我们需要知道每一个文件请求结果，以及这个内容是否已经输出过</li>
</ol>
<p>实现参考以下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"><span class="comment">// The old-n-busted callback way</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	fakeAjax(file,<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		fileReceived(file,text);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileReceived</span>(<span class="params">file,text</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// haven't received this text yet?</span></span><br><span class="line">	<span class="keyword">if</span> (!responses[file]) &#123;</span><br><span class="line">		responses[file] = text;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> files = [<span class="string">"file1"</span>,<span class="string">"file2"</span>,<span class="string">"file3"</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop through responses in order for rendering</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;files.length; i++) &#123;</span><br><span class="line">		<span class="comment">// response received?</span></span><br><span class="line">		<span class="keyword">if</span> (files[i] <span class="keyword">in</span> responses) &#123;</span><br><span class="line">			<span class="comment">// response needs to be rendered?</span></span><br><span class="line">			<span class="keyword">if</span> (responses[files[i]] !== <span class="literal">true</span>) &#123;</span><br><span class="line">				output(responses[files[i]]);</span><br><span class="line">				responses[files[i]] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// can't render yet</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// not complete!</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	output(<span class="string">"Complete!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hold responses in whatever order they come back</span></span><br><span class="line"><span class="keyword">var</span> responses = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request all files at once in "parallel"</span></span><br><span class="line">getFile(<span class="string">"file1"</span>);</span><br><span class="line">getFile(<span class="string">"file2"</span>);</span><br><span class="line">getFile(<span class="string">"file3"</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们的回调函数中的逻辑还是比较复杂的。 我们遍历了输出文件顺序的files数组，然后依次查看responses有没有返回信息，以及目前正在遍历到的file有没有被输出过。如果结果还没有返回，那么就退出，把这个输出的调用留到下一个回调函数触发的时候。如果返回了，那么还要看输出过了没，如果输出过了，那就过掉。<br>我们的回调函数中有了不少代码，跟这个回调本身该做的事情没有关系。这些代码，都是跟时间或者说状态有关的。输出的顺序，输出过的状态。而我们人脑的思维方式是习惯于顺序思考的。比如上面这个例子如果不考虑阻塞什么的，写伪代码的话我们大概会这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch( file1 );</span><br><span class="line">fetch( file2 );</span><br><span class="line">fetch( file3 );</span><br><span class="line">var file1Result = getFileContent (&quot;file1&quot;);</span><br><span class="line">var file2Result = getFileContent (&quot;file2&quot;);</span><br><span class="line">var file3Result = getFileContent (&quot;file3&quot;);</span><br><span class="line">output(file1Result);</span><br><span class="line">output(file2Result);</span><br><span class="line">output(file3Result);</span><br></pre></td></tr></table></figure></p>
<p>上面的伪代码，是我们一般喜欢的思考方式，代码读起来也很容易。<br>反观Callback Hell，我们把本该做纯粹输出的Callback函数加了很多他本不应该具备的功能，比如，把程序运行的控制逻辑放入了Callback函数中。造成了Non-Local， Non-Sequential的代码。课程中，把这个叫做Inversion Of Control。这里的IOC只是指这种我们刚才描述现象，而跟其他我们一般说起的IOC不想关，比如Java的一些设计模式，以及流行的框架Spring。</p>
<h2 id="Thunk"><a href="#Thunk" class="headerlink" title="Thunk"></a>Thunk</h2><p>我们再看一个叫做Thunk的模式。Thunk出现的非常早，比JavaScript语言出现要早很多。<br><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">阮一峰的博客里讲到了thunk</a><br>从同步的角度来看Thunk是一种不需要你传入任何参数的函数，不用传入任何状态，任何时候你调用他，你可以得到相同的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add(<span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunk();<span class="comment">//42</span></span><br></pre></td></tr></table></figure><br>Thunk从上面的例子看出，我们创建了一个Thunk，在里边Hard Code了调用add函数的参数。只要调用这个Thunk，他都会返回相同的值42。在这个Thunk中，我们用它包裹了一个状态的集合，之后我们不管把这个thunk传到哪里，只要调用他就能得到一个确定的值。我并不需要传递任何状态的值，我只需要这个Wrapper，并且调用他就可以得到我需要的值。这其实也是Promise设计的重要基础之一。而Promise要更为的高级，复杂。<br>我们可以把thunk从同步的模式，转换到异步的模式。那么什么是一个异步的thunk？其实这也没有标准答案。按照之前我们同步版thunk的特点，我们的thunk是一个状态和值的wrapper。那么，比较直接的想法，一个异步的thunk，是我们不传入任何跟值或者状态有关的东西，而只需要把回调的函数传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAsync</span>(<span class="params">x, y, cb</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(x + y);</span><br><span class="line">	&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">	addSync(<span class="number">11</span>, <span class="number">31</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunk(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">	sum;<span class="comment">//42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>每一次调用thunk，把Callback传入，我们知道我们会得到相应的结果。外部的代码并不知道，也不需要关心thunk里的参数或者计算倒地是什么细节。从thunk内部来说，他里边可能有复杂的计算，或者ajax call；他甚至可以记录计算后的结果，当你第二次调用他的时候立即返回这个结果。但是外部的代码并不需要关心这些，只要你调用thunk，就可以期待一个值在Callback中返回。<br>创建一个异步thunk，就是创建了一个返回值的wrapper，而且这个值是多少，与调用的时间无关。而时间，是程序代码中最复杂的状态因子。管理好程序执行的时机，是最难的工作之一。<br>Thunk就是一个value的wrapper，我不管把他传到哪里，我想知道这个value是，传入Callback，都会得到结果。<br>这其实跟promise的概念很相似。理解了这一点也就很容易理解promise。promise更为的复杂。</p>
<h3 id="Lazy-Thunk-Active-Thunk"><a href="#Lazy-Thunk-Active-Thunk" class="headerlink" title="Lazy Thunk, Active Thunk"></a>Lazy Thunk, Active Thunk</h3><p>我们之前的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAsync</span>(<span class="params">x, y, cb</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(x + y);</span><br><span class="line">	&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">	addSync(<span class="number">11</span>, <span class="number">31</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thunk(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">	sum;<span class="comment">//42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>只有在调用Thunk时，才回去请求addAsync函数。再联系到我们之前Callback最后那个题目的情景，如果我们要同时、并发去请求文件，这样的thunk是做不到的。我们起个名字，把这种叫Lazy Thunk。<br>那怎么实现我们的并发需求呢？Lazy Thunk似乎并不能满足我们的并发需求。我再把之前的例子贴过来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// what do we do here?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request all files at once in "parallel"</span></span><br><span class="line"><span class="comment">// ???</span></span><br></pre></td></tr></table></figure><br>我们的getFile应该返回一个接受一个Callback参数的thunk，所以我们最后的代码应该有这样一段，前三个调用创建三个thunk，并且创建时就去请求，最后顺序输出结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> th1 = getFile(<span class="string">'file1'</span>);</span><br><span class="line"><span class="keyword">var</span> th2 = getFile(<span class="string">'file2'</span>);</span><br><span class="line"><span class="keyword">var</span> th3 = getFile(<span class="string">'file3'</span>);</span><br><span class="line">th1(<span class="function"><span class="keyword">function</span>(<span class="params">file1</span>)</span>&#123;</span><br><span class="line">	output(file1);</span><br><span class="line">	th2(<span class="function"><span class="keyword">function</span>(<span class="params">file2</span>)</span>&#123;</span><br><span class="line">		output(file2);</span><br><span class="line">		th3(<span class="function"><span class="keyword">function</span>(<span class="params">file3</span>)</span>&#123;</span><br><span class="line">			output(file3);</span><br><span class="line">			output(<span class="string">'Compeleted!'</span>);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>下面是重点getFile怎么实现。而要满足并发这个需求，我们必须要在getFile中，第一时间去调用fakeAjax。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	fakeAjax(file, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//Do something</span></span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//Do other thing</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面有一个时机问题，我们的fakeAjax的回调函数执行时间，与thunk里传入的回调函数，倒地哪个先执行？</p>
<ol>
<li>fakeAjax中的cb先执行。<br>那么我们需要把response存在一个local变量中，等thunk里的cb执行时，直接调用cb，传入这个变量存好的值就可以了</li>
<li>thunk传入的cb先执行。<br>这个看上去不是很直接，我们的返回值还没有，怎么调用这个cb？其实我们要做的事情跟前边的一样，只需要把这个cb存到local的变量中，等fakeAjax返回，再去执行这个cb，把返回的response传入。<br>最后的参考代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> content, fn;</span><br><span class="line">	fakeAjax(file, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(fn)&#123;</span><br><span class="line">			fn(response);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			content = response;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(content) cb(content)</span><br><span class="line">		<span class="keyword">else</span> fn = cb;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可能看上去还不大习惯，但是这个代码风格还是很实用的。这个就是Active Thunk。<br>Thunk并不能解决我们之前在Callback中遇到的大部分缺陷，比如IOC，我们还是会有callback，callback hell的问题。但是这个模式比callback那个代码清晰许多，代码可读性，可维护性都增加了不少。<br>这个用纯js代码实现的异步工具，十分的实用，利用这样的代码可以构建很多有用的工具方法。理解了这个，也就更容易理解promise。</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise，大家肯定都知道了。Promise也成了ES6的标准，主流浏览器的都支持。可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN，Promise</a>。<br>Promise中比较重要的一点是一个Promise只能Resolve一次。举个例子，你做了一个电商网站，专门卖电视。其中有下单，给用户信用卡扣款的流程。如果使用callback，可能的代码是这样的。其中trackCheckout返回一个listener，你注册一个时间监听comletion，之后完成扣款。但是这个方法，可能来自于一个别人写的Module，甚至有可能是一个第三方的lib。如果这个模块中有bug，同一个订单的completion在某些情况下被触发了两次，那么这样的代码下，会扣两次款。这样的callback形式的代码对这种bug特别敏感，要处理这样的情况也需要做很多的额外代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">functiion finish()&#123;</span><br><span class="line">	chargeCreditCard(purchaseInfo);</span><br><span class="line">	showThankYouPage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	logStatsError(err);</span><br><span class="line">	finish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = trackCheckout(purchaseInfo);</span><br><span class="line">listener.on(<span class="string">'completion'</span>, finish);</span><br><span class="line">listener.on(<span class="string">'error'</span>, error);</span><br></pre></td></tr></table></figure><br>如果使用Promise，让trackCheckout返回一个promise，利用promise只能resolve一次的特点，就不会有个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trackCheckout</span>(<span class="params">purchaseInfo</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//call resolve when task complete</span></span><br><span class="line">		<span class="comment">//call rejct when task encounter error</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prommise = trackCheckout(purchageInfo);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">	finish,</span><br><span class="line">	error</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>不管你在trackCheckout中调用resolve多少次，then只会执行一次。<br>Promise保证</p>
<ol>
<li>only resolve once</li>
<li>either success or error</li>
<li>messages are kept/ passed</li>
<li>exceptions treat as error</li>
<li>immutable once resolved</li>
</ol>
<p>Promise可以理解成一个callback manager，让我们的callback调用更有保证，更清晰明白，</p>
<h3 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a>Flow Control</h3><p>下面看看我们一般从外边资料学习到的promise是哪些内容<br>一般我们写的js代码做一些复杂的事情，比如同时发request，等得到结果了以后做什么事情。就跟我们之前做的callback，thunk的练习一样。这就是flow control。我们看看promise做我们的flow control</p>
<h4 id="Chaining-Promise"><a href="#Chaining-Promise" class="headerlink" title="Chaining Promise"></a>Chaining Promise</h4><p>一个重要的特点，也是设计Promise API的最重要的点。就是Chaining。Promise A代表步骤A, Promise B代表步骤B，…<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doFirstThing()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doSecondThing();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doThirdThing():</span><br><span class="line">&#125;)</span><br><span class="line">.then(</span><br><span class="line">	complete,</span><br><span class="line">	error</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>Promise不仅是flow control，也是data flow的体现。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>跟之前的例子一样，我们看看如何用promise完成输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// what do we do here?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要在getFile中立马发出ajax请求，并且返回一个promise。<br>我们需要按顺序输出，这里应该要用到chaining.如果用过promise这个代码应该很容易写出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		fakeAjax(file,resolve);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request all files at once in</span></span><br><span class="line"><span class="comment">// "parallel" via `getFile(..)`.</span></span><br><span class="line"><span class="keyword">var</span> p1 = getFile(<span class="string">"file1"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = getFile(<span class="string">"file2"</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = getFile(<span class="string">"file3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render as each one finishes,</span></span><br><span class="line"><span class="comment">// but only once previous rendering</span></span><br><span class="line"><span class="comment">// is done.</span></span><br><span class="line">p1</span><br><span class="line">.then(output)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p2;</span><br><span class="line">&#125;)</span><br><span class="line">.then(output)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p3;</span><br><span class="line">&#125;)</span><br><span class="line">.then(output)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	output(<span class="string">"Complete!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有一些问题</p>
<ol>
<li>我们需要自己new 一个Promise吗？<br>一般的Library都会把异步操作封装好，直接返回一个promise。但是我们有时候还是需要和上面的代码一样，做一个异步操作的封装，封装的有可能是一个callback或者其他的调用。</li>
<li>能不能把output写到function里面？<br>可以，但是function应该有一个单一的功能，能分开的功能尽量分开</li>
<li>output的chain后面的promise.then的传入参数是什么？<br>传入一个新的promise，传入的参数是output的返回值。</li>
<li>resolve是哪里来的？<br>来自Promise库函数。</li>
<li>catch逻辑是怎么样的？</li>
</ol>
<h3 id="Promise-Hell"><a href="#Promise-Hell" class="headerlink" title="Promise Hell"></a>Promise Hell</h3><p>Promise一定要用对，不然很容易写成promise hell。如果你发现自己陷入了嵌套迭代很深的缩进时，说明你的promise代码很可能写错了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">	output(text);</span><br><span class="line">	p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		output(text);</span><br><span class="line">		p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">			output(text);</span><br><span class="line">			output(<span class="string">'completed!'</span>);</span><br><span class="line">		&#125; )</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure></p>
<p>上边的练习里边我们有三个文件要去请求，那么如果我们的请求的文件数目增加我们是不是要写很多的.then呢？有没有更好的办法？<br>可以用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">map</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">reduce</a>方法来减少我们的重复代码。<br>我们可以把任意个file的list转换成promise的list，再用reduce函数一一处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAjax</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fake_responses = &#123;</span><br><span class="line">		<span class="string">"file1"</span>: <span class="string">"The first text"</span>,</span><br><span class="line">		<span class="string">"file2"</span>: <span class="string">"The middle text"</span>,</span><br><span class="line">		<span class="string">"file3"</span>: <span class="string">"The last text"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> randomDelay = (<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">1E4</span>) % <span class="number">8000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Requesting: "</span> + url);</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb(fake_responses[url]);</span><br><span class="line">	&#125;,randomDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">		fakeAjax(file,resolve);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request all files at once in</span></span><br><span class="line"><span class="comment">// "parallel" via `getFile(..)`.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Render as each one finishes,</span></span><br><span class="line"><span class="comment">// but only once previous rendering</span></span><br><span class="line"><span class="comment">// is done.</span></span><br><span class="line">[<span class="string">"file1"</span>,<span class="string">"file2"</span>,<span class="string">"file3"</span>]</span><br><span class="line">.map(getFile)</span><br><span class="line">.reduce(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">chain,filePromise</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> chain</span><br><span class="line">			.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> filePromise;</span><br><span class="line">			&#125;)</span><br><span class="line">			.then(output);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">Promise</span>.resolve() <span class="comment">// fulfilled promise to start chain</span></span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	output(<span class="string">"Complete!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-其他的API"><a href="#Promise-其他的API" class="headerlink" title="Promise 其他的API"></a>Promise 其他的API</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>如果任何一个里面的promise reject，那么all立刻reject<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">	doTask1a(),</span><br><span class="line">	doTask1b(),</span><br><span class="line">	doTask1c()</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doTask2(</span><br><span class="line">		<span class="built_in">Math</span>.max(</span><br><span class="line">			results[<span class="number">0</span>],</span><br><span class="line">			results[<span class="number">1</span>],</span><br><span class="line">			results[<span class="number">2</span>],</span><br><span class="line">		);</span><br><span class="line">	);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>只要有一个promise完成，resolve或者reject<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = trySomeAsyncThing();</span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">	p,</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">_, reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			reject(<span class="string">'timeout!'</span>);</span><br><span class="line">		&#125;, <span class="number">3000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">])</span><br><span class="line">.then(</span><br><span class="line">	success,</span><br><span class="line">	error</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Roger Guo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roger Guo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
